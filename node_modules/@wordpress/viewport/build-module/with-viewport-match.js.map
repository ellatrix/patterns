{"version":3,"sources":["@wordpress/viewport/src/with-viewport-match.js"],"names":["createHigherOrderComponent","pure","useViewportMatch","withViewportMatch","queries","queryEntries","Object","entries","useViewPortQueriesResult","fromEntries","map","key","query","operator","breakpointName","split","undefined","WrappedComponent","props","queriesResult"],"mappings":";;;AAAA;AACA;AACA;AACA,SACCA,0BADD,EAECC,IAFD,EAGCC,gBAHD,QAIO,oBAJP;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAiB,GAAKC,OAAF,IAAe;AACxC,QAAMC,YAAY,GAAGC,MAAM,CAACC,OAAP,CAAgBH,OAAhB,CAArB;;AACA,QAAMI,wBAAwB,GAAG,MAChCF,MAAM,CAACG,WAAP,CACCJ,YAAY,CAACK,GAAb,CAAkB,QAAsB;AAAA,QAApB,CAAEC,GAAF,EAAOC,KAAP,CAAoB;AACvC,QAAI,CAAEC,QAAF,EAAYC,cAAZ,IAA+BF,KAAK,CAACG,KAAN,CAAa,GAAb,CAAnC;;AACA,QAAKD,cAAc,KAAKE,SAAxB,EAAoC;AACnCF,MAAAA,cAAc,GAAGD,QAAjB;AACAA,MAAAA,QAAQ,GAAG,IAAX;AACA,KALsC,CAMvC;AACA;AACA;AACA;;;AACA,WAAO,CAAEF,GAAF,EAAOT,gBAAgB,CAAEY,cAAF,EAAkBD,QAAlB,CAAvB,CAAP;AACA,GAXD,CADD,CADD;;AAeA,SAAOb,0BAA0B,CAAIiB,gBAAF,IAAwB;AAC1D,WAAOhB,IAAI,CAAIiB,KAAF,IAAa;AACzB,YAAMC,aAAa,GAAGX,wBAAwB,EAA9C;AACA,aAAO,cAAC,gBAAD,eAAuBU,KAAvB,EAAoCC,aAApC,EAAP;AACA,KAHU,CAAX;AAIA,GALgC,EAK9B,mBAL8B,CAAjC;AAMA,CAvBD;;AAyBA,eAAehB,iBAAf","sourcesContent":["/**\n * WordPress dependencies\n */\nimport {\n\tcreateHigherOrderComponent,\n\tpure,\n\tuseViewportMatch,\n} from '@wordpress/compose';\n\n/**\n * Higher-order component creator, creating a new component which renders with\n * the given prop names, where the value passed to the underlying component is\n * the result of the query assigned as the object's value.\n *\n * @see isViewportMatch\n *\n * @param {Object} queries Object of prop name to viewport query.\n *\n * @example\n *\n * ```jsx\n * function MyComponent( { isMobile } ) {\n * \treturn (\n * \t\t<div>Currently: { isMobile ? 'Mobile' : 'Not Mobile' }</div>\n * \t);\n * }\n *\n * MyComponent = withViewportMatch( { isMobile: '< small' } )( MyComponent );\n * ```\n *\n * @return {Function} Higher-order component.\n */\nconst withViewportMatch = ( queries ) => {\n\tconst queryEntries = Object.entries( queries );\n\tconst useViewPortQueriesResult = () =>\n\t\tObject.fromEntries(\n\t\t\tqueryEntries.map( ( [ key, query ] ) => {\n\t\t\t\tlet [ operator, breakpointName ] = query.split( ' ' );\n\t\t\t\tif ( breakpointName === undefined ) {\n\t\t\t\t\tbreakpointName = operator;\n\t\t\t\t\toperator = '>=';\n\t\t\t\t}\n\t\t\t\t// Hooks should unconditionally execute in the same order,\n\t\t\t\t// we are respecting that as from the static query of the HOC we generate\n\t\t\t\t// a hook that calls other hooks always in the same order (because the query never changes).\n\t\t\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\t\t\treturn [ key, useViewportMatch( breakpointName, operator ) ];\n\t\t\t} )\n\t\t);\n\treturn createHigherOrderComponent( ( WrappedComponent ) => {\n\t\treturn pure( ( props ) => {\n\t\t\tconst queriesResult = useViewPortQueriesResult();\n\t\t\treturn <WrappedComponent { ...props } { ...queriesResult } />;\n\t\t} );\n\t}, 'withViewportMatch' );\n};\n\nexport default withViewportMatch;\n"]}