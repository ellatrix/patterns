import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { hasBlockSupport } from '@wordpress/blocks';
import { __experimentalTreeGridCell as TreeGridCell, __experimentalTreeGridItem as TreeGridItem } from '@wordpress/components';
import { useInstanceId } from '@wordpress/compose';
import { moreVertical } from '@wordpress/icons';
import { useState, useRef, useEffect, useCallback, memo } from '@wordpress/element';
import { useDispatch, useSelect } from '@wordpress/data';
import { sprintf, __ } from '@wordpress/i18n';
/**
 * Internal dependencies
 */

import ListViewLeaf from './leaf';
import useListViewScrollIntoView from './use-list-view-scroll-into-view';
import { BlockMoverUpButton, BlockMoverDownButton } from '../block-mover/button';
import ListViewBlockContents from './block-contents';
import BlockSettingsDropdown from '../block-settings-menu/block-settings-dropdown';
import { useListViewContext } from './context';
import { getBlockPositionDescription } from './utils';
import { store as blockEditorStore } from '../../store';
import useBlockDisplayInformation from '../use-block-display-information';
import { useBlockLock } from '../block-lock';

function ListViewBlock(_ref) {
  let {
    block,
    isDragged,
    isSelected,
    isBranchSelected,
    selectBlock,
    position,
    level,
    rowCount,
    siblingBlockCount,
    showBlockMovers,
    path,
    isExpanded,
    selectedClientIds,
    preventAnnouncement,
    isSyncedBranch
  } = _ref;
  const cellRef = useRef(null);
  const rowRef = useRef(null);
  const [isHovered, setIsHovered] = useState(false);
  const {
    clientId
  } = block;
  const {
    isLocked,
    isContentLocked,
    canEdit
  } = useBlockLock(clientId);
  const forceSelectionContentLock = useSelect(select => {
    if (isSelected) {
      return false;
    }

    if (!isContentLocked) {
      return false;
    }

    return select(blockEditorStore).hasSelectedInnerBlock(clientId, true);
  }, [isContentLocked, clientId, isSelected]);
  const canExpand = isContentLocked ? false : canEdit;
  const isFirstSelectedBlock = forceSelectionContentLock || isSelected && selectedClientIds[0] === clientId;
  const isLastSelectedBlock = forceSelectionContentLock || isSelected && selectedClientIds[selectedClientIds.length - 1] === clientId;
  const {
    toggleBlockHighlight
  } = useDispatch(blockEditorStore);
  const blockInformation = useBlockDisplayInformation(clientId);
  const blockName = useSelect(select => select(blockEditorStore).getBlockName(clientId), [clientId]); // When a block hides its toolbar it also hides the block settings menu,
  // since that menu is part of the toolbar in the editor canvas.
  // List View respects this by also hiding the block settings menu.

  const showBlockActions = hasBlockSupport(blockName, '__experimentalToolbar', true);
  const instanceId = useInstanceId(ListViewBlock);
  const descriptionId = `list-view-block-select-button__${instanceId}`;
  const blockPositionDescription = getBlockPositionDescription(position, siblingBlockCount, level);

  let blockAriaLabel = __('Link');

  if (blockInformation) {
    blockAriaLabel = isLocked ? sprintf( // translators: %s: The title of the block. This string indicates a link to select the locked block.
    __('%s link (locked)'), blockInformation.title) : sprintf( // translators: %s: The title of the block. This string indicates a link to select the block.
    __('%s link'), blockInformation.title);
  }

  const settingsAriaLabel = blockInformation ? sprintf( // translators: %s: The title of the block.
  __('Options for %s block'), blockInformation.title) : __('Options');
  const {
    isTreeGridMounted,
    expand,
    collapse
  } = useListViewContext();
  const hasSiblings = siblingBlockCount > 0;
  const hasRenderedMovers = showBlockMovers && hasSiblings;
  const moverCellClassName = classnames('block-editor-list-view-block__mover-cell', {
    'is-visible': isHovered || isSelected
  });
  const listViewBlockSettingsClassName = classnames('block-editor-list-view-block__menu-cell', {
    'is-visible': isHovered || isFirstSelectedBlock
  }); // If ListView has experimental features related to the Persistent List View,
  // only focus the selected list item on mount; otherwise the list would always
  // try to steal the focus from the editor canvas.

  useEffect(() => {
    if (!isTreeGridMounted && isSelected) {
      cellRef.current.focus();
    }
  }, []);
  const onMouseEnter = useCallback(() => {
    setIsHovered(true);
    toggleBlockHighlight(clientId, true);
  }, [clientId, setIsHovered, toggleBlockHighlight]);
  const onMouseLeave = useCallback(() => {
    setIsHovered(false);
    toggleBlockHighlight(clientId, false);
  }, [clientId, setIsHovered, toggleBlockHighlight]);
  const selectEditorBlock = useCallback(event => {
    selectBlock(event, clientId);
    event.preventDefault();
  }, [clientId, selectBlock]);
  const updateSelection = useCallback(newClientId => {
    selectBlock(undefined, newClientId);
  }, [selectBlock]);
  const toggleExpanded = useCallback(event => {
    // Prevent shift+click from opening link in a new window when toggling.
    event.preventDefault();
    event.stopPropagation();

    if (isExpanded === true) {
      collapse(clientId);
    } else if (isExpanded === false) {
      expand(clientId);
    }
  }, [clientId, expand, collapse, isExpanded]);
  let colSpan;

  if (hasRenderedMovers) {
    colSpan = 2;
  } else if (!showBlockActions) {
    colSpan = 3;
  }

  const classes = classnames({
    'is-selected': isSelected || forceSelectionContentLock,
    'is-first-selected': isFirstSelectedBlock,
    'is-last-selected': isLastSelectedBlock,
    'is-branch-selected': isBranchSelected,
    'is-synced-branch': isSyncedBranch,
    'is-dragging': isDragged,
    'has-single-cell': !showBlockActions,
    'is-synced': blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.isSynced
  }); // Only include all selected blocks if the currently clicked on block
  // is one of the selected blocks. This ensures that if a user attempts
  // to alter a block that isn't part of the selection, they're still able
  // to do so.

  const dropdownClientIds = selectedClientIds.includes(clientId) ? selectedClientIds : [clientId]; // Pass in a ref to the row, so that it can be scrolled
  // into view when selected. For long lists, the placeholder for the
  // selected block is also observed, within ListViewLeafPlaceholder.

  useListViewScrollIntoView({
    isSelected,
    rowItemRef: rowRef,
    selectedClientIds
  }); // Detect if there is a block in the canvas currently being edited and multi-selection is not happening.

  const currentlyEditingBlockInCanvas = isSelected && selectedClientIds.length === 1;
  return createElement(ListViewLeaf, {
    className: classes,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onFocus: onMouseEnter,
    onBlur: onMouseLeave,
    level: level,
    position: position,
    rowCount: rowCount,
    path: path,
    id: `list-view-block-${clientId}`,
    "data-block": clientId,
    isExpanded: canExpand ? isExpanded : undefined,
    "aria-selected": !!isSelected || forceSelectionContentLock,
    ref: rowRef
  }, createElement(TreeGridCell, {
    className: "block-editor-list-view-block__contents-cell",
    colSpan: colSpan,
    ref: cellRef,
    "aria-label": blockAriaLabel,
    "aria-selected": !!isSelected || forceSelectionContentLock,
    "aria-expanded": canExpand ? isExpanded : undefined,
    "aria-describedby": descriptionId
  }, _ref2 => {
    let {
      ref,
      tabIndex,
      onFocus
    } = _ref2;
    return createElement("div", {
      className: "block-editor-list-view-block__contents-container"
    }, createElement(ListViewBlockContents, {
      block: block,
      onClick: selectEditorBlock,
      onToggleExpanded: toggleExpanded,
      isSelected: isSelected,
      position: position,
      siblingBlockCount: siblingBlockCount,
      level: level,
      ref: ref,
      tabIndex: currentlyEditingBlockInCanvas ? 0 : tabIndex,
      onFocus: onFocus,
      isExpanded: isExpanded,
      selectedClientIds: selectedClientIds,
      preventAnnouncement: preventAnnouncement
    }), createElement("div", {
      className: "block-editor-list-view-block-select-button__description",
      id: descriptionId
    }, blockPositionDescription));
  }), hasRenderedMovers && createElement(Fragment, null, createElement(TreeGridCell, {
    className: moverCellClassName,
    withoutGridItem: true
  }, createElement(TreeGridItem, null, _ref3 => {
    let {
      ref,
      tabIndex,
      onFocus
    } = _ref3;
    return createElement(BlockMoverUpButton, {
      orientation: "vertical",
      clientIds: [clientId],
      ref: ref,
      tabIndex: tabIndex,
      onFocus: onFocus
    });
  }), createElement(TreeGridItem, null, _ref4 => {
    let {
      ref,
      tabIndex,
      onFocus
    } = _ref4;
    return createElement(BlockMoverDownButton, {
      orientation: "vertical",
      clientIds: [clientId],
      ref: ref,
      tabIndex: tabIndex,
      onFocus: onFocus
    });
  }))), showBlockActions && createElement(TreeGridCell, {
    className: listViewBlockSettingsClassName,
    "aria-selected": !!isSelected || forceSelectionContentLock
  }, _ref5 => {
    let {
      ref,
      tabIndex,
      onFocus
    } = _ref5;
    return createElement(BlockSettingsDropdown, {
      clientIds: dropdownClientIds,
      icon: moreVertical,
      label: settingsAriaLabel,
      toggleProps: {
        ref,
        className: 'block-editor-list-view-block__menu',
        tabIndex,
        onFocus
      },
      disableOpenOnArrowDown: true,
      __experimentalSelectBlock: updateSelection
    });
  }));
}

export default memo(ListViewBlock);
//# sourceMappingURL=block.js.map