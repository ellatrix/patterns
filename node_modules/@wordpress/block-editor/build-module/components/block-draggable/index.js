import { createElement } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { getBlockType } from '@wordpress/blocks';
import { Draggable } from '@wordpress/components';
import { useSelect, useDispatch } from '@wordpress/data';
import { useEffect, useRef } from '@wordpress/element';
/**
 * Internal dependencies
 */

import BlockDraggableChip from './draggable-chip';
import useScrollWhenDragging from './use-scroll-when-dragging';
import { store as blockEditorStore } from '../../store';

const BlockDraggable = _ref => {
  let {
    children,
    clientIds,
    cloneClassname,
    onDragStart,
    onDragEnd
  } = _ref;
  const {
    srcRootClientId,
    isDraggable,
    icon
  } = useSelect(select => {
    var _getBlockType;

    const {
      canMoveBlocks,
      getBlockRootClientId,
      getBlockName
    } = select(blockEditorStore);
    const rootClientId = getBlockRootClientId(clientIds[0]);
    const blockName = getBlockName(clientIds[0]);
    return {
      srcRootClientId: rootClientId,
      isDraggable: canMoveBlocks(clientIds, rootClientId),
      icon: (_getBlockType = getBlockType(blockName)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.icon
    };
  }, [clientIds]);
  const isDragging = useRef(false);
  const [startScrolling, scrollOnDragOver, stopScrolling] = useScrollWhenDragging();
  const {
    startDraggingBlocks,
    stopDraggingBlocks
  } = useDispatch(blockEditorStore); // Stop dragging blocks if the block draggable is unmounted.

  useEffect(() => {
    return () => {
      if (isDragging.current) {
        stopDraggingBlocks();
      }
    };
  }, []);

  if (!isDraggable) {
    return children({
      draggable: false
    });
  }

  const transferData = {
    type: 'block',
    srcClientIds: clientIds,
    srcRootClientId
  };
  return createElement(Draggable, {
    cloneClassname: cloneClassname,
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    onDragStart: event => {
      startDraggingBlocks(clientIds);
      isDragging.current = true;
      startScrolling(event);

      if (onDragStart) {
        onDragStart();
      }
    },
    onDragOver: scrollOnDragOver,
    onDragEnd: () => {
      stopDraggingBlocks();
      isDragging.current = false;
      stopScrolling();

      if (onDragEnd) {
        onDragEnd();
      }
    },
    __experimentalDragComponent: createElement(BlockDraggableChip, {
      count: clientIds.length,
      icon: icon
    })
  }, _ref2 => {
    let {
      onDraggableStart,
      onDraggableEnd
    } = _ref2;
    return children({
      draggable: true,
      onDragStart: onDraggableStart,
      onDragEnd: onDraggableEnd
    });
  });
};

export default BlockDraggable;
//# sourceMappingURL=index.js.map