{"version":3,"sources":["@wordpress/block-editor/src/components/writing-flow/use-arrow-nav.js"],"names":["computeCaretRect","focus","isHorizontalEdge","isVerticalEdge","placeCaretAtHorizontalEdge","placeCaretAtVerticalEdge","isRTL","UP","DOWN","LEFT","RIGHT","useDispatch","useSelect","useRefEffect","getBlockClientId","isInSameBlock","store","blockEditorStore","isNavigationCandidate","element","keyCode","hasModifier","isVertical","tagName","simpleInputTypes","includes","getAttribute","getClosestTabbable","target","isReverse","containerElement","onlyVertical","focusableNodes","focusable","find","reverse","slice","indexOf","targetRect","getBoundingClientRect","isTabCandidate","node","children","length","firstElementChild","tabbable","isTabbableIndex","isContentEditable","contentEditable","nodeRect","left","right","useArrowNav","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getSettings","hasMultiSelection","__unstableIsFullySelected","selectBlock","verticalRect","onMouseDown","isClosestTabbableABlock","closestTabbable","onKeyDown","event","defaultPrevented","shiftKey","ctrlKey","altKey","metaKey","isUp","isDown","isLeft","isRight","isHorizontal","isNav","isNavEdge","ownerDocument","defaultView","preventDefault","isReverseDir","keepCaretInsideBlock","undefined","getSelection","isCollapsed","addEventListener","removeEventListener"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport {\n\tcomputeCaretRect,\n\tfocus,\n\tisHorizontalEdge,\n\tisVerticalEdge,\n\tplaceCaretAtHorizontalEdge,\n\tplaceCaretAtVerticalEdge,\n\tisRTL,\n} from '@wordpress/dom';\nimport { UP, DOWN, LEFT, RIGHT } from '@wordpress/keycodes';\nimport { useDispatch, useSelect } from '@wordpress/data';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { getBlockClientId, isInSameBlock } from '../../utils/dom';\nimport { store as blockEditorStore } from '../../store';\n\n/**\n * Returns true if the element should consider edge navigation upon a keyboard\n * event of the given directional key code, or false otherwise.\n *\n * @param {Element} element     HTML element to test.\n * @param {number}  keyCode     KeyboardEvent keyCode to test.\n * @param {boolean} hasModifier Whether a modifier is pressed.\n *\n * @return {boolean} Whether element should consider edge navigation.\n */\nexport function isNavigationCandidate( element, keyCode, hasModifier ) {\n\tconst isVertical = keyCode === UP || keyCode === DOWN;\n\n\t// Currently, all elements support unmodified vertical navigation.\n\tif ( isVertical && ! hasModifier ) {\n\t\treturn true;\n\t}\n\n\tconst { tagName } = element;\n\n\t// Native inputs should not navigate horizontally, unless they are simple types that don't need left/right arrow keys.\n\tif ( tagName === 'INPUT' ) {\n\t\tconst simpleInputTypes = [\n\t\t\t'button',\n\t\t\t'checkbox',\n\t\t\t'color',\n\t\t\t'file',\n\t\t\t'image',\n\t\t\t'radio',\n\t\t\t'reset',\n\t\t\t'submit',\n\t\t];\n\t\treturn simpleInputTypes.includes( element.getAttribute( 'type' ) );\n\t}\n\n\t// Native textareas should not navigate horizontally.\n\treturn tagName !== 'TEXTAREA';\n}\n\n/**\n * Returns the optimal tab target from the given focused element in the desired\n * direction. A preference is made toward text fields, falling back to the block\n * focus stop if no other candidates exist for the block.\n *\n * @param {Element} target           Currently focused text field.\n * @param {boolean} isReverse        True if considering as the first field.\n * @param {Element} containerElement Element containing all blocks.\n * @param {boolean} onlyVertical     Whether to only consider tabbable elements\n *                                   that are visually above or under the\n *                                   target.\n *\n * @return {?Element} Optimal tab target, if one exists.\n */\nexport function getClosestTabbable(\n\ttarget,\n\tisReverse,\n\tcontainerElement,\n\tonlyVertical\n) {\n\t// Since the current focus target is not guaranteed to be a text field, find\n\t// all focusables. Tabbability is considered later.\n\tlet focusableNodes = focus.focusable.find( containerElement );\n\n\tif ( isReverse ) {\n\t\tfocusableNodes.reverse();\n\t}\n\n\t// Consider as candidates those focusables after the current target. It's\n\t// assumed this can only be reached if the target is focusable (on its\n\t// keydown event), so no need to verify it exists in the set.\n\tfocusableNodes = focusableNodes.slice(\n\t\tfocusableNodes.indexOf( target ) + 1\n\t);\n\n\tlet targetRect;\n\n\tif ( onlyVertical ) {\n\t\ttargetRect = target.getBoundingClientRect();\n\t}\n\n\tfunction isTabCandidate( node ) {\n\t\t// Skip if there's only one child that is content editable (and thus a\n\t\t// better candidate).\n\t\tif (\n\t\t\tnode.children.length === 1 &&\n\t\t\tisInSameBlock( node, node.firstElementChild ) &&\n\t\t\tnode.firstElementChild.getAttribute( 'contenteditable' ) === 'true'\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Not a candidate if the node is not tabbable.\n\t\tif ( ! focus.tabbable.isTabbableIndex( node ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Skip focusable elements such as links within content editable nodes.\n\t\tif ( node.isContentEditable && node.contentEditable !== 'true' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( onlyVertical ) {\n\t\t\tconst nodeRect = node.getBoundingClientRect();\n\n\t\t\tif (\n\t\t\t\tnodeRect.left >= targetRect.right ||\n\t\t\t\tnodeRect.right <= targetRect.left\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn focusableNodes.find( isTabCandidate );\n}\n\nexport default function useArrowNav() {\n\tconst {\n\t\tgetMultiSelectedBlocksStartClientId,\n\t\tgetMultiSelectedBlocksEndClientId,\n\t\tgetSettings,\n\t\thasMultiSelection,\n\t\t__unstableIsFullySelected,\n\t} = useSelect( blockEditorStore );\n\tconst { selectBlock } = useDispatch( blockEditorStore );\n\treturn useRefEffect( ( node ) => {\n\t\t// Here a DOMRect is stored while moving the caret vertically so\n\t\t// vertical position of the start position can be restored. This is to\n\t\t// recreate browser behaviour across blocks.\n\t\tlet verticalRect;\n\n\t\tfunction onMouseDown() {\n\t\t\tverticalRect = null;\n\t\t}\n\n\t\tfunction isClosestTabbableABlock( target, isReverse ) {\n\t\t\tconst closestTabbable = getClosestTabbable(\n\t\t\t\ttarget,\n\t\t\t\tisReverse,\n\t\t\t\tnode\n\t\t\t);\n\t\t\treturn closestTabbable && getBlockClientId( closestTabbable );\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\t\t\t// Abort if navigation has already been handled (e.g. RichText\n\t\t\t// inline boundaries).\n\t\t\tif ( event.defaultPrevented ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { keyCode, target, shiftKey, ctrlKey, altKey, metaKey } =\n\t\t\t\tevent;\n\t\t\tconst isUp = keyCode === UP;\n\t\t\tconst isDown = keyCode === DOWN;\n\t\t\tconst isLeft = keyCode === LEFT;\n\t\t\tconst isRight = keyCode === RIGHT;\n\t\t\tconst isReverse = isUp || isLeft;\n\t\t\tconst isHorizontal = isLeft || isRight;\n\t\t\tconst isVertical = isUp || isDown;\n\t\t\tconst isNav = isHorizontal || isVertical;\n\t\t\tconst hasModifier = shiftKey || ctrlKey || altKey || metaKey;\n\t\t\tconst isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;\n\t\t\tconst { ownerDocument } = node;\n\t\t\tconst { defaultView } = ownerDocument;\n\n\t\t\tif ( ! isNav ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there is a multi-selection, the arrow keys should collapse the\n\t\t\t// selection to the start or end of the selection.\n\t\t\tif ( hasMultiSelection() ) {\n\t\t\t\tif ( shiftKey ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Only handle if we have a full selection (not a native partial\n\t\t\t\t// selection).\n\t\t\t\tif ( ! __unstableIsFullySelected() ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tif ( isReverse ) {\n\t\t\t\t\tselectBlock( getMultiSelectedBlocksStartClientId() );\n\t\t\t\t} else {\n\t\t\t\t\tselectBlock( getMultiSelectedBlocksEndClientId(), -1 );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Abort if our current target is not a candidate for navigation\n\t\t\t// (e.g. preserve native input behaviors).\n\t\t\tif ( ! isNavigationCandidate( target, keyCode, hasModifier ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// When presing any key other than up or down, the initial vertical\n\t\t\t// position must ALWAYS be reset. The vertical position is saved so\n\t\t\t// it can be restored as well as possible on sebsequent vertical\n\t\t\t// arrow key presses. It may not always be possible to restore the\n\t\t\t// exact same position (such as at an empty line), so it wouldn't be\n\t\t\t// good to compute the position right before any vertical arrow key\n\t\t\t// press.\n\t\t\tif ( ! isVertical ) {\n\t\t\t\tverticalRect = null;\n\t\t\t} else if ( ! verticalRect ) {\n\t\t\t\tverticalRect = computeCaretRect( defaultView );\n\t\t\t}\n\n\t\t\t// In the case of RTL scripts, right means previous and left means\n\t\t\t// next, which is the exact reverse of LTR.\n\t\t\tconst isReverseDir = isRTL( target ) ? ! isReverse : isReverse;\n\t\t\tconst { keepCaretInsideBlock } = getSettings();\n\n\t\t\tif ( shiftKey ) {\n\t\t\t\tif (\n\t\t\t\t\tisClosestTabbableABlock( target, isReverse ) &&\n\t\t\t\t\tisNavEdge( target, isReverse )\n\t\t\t\t) {\n\t\t\t\t\tnode.contentEditable = true;\n\t\t\t\t\t// Firefox doesn't automatically move focus.\n\t\t\t\t\tnode.focus();\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tisVertical &&\n\t\t\t\tisVerticalEdge( target, isReverse ) &&\n\t\t\t\t// When Alt is pressed, only intercept if the caret is also at\n\t\t\t\t// the horizontal edge.\n\t\t\t\t( altKey ? isHorizontalEdge( target, isReverseDir ) : true ) &&\n\t\t\t\t! keepCaretInsideBlock\n\t\t\t) {\n\t\t\t\tconst closestTabbable = getClosestTabbable(\n\t\t\t\t\ttarget,\n\t\t\t\t\tisReverse,\n\t\t\t\t\tnode,\n\t\t\t\t\ttrue\n\t\t\t\t);\n\n\t\t\t\tif ( closestTabbable ) {\n\t\t\t\t\tplaceCaretAtVerticalEdge(\n\t\t\t\t\t\tclosestTabbable,\n\t\t\t\t\t\t// When Alt is pressed, place the caret at the furthest\n\t\t\t\t\t\t// horizontal edge and the furthest vertical edge.\n\t\t\t\t\t\taltKey ? ! isReverse : isReverse,\n\t\t\t\t\t\taltKey ? undefined : verticalRect\n\t\t\t\t\t);\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tisHorizontal &&\n\t\t\t\tdefaultView.getSelection().isCollapsed &&\n\t\t\t\tisHorizontalEdge( target, isReverseDir ) &&\n\t\t\t\t! keepCaretInsideBlock\n\t\t\t) {\n\t\t\t\tconst closestTabbable = getClosestTabbable(\n\t\t\t\t\ttarget,\n\t\t\t\t\tisReverseDir,\n\t\t\t\t\tnode\n\t\t\t\t);\n\t\t\t\tplaceCaretAtHorizontalEdge( closestTabbable, isReverse );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\n\t\tnode.addEventListener( 'mousedown', onMouseDown );\n\t\tnode.addEventListener( 'keydown', onKeyDown );\n\t\treturn () => {\n\t\t\tnode.removeEventListener( 'mousedown', onMouseDown );\n\t\t\tnode.removeEventListener( 'keydown', onKeyDown );\n\t\t};\n\t}, [] );\n}\n"]}