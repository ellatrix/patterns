import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import { kebabCase } from 'lodash';
/**
 * WordPress dependencies
 */

import { createHigherOrderComponent, useInstanceId } from '@wordpress/compose';
import { addFilter } from '@wordpress/hooks';
import { getBlockSupport, hasBlockSupport } from '@wordpress/blocks';
import { useSelect } from '@wordpress/data';
import { Button, ButtonGroup, ToggleControl, PanelBody } from '@wordpress/components';
import { __ } from '@wordpress/i18n';
import { useContext, createPortal } from '@wordpress/element';
/**
 * Internal dependencies
 */

import { store as blockEditorStore } from '../store';
import { InspectorControls } from '../components';
import useSetting from '../components/use-setting';
import { LayoutStyle } from '../components/block-list/layout';
import BlockList from '../components/block-list';
import { getLayoutType, getLayoutTypes } from '../layouts';
const layoutBlockSupportKey = '__experimentalLayout';
/**
 * Generates the utility classnames for the given block's layout attributes.
 *
 * @param { Object } block Block object.
 *
 * @return { Array } Array of CSS classname strings.
 */

export function useLayoutClasses() {
  var _globalLayoutSettings, _globalLayoutSettings2;

  let block = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const rootPaddingAlignment = useSelect(select => {
    var _getSettings$__experi;

    const {
      getSettings
    } = select(blockEditorStore);
    return (_getSettings$__experi = getSettings().__experimentalFeatures) === null || _getSettings$__experi === void 0 ? void 0 : _getSettings$__experi.useRootPaddingAwareAlignments;
  }, []);
  const globalLayoutSettings = useSetting('layout') || {};
  const {
    attributes = {},
    name
  } = block;
  const {
    layout
  } = attributes;
  const {
    default: defaultBlockLayout
  } = getBlockSupport(name, layoutBlockSupportKey) || {};
  const usedLayout = layout !== null && layout !== void 0 && layout.inherit || layout !== null && layout !== void 0 && layout.contentSize || layout !== null && layout !== void 0 && layout.wideSize ? { ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const layoutClassnames = [];

  if (globalLayoutSettings !== null && globalLayoutSettings !== void 0 && (_globalLayoutSettings = globalLayoutSettings.definitions) !== null && _globalLayoutSettings !== void 0 && (_globalLayoutSettings2 = _globalLayoutSettings[(usedLayout === null || usedLayout === void 0 ? void 0 : usedLayout.type) || 'default']) !== null && _globalLayoutSettings2 !== void 0 && _globalLayoutSettings2.className) {
    var _globalLayoutSettings3, _globalLayoutSettings4;

    layoutClassnames.push(globalLayoutSettings === null || globalLayoutSettings === void 0 ? void 0 : (_globalLayoutSettings3 = globalLayoutSettings.definitions) === null || _globalLayoutSettings3 === void 0 ? void 0 : (_globalLayoutSettings4 = _globalLayoutSettings3[(usedLayout === null || usedLayout === void 0 ? void 0 : usedLayout.type) || 'default']) === null || _globalLayoutSettings4 === void 0 ? void 0 : _globalLayoutSettings4.className);
  }

  if ((usedLayout !== null && usedLayout !== void 0 && usedLayout.inherit || usedLayout !== null && usedLayout !== void 0 && usedLayout.contentSize || (usedLayout === null || usedLayout === void 0 ? void 0 : usedLayout.type) === 'constrained') && rootPaddingAlignment) {
    layoutClassnames.push('has-global-padding');
  }

  if (usedLayout !== null && usedLayout !== void 0 && usedLayout.orientation) {
    layoutClassnames.push(`is-${kebabCase(usedLayout.orientation)}`);
  }

  if (usedLayout !== null && usedLayout !== void 0 && usedLayout.justifyContent) {
    layoutClassnames.push(`is-content-justification-${kebabCase(usedLayout.justifyContent)}`);
  }

  if (usedLayout !== null && usedLayout !== void 0 && usedLayout.flexWrap && usedLayout.flexWrap === 'nowrap') {
    layoutClassnames.push('is-nowrap');
  }

  return layoutClassnames;
}
/**
 * Generates a CSS rule with the given block's layout styles.
 *
 * @param { Object } block    Block object.
 * @param { string } selector A selector to use in generating the CSS rule.
 *
 * @return { string } CSS rule.
 */

export function useLayoutStyles() {
  var _fullLayoutType$getLa;

  let block = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let selector = arguments.length > 1 ? arguments[1] : undefined;
  const {
    attributes = {},
    name
  } = block;
  const {
    layout = {},
    style = {}
  } = attributes; // Update type for blocks using legacy layouts.

  const usedLayout = layout !== null && layout !== void 0 && layout.inherit || layout !== null && layout !== void 0 && layout.contentSize || layout !== null && layout !== void 0 && layout.wideSize ? { ...layout,
    type: 'constrained'
  } : layout || {};
  const fullLayoutType = getLayoutType((usedLayout === null || usedLayout === void 0 ? void 0 : usedLayout.type) || 'default');
  const globalLayoutSettings = useSetting('layout') || {};
  const blockGapSupport = useSetting('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null;
  const css = fullLayoutType === null || fullLayoutType === void 0 ? void 0 : (_fullLayoutType$getLa = fullLayoutType.getLayoutStyle) === null || _fullLayoutType$getLa === void 0 ? void 0 : _fullLayoutType$getLa.call(fullLayoutType, {
    blockName: name,
    selector,
    layout,
    layoutDefinitions: globalLayoutSettings === null || globalLayoutSettings === void 0 ? void 0 : globalLayoutSettings.definitions,
    style,
    hasBlockGapSupport
  });
  return css;
}

function LayoutPanel(_ref) {
  let {
    clientId,
    setAttributes,
    attributes,
    name: blockName
  } = _ref;
  const {
    layout
  } = attributes;
  const defaultThemeLayout = useSetting('layout');
  const {
    themeSupportsLayout,
    isContentLocked
  } = useSelect(select => {
    const {
      getSettings,
      __unstableGetContentLockingParent
    } = select(blockEditorStore);
    return {
      themeSupportsLayout: getSettings().supportsLayout,
      isContentLocked: __unstableGetContentLockingParent(clientId)
    };
  }, [clientId]);
  const layoutBlockSupport = getBlockSupport(blockName, layoutBlockSupportKey, {});
  const {
    allowSwitching,
    allowEditing = true,
    allowInheriting = true,
    default: defaultBlockLayout
  } = layoutBlockSupport;

  if (!allowEditing) {
    return null;
  } // Only show the inherit toggle if it's supported,
  // a default theme layout is set (e.g. one that provides `contentSize` and/or `wideSize` values),
  // and either the default / flow or the constrained layout type is in use, as the toggle switches from one to the other.


  const showInheritToggle = !!(allowInheriting && !!defaultThemeLayout && (!(layout !== null && layout !== void 0 && layout.type) || (layout === null || layout === void 0 ? void 0 : layout.type) === 'default' || (layout === null || layout === void 0 ? void 0 : layout.type) === 'constrained' || layout !== null && layout !== void 0 && layout.inherit));
  const usedLayout = layout || defaultBlockLayout || {};
  const {
    inherit = false,
    type = 'default',
    contentSize = null
  } = usedLayout;
  /**
   * `themeSupportsLayout` is only relevant to the `default/flow` or
   * `constrained` layouts and it should not be taken into account when other
   * `layout` types are used.
   */

  if ((type === 'default' || type === 'constrained') && !themeSupportsLayout) {
    return null;
  }

  const layoutType = getLayoutType(type);
  const constrainedType = getLayoutType('constrained');
  const displayControlsForLegacyLayouts = !usedLayout.type && (contentSize || inherit);
  const hasContentSizeOrLegacySettings = !!inherit || !!contentSize;

  const onChangeType = newType => setAttributes({
    layout: {
      type: newType
    }
  });

  const onChangeLayout = newLayout => setAttributes({
    layout: newLayout
  });

  return createElement(Fragment, null, createElement(InspectorControls, null, createElement(PanelBody, {
    title: __('Layout')
  }, showInheritToggle && createElement(Fragment, null, createElement(ToggleControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-hooks__toggle-control",
    label: __('Inner blocks use content width'),
    checked: (layoutType === null || layoutType === void 0 ? void 0 : layoutType.name) === 'constrained' || hasContentSizeOrLegacySettings,
    onChange: () => setAttributes({
      layout: {
        type: (layoutType === null || layoutType === void 0 ? void 0 : layoutType.name) === 'constrained' || hasContentSizeOrLegacySettings ? 'default' : 'constrained'
      }
    }),
    help: (layoutType === null || layoutType === void 0 ? void 0 : layoutType.name) === 'constrained' || hasContentSizeOrLegacySettings ? __('Nested blocks use content width with options for full and wide widths.') : __('Nested blocks will fill the width of this container. Toggle to constrain.')
  })), !inherit && allowSwitching && createElement(LayoutTypeSwitcher, {
    type: type,
    onChange: onChangeType
  }), layoutType && layoutType.name !== 'default' && createElement(layoutType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }), constrainedType && displayControlsForLegacyLayouts && createElement(constrainedType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }))), !inherit && !isContentLocked && layoutType && createElement(layoutType.toolBarControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }));
}

function LayoutTypeSwitcher(_ref2) {
  let {
    type,
    onChange
  } = _ref2;
  return createElement(ButtonGroup, null, getLayoutTypes().map(_ref3 => {
    let {
      name,
      label
    } = _ref3;
    return createElement(Button, {
      key: name,
      isPressed: type === name,
      onClick: () => onChange(name)
    }, label);
  }));
}
/**
 * Filters registered block settings, extending attributes to include `layout`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


export function addAttribute(settings) {
  var _settings$attributes$, _settings$attributes;

  if ('type' in ((_settings$attributes$ = (_settings$attributes = settings.attributes) === null || _settings$attributes === void 0 ? void 0 : _settings$attributes.layout) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }

  if (hasBlockSupport(settings, layoutBlockSupportKey)) {
    settings.attributes = { ...settings.attributes,
      layout: {
        type: 'object'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include layout controls
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */

export const withInspectorControls = createHigherOrderComponent(BlockEdit => props => {
  const {
    name: blockName
  } = props;
  const supportLayout = hasBlockSupport(blockName, layoutBlockSupportKey);
  return [supportLayout && createElement(LayoutPanel, _extends({
    key: "layout"
  }, props)), createElement(BlockEdit, _extends({
    key: "edit"
  }, props))];
}, 'withInspectorControls');
/**
 * Override the default block element to add the layout styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

export const withLayoutStyles = createHigherOrderComponent(BlockListBlock => props => {
  const {
    name,
    attributes,
    block
  } = props;
  const hasLayoutBlockSupport = hasBlockSupport(name, layoutBlockSupportKey);
  const disableLayoutStyles = useSelect(select => {
    const {
      getSettings
    } = select(blockEditorStore);
    return !!getSettings().disableLayoutStyles;
  });
  const shouldRenderLayoutStyles = hasLayoutBlockSupport && !disableLayoutStyles;
  const id = useInstanceId(BlockListBlock);
  const defaultThemeLayout = useSetting('layout') || {};
  const element = useContext(BlockList.__unstableElementContext);
  const {
    layout
  } = attributes;
  const {
    default: defaultBlockLayout
  } = getBlockSupport(name, layoutBlockSupportKey) || {};
  const usedLayout = layout !== null && layout !== void 0 && layout.inherit || layout !== null && layout !== void 0 && layout.contentSize || layout !== null && layout !== void 0 && layout.wideSize ? { ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const layoutClasses = hasLayoutBlockSupport ? useLayoutClasses(block) : null; // Higher specificity to override defaults from theme.json.

  const selector = `.wp-container-${id}.wp-container-${id}`;
  const blockGapSupport = useSetting('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null; // Get CSS string for the current layout type.
  // The CSS and `style` element is only output if it is not empty.

  let css;

  if (shouldRenderLayoutStyles) {
    var _fullLayoutType$getLa2;

    const fullLayoutType = getLayoutType((usedLayout === null || usedLayout === void 0 ? void 0 : usedLayout.type) || 'default');
    css = fullLayoutType === null || fullLayoutType === void 0 ? void 0 : (_fullLayoutType$getLa2 = fullLayoutType.getLayoutStyle) === null || _fullLayoutType$getLa2 === void 0 ? void 0 : _fullLayoutType$getLa2.call(fullLayoutType, {
      blockName: name,
      selector,
      layout: usedLayout,
      layoutDefinitions: defaultThemeLayout === null || defaultThemeLayout === void 0 ? void 0 : defaultThemeLayout.definitions,
      style: attributes === null || attributes === void 0 ? void 0 : attributes.style,
      hasBlockGapSupport
    });
  } // Attach a `wp-container-` id-based class name as well as a layout class name such as `is-layout-flex`.


  const layoutClassNames = classnames({
    [`wp-container-${id}`]: shouldRenderLayoutStyles && !!css // Only attach a container class if there is generated CSS to be attached.

  }, layoutClasses);
  return createElement(Fragment, null, shouldRenderLayoutStyles && element && !!css && createPortal(createElement(LayoutStyle, {
    blockName: name,
    selector: selector,
    css: css,
    layout: usedLayout,
    style: attributes === null || attributes === void 0 ? void 0 : attributes.style
  }), element), createElement(BlockListBlock, _extends({}, props, {
    __unstableLayoutClassNames: layoutClassNames
  })));
});
/**
 * Override the default block element to add the child layout styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

export const withChildLayoutStyles = createHigherOrderComponent(BlockListBlock => props => {
  const {
    attributes
  } = props;
  const {
    style: {
      layout = {}
    } = {}
  } = attributes;
  const {
    selfStretch,
    flexSize
  } = layout;
  const hasChildLayout = selfStretch || flexSize;
  const disableLayoutStyles = useSelect(select => {
    const {
      getSettings
    } = select(blockEditorStore);
    return !!getSettings().disableLayoutStyles;
  });
  const shouldRenderChildLayoutStyles = hasChildLayout && !disableLayoutStyles;
  const element = useContext(BlockList.__unstableElementContext);
  const id = useInstanceId(BlockListBlock);
  const selector = `.wp-container-content-${id}`;
  let css = '';

  if (selfStretch === 'fixed' && flexSize) {
    css += `${selector} {
				flex-basis: ${flexSize};
				box-sizing: border-box;
			}`;
  } else if (selfStretch === 'fill') {
    css += `${selector} {
				flex-grow: 1;
			}`;
  } // Attach a `wp-container-content` id-based classname.


  const className = classnames(props === null || props === void 0 ? void 0 : props.className, {
    [`wp-container-content-${id}`]: shouldRenderChildLayoutStyles && !!css // Only attach a container class if there is generated CSS to be attached.

  });
  return createElement(Fragment, null, shouldRenderChildLayoutStyles && element && !!css && createPortal(createElement("style", null, css), element), createElement(BlockListBlock, _extends({}, props, {
    className: className
  })));
});
addFilter('blocks.registerBlockType', 'core/layout/addAttribute', addAttribute);
addFilter('editor.BlockListBlock', 'core/editor/layout/with-layout-styles', withLayoutStyles);
addFilter('editor.BlockListBlock', 'core/editor/layout/with-child-layout-styles', withChildLayoutStyles);
addFilter('editor.BlockEdit', 'core/editor/layout/with-inspector-controls', withInspectorControls);
//# sourceMappingURL=layout.js.map