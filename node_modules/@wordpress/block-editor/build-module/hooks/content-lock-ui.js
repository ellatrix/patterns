import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement, Fragment } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { ToolbarButton, MenuItem } from '@wordpress/components';
import { createHigherOrderComponent } from '@wordpress/compose';
import { useDispatch, useSelect } from '@wordpress/data';
import { addFilter } from '@wordpress/hooks';
import { __ } from '@wordpress/i18n';
import { useEffect, useRef, useCallback } from '@wordpress/element';
/**
 * Internal dependencies
 */

import { store as blockEditorStore } from '../store';
import { BlockControls, BlockSettingsMenuControls } from '../components';
/**
 * External dependencies
 */

import classnames from 'classnames';

function StopEditingAsBlocksOnOutsideSelect(_ref) {
  let {
    clientId,
    stopEditingAsBlock
  } = _ref;
  const isBlockOrDescendantSelected = useSelect(select => {
    const {
      isBlockSelected,
      hasSelectedInnerBlock
    } = select(blockEditorStore);
    return isBlockSelected(clientId) || hasSelectedInnerBlock(clientId, true);
  }, [clientId]);
  useEffect(() => {
    if (!isBlockOrDescendantSelected) {
      stopEditingAsBlock();
    }
  }, [isBlockOrDescendantSelected]);
  return null;
}

export const withBlockControls = createHigherOrderComponent(BlockEdit => props => {
  const {
    getBlockListSettings,
    getSettings
  } = useSelect(blockEditorStore);
  const focusModeToRevert = useRef();
  const {
    templateLock,
    isLockedByParent,
    isEditingAsBlocks
  } = useSelect(select => {
    const {
      __unstableGetContentLockingParent,
      getTemplateLock,
      __unstableGetTemporarilyEditingAsBlocks
    } = select(blockEditorStore);
    return {
      templateLock: getTemplateLock(props.clientId),
      isLockedByParent: !!__unstableGetContentLockingParent(props.clientId),
      isEditingAsBlocks: __unstableGetTemporarilyEditingAsBlocks() === props.clientId
    };
  }, [props.clientId]);
  const {
    updateSettings,
    updateBlockListSettings,
    __unstableSetTemporarilyEditingAsBlocks
  } = useDispatch(blockEditorStore);
  const isContentLocked = !isLockedByParent && templateLock === 'contentOnly';
  const {
    __unstableMarkNextChangeAsNotPersistent,
    updateBlockAttributes
  } = useDispatch(blockEditorStore);
  const stopEditingAsBlock = useCallback(() => {
    __unstableMarkNextChangeAsNotPersistent();

    updateBlockAttributes(props.clientId, {
      templateLock: 'contentOnly'
    });
    updateBlockListSettings(props.clientId, { ...getBlockListSettings(props.clientId),
      templateLock: 'contentOnly'
    });
    updateSettings({
      focusMode: focusModeToRevert.current
    });

    __unstableSetTemporarilyEditingAsBlocks();
  }, [props.clientId, focusModeToRevert, updateSettings, updateBlockListSettings, getBlockListSettings, __unstableMarkNextChangeAsNotPersistent, updateBlockAttributes, __unstableSetTemporarilyEditingAsBlocks]);

  if (!isContentLocked && !isEditingAsBlocks) {
    return createElement(BlockEdit, props);
  }

  return createElement(Fragment, null, isEditingAsBlocks && !isContentLocked && createElement(Fragment, null, createElement(StopEditingAsBlocksOnOutsideSelect, {
    clientId: props.clientId,
    stopEditingAsBlock: stopEditingAsBlock
  }), createElement(BlockControls, {
    group: "other"
  }, createElement(ToolbarButton, {
    onClick: () => {
      stopEditingAsBlock();
    }
  }, __('Done')))), !isEditingAsBlocks && isContentLocked && props.isSelected && createElement(BlockSettingsMenuControls, null, _ref2 => {
    let {
      onClose
    } = _ref2;
    return createElement(MenuItem, {
      onClick: () => {
        __unstableMarkNextChangeAsNotPersistent();

        updateBlockAttributes(props.clientId, {
          templateLock: undefined
        });
        updateBlockListSettings(props.clientId, { ...getBlockListSettings(props.clientId),
          templateLock: false
        });
        focusModeToRevert.current = getSettings().focusMode;
        updateSettings({
          focusMode: true
        });

        __unstableSetTemporarilyEditingAsBlocks(props.clientId);

        onClose();
      }
    }, __('Modify'));
  }), createElement(BlockEdit, _extends({}, props, {
    className: classnames(props.className, isEditingAsBlocks && 'is-content-locked-editing-as-blocks')
  })));
}, 'withToolbarControls');
addFilter('editor.BlockEdit', 'core/content-lock-ui/with-block-controls', withBlockControls);
//# sourceMappingURL=content-lock-ui.js.map