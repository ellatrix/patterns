"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanEmptyObject = void 0;
exports.immutableSet = immutableSet;
exports.shouldSkipSerialization = shouldSkipSerialization;
exports.transformStyles = transformStyles;
exports.useBlockSettings = useBlockSettings;

var _lodash = require("lodash");

var _blocks = require("@wordpress/blocks");

var _element = require("@wordpress/element");

var _components = require("../components");

var _hooks = require("../components/global-styles/hooks");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Removed falsy values from nested object.
 *
 * @param {*} object
 * @return {*} Object cleaned from falsy values
 */
const cleanEmptyObject = object => {
  if (object === null || typeof object !== 'object' || Array.isArray(object)) {
    return object;
  }

  const cleanedNestedObjects = Object.fromEntries(Object.entries((0, _lodash.mapValues)(object, cleanEmptyObject)).filter(_ref => {
    let [, value] = _ref;
    return Boolean(value);
  }));
  return (0, _lodash.isEmpty)(cleanedNestedObjects) ? undefined : cleanedNestedObjects;
};
/**
 * Converts a path to an array of its fragments.
 * Supports strings, numbers and arrays:
 *
 * 'foo' => [ 'foo' ]
 * 2 => [ '2' ]
 * [ 'foo', 'bar' ] => [ 'foo', 'bar' ]
 *
 * @param {string|number|Array} path Path
 * @return {Array} Normalized path.
 */


exports.cleanEmptyObject = cleanEmptyObject;

function normalizePath(path) {
  if (Array.isArray(path)) {
    return path;
  } else if (typeof path === 'number') {
    return [path.toString()];
  }

  return [path];
}
/**
 * Clones an object.
 * Non-object values are returned unchanged.
 *
 * @param {*} object Object to clone.
 * @return {*} Cloned object, or original literal non-object value.
 */


function cloneObject(object) {
  if (typeof object === 'object') {
    return { ...Object.fromEntries(Object.entries(object).map(_ref2 => {
        let [key, value] = _ref2;
        return [key, cloneObject(value)];
      }))
    };
  }

  return object;
}
/**
 * Perform an immutable set.
 * Handles nullish initial values.
 * Clones all nested objects in the specified object.
 *
 * @param {Object}              object Object to set a value in.
 * @param {number|string|Array} path   Path in the object to modify.
 * @param {*}                   value  New value to set.
 * @return {Object} Cloned object with the new value set.
 */


function immutableSet(object, path, value) {
  const normalizedPath = normalizePath(path);
  const newObject = object ? cloneObject(object) : {};
  normalizedPath.reduce((acc, key, i) => {
    if (acc[key] === undefined) {
      acc[key] = {};
    }

    if (i === normalizedPath.length - 1) {
      acc[key] = value;
    }

    return acc[key];
  }, newObject);
  return newObject;
}

function transformStyles(activeSupports, migrationPaths, result, source, index, results) {
  var _source$;

  // If there are no active supports return early.
  if (Object.values(activeSupports !== null && activeSupports !== void 0 ? activeSupports : {}).every(isActive => !isActive)) {
    return result;
  } // If the condition verifies we are probably in the presence of a wrapping transform
  // e.g: nesting paragraphs in a group or columns and in that case the styles should not be transformed.


  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  } // For cases where we have a transform from one block to multiple blocks
  // or multiple blocks to one block we apply the styles of the first source block
  // to the result(s).


  let referenceBlockAttributes = (_source$ = source[0]) === null || _source$ === void 0 ? void 0 : _source$.attributes; // If we are in presence of transform between more than one block in the source
  // that has more than one block in the result
  // we apply the styles on source N to the result N,
  // if source N does not exists we do nothing.

  if (results.length > 1 && source.length > 1) {
    if (source[index]) {
      var _source$index;

      referenceBlockAttributes = (_source$index = source[index]) === null || _source$index === void 0 ? void 0 : _source$index.attributes;
    } else {
      return result;
    }
  }

  let returnBlock = result;
  Object.entries(activeSupports).forEach(_ref3 => {
    let [support, isActive] = _ref3;

    if (isActive) {
      migrationPaths[support].forEach(path => {
        const styleValue = (0, _lodash.get)(referenceBlockAttributes, path);

        if (styleValue) {
          returnBlock = { ...returnBlock,
            attributes: immutableSet(returnBlock.attributes, path, styleValue)
          };
        }
      });
    }
  });
  return returnBlock;
}
/**
 * Check whether serialization of specific block support feature or set should
 * be skipped.
 *
 * @param {string|Object} blockType  Block name or block type object.
 * @param {string}        featureSet Name of block support feature set.
 * @param {string}        feature    Name of the individual feature to check.
 *
 * @return {boolean} Whether serialization should occur.
 */


function shouldSkipSerialization(blockType, featureSet, feature) {
  const support = (0, _blocks.getBlockSupport)(blockType, featureSet);
  const skipSerialization = support === null || support === void 0 ? void 0 : support.__experimentalSkipSerialization;

  if (Array.isArray(skipSerialization)) {
    return skipSerialization.includes(feature);
  }

  return skipSerialization;
}
/**
 * Based on the block and its context, returns an object of all the block settings.
 * This object can be passed as a prop to all the Styles UI components
 * (TypographyPanel, DimensionsPanel...).
 *
 * @param {string} name         Block name.
 * @param {*}      parentLayout Parent layout.
 *
 * @return {Object} Settings object.
 */


function useBlockSettings(name, parentLayout) {
  const fontFamilies = (0, _components.useSetting)('typography.fontFamilies');
  const fontSizes = (0, _components.useSetting)('typography.fontSizes');
  const customFontSize = (0, _components.useSetting)('typography.customFontSize');
  const fontStyle = (0, _components.useSetting)('typography.fontStyle');
  const fontWeight = (0, _components.useSetting)('typography.fontWeight');
  const lineHeight = (0, _components.useSetting)('typography.lineHeight');
  const textDecoration = (0, _components.useSetting)('typography.textDecoration');
  const textTransform = (0, _components.useSetting)('typography.textTransform');
  const letterSpacing = (0, _components.useSetting)('typography.letterSpacing');
  const padding = (0, _components.useSetting)('spacing.padding');
  const margin = (0, _components.useSetting)('spacing.margin');
  const blockGap = (0, _components.useSetting)('spacing.blockGap');
  const spacingSizes = (0, _components.useSetting)('spacing.spacingSizes');
  const units = (0, _components.useSetting)('spacing.units');
  const minHeight = (0, _components.useSetting)('dimensions.minHeight');
  const layout = (0, _components.useSetting)('layout');
  const rawSettings = (0, _element.useMemo)(() => {
    return {
      typography: {
        fontFamilies: {
          custom: fontFamilies
        },
        fontSizes: {
          custom: fontSizes
        },
        customFontSize,
        fontStyle,
        fontWeight,
        lineHeight,
        textDecoration,
        textTransform,
        letterSpacing
      },
      spacing: {
        spacingSizes: {
          custom: spacingSizes
        },
        padding,
        margin,
        blockGap,
        units
      },
      dimensions: {
        minHeight
      },
      layout,
      parentLayout
    };
  }, [fontFamilies, fontSizes, customFontSize, fontStyle, fontWeight, lineHeight, textDecoration, textTransform, letterSpacing, padding, margin, blockGap, spacingSizes, units, minHeight, layout, parentLayout]);
  return (0, _hooks.useSettingsForBlockElement)(rawSettings, name);
}
//# sourceMappingURL=utils.js.map