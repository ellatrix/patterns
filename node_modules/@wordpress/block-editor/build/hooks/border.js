"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BORDER_SUPPORT_KEY = void 0;
exports.BorderPanel = BorderPanel;
exports.getBorderClasses = getBorderClasses;
exports.getMultiOriginColor = void 0;
exports.hasBorderSupport = hasBorderSupport;
exports.removeBorderAttribute = removeBorderAttribute;
exports.withBorderColorPaletteStyles = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _blocks = require("@wordpress/blocks");

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _hooks = require("@wordpress/hooks");

var _i18n = require("@wordpress/i18n");

var _borderRadius = require("./border-radius");

var _colors = require("../components/colors");

var _inspectorControls = _interopRequireDefault(require("../components/inspector-controls"));

var _useMultipleOriginColorsAndGradients = _interopRequireDefault(require("../components/colors-gradients/use-multiple-origin-colors-and-gradients"));

var _useSetting = _interopRequireDefault(require("../components/use-setting"));

var _utils = require("./utils");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const BORDER_SUPPORT_KEY = '__experimentalBorder';
exports.BORDER_SUPPORT_KEY = BORDER_SUPPORT_KEY;
const borderSides = ['top', 'right', 'bottom', 'left'];

const hasBorderValue = props => {
  const {
    borderColor,
    style
  } = props.attributes;
  return (0, _components.__experimentalIsDefinedBorder)(style === null || style === void 0 ? void 0 : style.border) || !!borderColor;
}; // The border color, style, and width are omitted so they get undefined. The
// border radius is separate and must retain its selection.


const resetBorder = _ref => {
  var _style$border;

  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    borderColor: undefined,
    style: { ...style,
      border: (0, _utils.cleanEmptyObject)({
        radius: style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.radius
      })
    }
  });
};

const resetBorderFilter = newAttributes => {
  var _newAttributes$style, _newAttributes$style$;

  return { ...newAttributes,
    borderColor: undefined,
    style: { ...newAttributes.style,
      border: {
        radius: (_newAttributes$style = newAttributes.style) === null || _newAttributes$style === void 0 ? void 0 : (_newAttributes$style$ = _newAttributes$style.border) === null || _newAttributes$style$ === void 0 ? void 0 : _newAttributes$style$.radius
      }
    }
  };
};

const getColorByProperty = (colors, property, value) => {
  let matchedColor;
  colors.some(origin => origin.colors.some(color => {
    if (color[property] === value) {
      matchedColor = color;
      return true;
    }

    return false;
  }));
  return matchedColor;
};

const getMultiOriginColor = _ref2 => {
  let {
    colors,
    namedColor,
    customColor
  } = _ref2;

  // Search each origin (default, theme, or user) for matching color by name.
  if (namedColor) {
    const colorObject = getColorByProperty(colors, 'slug', namedColor);

    if (colorObject) {
      return colorObject;
    }
  } // Skip if no custom color or matching named color.


  if (!customColor) {
    return {
      color: undefined
    };
  } // Attempt to find color via custom color value or build new object.


  const colorObject = getColorByProperty(colors, 'color', customColor);
  return colorObject ? colorObject : {
    color: customColor
  };
};

exports.getMultiOriginColor = getMultiOriginColor;

const getBorderObject = (attributes, colors) => {
  const {
    borderColor,
    style
  } = attributes;
  const {
    border: borderStyles
  } = style || {}; // If we have a named color for a flat border. Fetch that color object and
  // apply that color's value to the color property within the style object.

  if (borderColor) {
    const {
      color
    } = getMultiOriginColor({
      colors,
      namedColor: borderColor
    });
    return color ? { ...borderStyles,
      color
    } : borderStyles;
  } // Individual side border color slugs are stored within the border style
  // object. If we don't have a border styles object we have nothing further
  // to hydrate.


  if (!borderStyles) {
    return borderStyles;
  } // If we have named colors for the individual side borders, retrieve their
  // related color objects and apply the real color values to the split
  // border objects.


  const hydratedBorderStyles = { ...borderStyles
  };
  borderSides.forEach(side => {
    var _hydratedBorderStyles;

    const colorSlug = getColorSlugFromVariable((_hydratedBorderStyles = hydratedBorderStyles[side]) === null || _hydratedBorderStyles === void 0 ? void 0 : _hydratedBorderStyles.color);

    if (colorSlug) {
      const {
        color
      } = getMultiOriginColor({
        colors,
        namedColor: colorSlug
      });
      hydratedBorderStyles[side] = { ...hydratedBorderStyles[side],
        color
      };
    }
  });
  return hydratedBorderStyles;
};

function getColorSlugFromVariable(value) {
  const namedColor = /var:preset\|color\|(.+)/.exec(value);

  if (namedColor && namedColor[1]) {
    return namedColor[1];
  }

  return null;
}

function BorderPanel(props) {
  const {
    attributes,
    clientId,
    setAttributes
  } = props;
  const {
    style
  } = attributes;
  const {
    colors
  } = (0, _useMultipleOriginColorsAndGradients.default)();
  const isSupported = hasBorderSupport(props.name);
  const isColorSupported = (0, _useSetting.default)('border.color') && hasBorderSupport(props.name, 'color');
  const isRadiusSupported = (0, _useSetting.default)('border.radius') && hasBorderSupport(props.name, 'radius');
  const isStyleSupported = (0, _useSetting.default)('border.style') && hasBorderSupport(props.name, 'style');
  const isWidthSupported = (0, _useSetting.default)('border.width') && hasBorderSupport(props.name, 'width');
  const isDisabled = [!isColorSupported, !isRadiusSupported, !isStyleSupported, !isWidthSupported].every(Boolean);

  if (isDisabled || !isSupported) {
    return null;
  }

  const defaultBorderControls = (0, _blocks.getBlockSupport)(props.name, [BORDER_SUPPORT_KEY, '__experimentalDefaultControls']);
  const showBorderByDefault = (defaultBorderControls === null || defaultBorderControls === void 0 ? void 0 : defaultBorderControls.color) || (defaultBorderControls === null || defaultBorderControls === void 0 ? void 0 : defaultBorderControls.width);

  const onBorderChange = newBorder => {
    var _style$border2;

    // Filter out named colors and apply them to appropriate block
    // attributes so that CSS classes can be used to apply those colors.
    // e.g. has-primary-border-top-color.
    let newBorderStyles = { ...newBorder
    };
    let newBorderColor;

    if ((0, _components.__experimentalHasSplitBorders)(newBorder)) {
      // For each side check if the side has a color value set
      // If so, determine if it belongs to a named color, in which case
      // we update the color property.
      //
      // This deliberately overwrites `newBorderStyles` to avoid mutating
      // the passed object which causes problems otherwise.
      newBorderStyles = {
        top: { ...newBorder.top
        },
        right: { ...newBorder.right
        },
        bottom: { ...newBorder.bottom
        },
        left: { ...newBorder.left
        }
      };
      borderSides.forEach(side => {
        var _newBorder$side;

        if ((_newBorder$side = newBorder[side]) !== null && _newBorder$side !== void 0 && _newBorder$side.color) {
          var _newBorder$side2;

          const colorObject = getMultiOriginColor({
            colors,
            customColor: (_newBorder$side2 = newBorder[side]) === null || _newBorder$side2 === void 0 ? void 0 : _newBorder$side2.color
          });

          if (colorObject.slug) {
            newBorderStyles[side].color = `var:preset|color|${colorObject.slug}`;
          }
        }
      });
    } else if (newBorder !== null && newBorder !== void 0 && newBorder.color) {
      // We have a flat border configuration. Apply named color slug to
      // `borderColor` attribute and clear color style property if found.
      const customColor = newBorder === null || newBorder === void 0 ? void 0 : newBorder.color;
      const colorObject = getMultiOriginColor({
        colors,
        customColor
      });

      if (colorObject.slug) {
        newBorderColor = colorObject.slug;
        newBorderStyles.color = undefined;
      }
    } // Ensure previous border radius styles are maintained and clean
    // overall result for empty objects or properties.


    const newStyle = (0, _utils.cleanEmptyObject)({ ...style,
      border: {
        radius: style === null || style === void 0 ? void 0 : (_style$border2 = style.border) === null || _style$border2 === void 0 ? void 0 : _style$border2.radius,
        ...newBorderStyles
      }
    });
    setAttributes({
      style: newStyle,
      borderColor: newBorderColor
    });
  };

  const hydratedBorder = getBorderObject(attributes, colors);
  return (0, _element.createElement)(_inspectorControls.default, {
    group: "border"
  }, (isWidthSupported || isColorSupported) && (0, _element.createElement)(_components.__experimentalToolsPanelItem, {
    hasValue: () => hasBorderValue(props),
    label: (0, _i18n.__)('Border'),
    onDeselect: () => resetBorder(props),
    isShownByDefault: showBorderByDefault,
    resetAllFilter: resetBorderFilter,
    panelId: clientId
  }, (0, _element.createElement)(_components.__experimentalBorderBoxControl, {
    colors: colors,
    enableAlpha: true,
    enableStyle: isStyleSupported,
    onChange: onBorderChange,
    popoverOffset: 40,
    popoverPlacement: "left-start",
    size: "__unstable-large",
    value: hydratedBorder,
    __experimentalIsRenderedInSidebar: true
  })), isRadiusSupported && (0, _element.createElement)(_components.__experimentalToolsPanelItem, {
    hasValue: () => (0, _borderRadius.hasBorderRadiusValue)(props),
    label: (0, _i18n.__)('Radius'),
    onDeselect: () => (0, _borderRadius.resetBorderRadius)(props),
    isShownByDefault: defaultBorderControls === null || defaultBorderControls === void 0 ? void 0 : defaultBorderControls.radius,
    resetAllFilter: newAttributes => {
      var _newAttributes$style2;

      return { ...newAttributes,
        style: { ...newAttributes.style,
          border: { ...((_newAttributes$style2 = newAttributes.style) === null || _newAttributes$style2 === void 0 ? void 0 : _newAttributes$style2.border),
            radius: undefined
          }
        }
      };
    },
    panelId: clientId
  }, (0, _element.createElement)(_borderRadius.BorderRadiusEdit, props)));
}
/**
 * Determine whether there is block support for border properties.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   Border feature to check support for.
 *
 * @return {boolean} Whether there is support.
 */


function hasBorderSupport(blockName) {
  let feature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';

  if (_element.Platform.OS !== 'web') {
    return false;
  }

  const support = (0, _blocks.getBlockSupport)(blockName, BORDER_SUPPORT_KEY);

  if (support === true) {
    return true;
  }

  if (feature === 'any') {
    return !!(support !== null && support !== void 0 && support.color || support !== null && support !== void 0 && support.radius || support !== null && support !== void 0 && support.width || support !== null && support !== void 0 && support.style);
  }

  return !!(support !== null && support !== void 0 && support[feature]);
}
/**
 * Returns a new style object where the specified border attribute has been
 * removed.
 *
 * @param {Object} style     Styles from block attributes.
 * @param {string} attribute The border style attribute to clear.
 *
 * @return {Object} Style object with the specified attribute removed.
 */


function removeBorderAttribute(style, attribute) {
  return (0, _utils.cleanEmptyObject)({ ...style,
    border: { ...(style === null || style === void 0 ? void 0 : style.border),
      [attribute]: undefined
    }
  });
}
/**
 * Filters registered block settings, extending attributes to include
 * `borderColor` if needed.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Updated block settings.
 */


function addAttributes(settings) {
  if (!hasBorderSupport(settings, 'color')) {
    return settings;
  } // Allow blocks to specify default value if needed.


  if (settings.attributes.borderColor) {
    return settings;
  } // Add new borderColor attribute to block settings.


  return { ...settings,
    attributes: { ...settings.attributes,
      borderColor: {
        type: 'string'
      }
    }
  };
}
/**
 * Override props assigned to save component to inject border color.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type definition.
 * @param {Object} attributes Block's attributes.
 *
 * @return {Object} Filtered props to apply to save element.
 */


function addSaveProps(props, blockType, attributes) {
  if (!hasBorderSupport(blockType, 'color') || (0, _utils.shouldSkipSerialization)(blockType, BORDER_SUPPORT_KEY, 'color')) {
    return props;
  }

  const borderClasses = getBorderClasses(attributes);
  const newClassName = (0, _classnames.default)(props.className, borderClasses); // If we are clearing the last of the previous classes in `className`
  // set it to `undefined` to avoid rendering empty DOM attributes.

  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Generates a CSS class name consisting of all the applicable border color
 * classes given the current block attributes.
 *
 * @param {Object} attributes Block's attributes.
 *
 * @return {string} CSS class name.
 */


function getBorderClasses(attributes) {
  var _style$border3;

  const {
    borderColor,
    style
  } = attributes;
  const borderColorClass = (0, _colors.getColorClassName)('border-color', borderColor);
  return (0, _classnames.default)({
    'has-border-color': borderColor || (style === null || style === void 0 ? void 0 : (_style$border3 = style.border) === null || _style$border3 === void 0 ? void 0 : _style$border3.color),
    [borderColorClass]: !!borderColorClass
  });
}
/**
 * Filters the registered block settings to apply border color styles and
 * classnames to the block edit wrapper.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function addEditProps(settings) {
  if (!hasBorderSupport(settings, 'color') || (0, _utils.shouldSkipSerialization)(settings, BORDER_SUPPORT_KEY, 'color')) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */


const withBorderColorPaletteStyles = (0, _compose.createHigherOrderComponent)(BlockListBlock => props => {
  var _style$border4, _style$border4$top, _style$border5, _style$border5$right, _style$border6, _style$border6$bottom, _style$border7, _style$border7$left, _props$wrapperProps;

  const {
    name,
    attributes
  } = props;
  const {
    borderColor,
    style
  } = attributes;
  const {
    colors
  } = (0, _useMultipleOriginColorsAndGradients.default)();

  if (!hasBorderSupport(name, 'color') || (0, _utils.shouldSkipSerialization)(name, BORDER_SUPPORT_KEY, 'color')) {
    return (0, _element.createElement)(BlockListBlock, props);
  }

  const {
    color: borderColorValue
  } = getMultiOriginColor({
    colors,
    namedColor: borderColor
  });
  const {
    color: borderTopColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border4 = style.border) === null || _style$border4 === void 0 ? void 0 : (_style$border4$top = _style$border4.top) === null || _style$border4$top === void 0 ? void 0 : _style$border4$top.color)
  });
  const {
    color: borderRightColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border5 = style.border) === null || _style$border5 === void 0 ? void 0 : (_style$border5$right = _style$border5.right) === null || _style$border5$right === void 0 ? void 0 : _style$border5$right.color)
  });
  const {
    color: borderBottomColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border6 = style.border) === null || _style$border6 === void 0 ? void 0 : (_style$border6$bottom = _style$border6.bottom) === null || _style$border6$bottom === void 0 ? void 0 : _style$border6$bottom.color)
  });
  const {
    color: borderLeftColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border7 = style.border) === null || _style$border7 === void 0 ? void 0 : (_style$border7$left = _style$border7.left) === null || _style$border7$left === void 0 ? void 0 : _style$border7$left.color)
  });
  const extraStyles = {
    borderTopColor: borderTopColor || borderColorValue,
    borderRightColor: borderRightColor || borderColorValue,
    borderBottomColor: borderBottomColor || borderColorValue,
    borderLeftColor: borderLeftColor || borderColorValue
  };
  let wrapperProps = props.wrapperProps;
  wrapperProps = { ...props.wrapperProps,
    style: { ...((_props$wrapperProps = props.wrapperProps) === null || _props$wrapperProps === void 0 ? void 0 : _props$wrapperProps.style),
      ...extraStyles
    }
  };
  return (0, _element.createElement)(BlockListBlock, (0, _extends2.default)({}, props, {
    wrapperProps: wrapperProps
  }));
});
exports.withBorderColorPaletteStyles = withBorderColorPaletteStyles;
(0, _hooks.addFilter)('blocks.registerBlockType', 'core/border/addAttributes', addAttributes);
(0, _hooks.addFilter)('blocks.getSaveContent.extraProps', 'core/border/addSaveProps', addSaveProps);
(0, _hooks.addFilter)('blocks.registerBlockType', 'core/border/addEditProps', addEditProps);
(0, _hooks.addFilter)('editor.BlockListBlock', 'core/border/with-border-color-palette-styles', withBorderColorPaletteStyles);
//# sourceMappingURL=border.js.map