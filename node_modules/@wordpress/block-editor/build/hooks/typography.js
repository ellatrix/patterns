"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TYPOGRAPHY_SUPPORT_KEYS = exports.TYPOGRAPHY_SUPPORT_KEY = void 0;
exports.TypographyPanel = TypographyPanel;
exports.hasTypographySupport = void 0;

var _element = require("@wordpress/element");

var _blocks = require("@wordpress/blocks");

var _inspectorControls = _interopRequireDefault(require("../components/inspector-controls"));

var _typographyPanel = _interopRequireWildcard(require("../components/global-styles/typography-panel"));

var _lineHeight = require("./line-height");

var _fontFamily = require("./font-family");

var _fontSize = require("./font-size");

var _utils = require("./utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function omit(object, keys) {
  return Object.fromEntries(Object.entries(object).filter(_ref => {
    let [key] = _ref;
    return !keys.includes(key);
  }));
}

const LETTER_SPACING_SUPPORT_KEY = 'typography.__experimentalLetterSpacing';
const TEXT_TRANSFORM_SUPPORT_KEY = 'typography.__experimentalTextTransform';
const TEXT_DECORATION_SUPPORT_KEY = 'typography.__experimentalTextDecoration';
const FONT_STYLE_SUPPORT_KEY = 'typography.__experimentalFontStyle';
const FONT_WEIGHT_SUPPORT_KEY = 'typography.__experimentalFontWeight';
const TYPOGRAPHY_SUPPORT_KEY = 'typography';
exports.TYPOGRAPHY_SUPPORT_KEY = TYPOGRAPHY_SUPPORT_KEY;
const TYPOGRAPHY_SUPPORT_KEYS = [_lineHeight.LINE_HEIGHT_SUPPORT_KEY, _fontSize.FONT_SIZE_SUPPORT_KEY, FONT_STYLE_SUPPORT_KEY, FONT_WEIGHT_SUPPORT_KEY, _fontFamily.FONT_FAMILY_SUPPORT_KEY, TEXT_DECORATION_SUPPORT_KEY, TEXT_TRANSFORM_SUPPORT_KEY, LETTER_SPACING_SUPPORT_KEY];
exports.TYPOGRAPHY_SUPPORT_KEYS = TYPOGRAPHY_SUPPORT_KEYS;

function styleToAttributes(style) {
  var _style$typography, _style$typography2;

  const updatedStyle = { ...omit(style, ['fontFamily'])
  };
  const fontSizeValue = style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.fontSize;
  const fontFamilyValue = style === null || style === void 0 ? void 0 : (_style$typography2 = style.typography) === null || _style$typography2 === void 0 ? void 0 : _style$typography2.fontFamily;
  const fontSizeSlug = fontSizeValue !== null && fontSizeValue !== void 0 && fontSizeValue.startsWith('var:preset|font-size|') ? fontSizeValue.substring('var:preset|font-size|'.length) : undefined;
  const fontFamilySlug = fontFamilyValue !== null && fontFamilyValue !== void 0 && fontFamilyValue.startsWith('var:preset|font-family|') ? fontFamilyValue.substring('var:preset|font-family|'.length) : undefined;
  updatedStyle.typography = { ...omit(updatedStyle.typography, ['fontFamily']),
    fontSize: fontSizeSlug ? undefined : fontSizeValue
  };
  return {
    style: (0, _utils.cleanEmptyObject)(updatedStyle),
    fontFamily: fontFamilySlug,
    fontSize: fontSizeSlug
  };
}

function attributesToStyle(attributes) {
  var _attributes$style, _attributes$style2, _attributes$style2$ty;

  return { ...attributes.style,
    typography: { ...((_attributes$style = attributes.style) === null || _attributes$style === void 0 ? void 0 : _attributes$style.typography),
      fontFamily: attributes.fontFamily ? 'var:preset|font-family|' + attributes.fontFamily : undefined,
      fontSize: attributes.fontSize ? 'var:preset|font-size|' + attributes.fontSize : (_attributes$style2 = attributes.style) === null || _attributes$style2 === void 0 ? void 0 : (_attributes$style2$ty = _attributes$style2.typography) === null || _attributes$style2$ty === void 0 ? void 0 : _attributes$style2$ty.fontSize
    }
  };
}

function TypographyInspectorControl(_ref2) {
  let {
    children,
    resetAllFilter
  } = _ref2;
  const attributesResetAllFilter = (0, _element.useCallback)(attributes => {
    const existingStyle = attributesToStyle(attributes);
    const updatedStyle = resetAllFilter(existingStyle);
    return { ...attributes,
      ...styleToAttributes(updatedStyle)
    };
  }, [resetAllFilter]);
  return (0, _element.createElement)(_inspectorControls.default, {
    group: "typography",
    resetAllFilter: attributesResetAllFilter
  }, children);
}

function TypographyPanel(_ref3) {
  let {
    clientId,
    name,
    attributes,
    setAttributes,
    __unstableParentLayout
  } = _ref3;
  const settings = (0, _utils.useBlockSettings)(name, __unstableParentLayout);
  const isEnabled = (0, _typographyPanel.useHasTypographyPanel)(settings);
  const value = (0, _element.useMemo)(() => {
    return attributesToStyle({
      style: attributes.style,
      fontFamily: attributes.fontFamily,
      fontSize: attributes.fontSize
    });
  }, [attributes.style, attributes.fontSize, attributes.fontFamily]);

  const onChange = newStyle => {
    setAttributes(styleToAttributes(newStyle));
  };

  if (!isEnabled) {
    return null;
  }

  const defaultControls = (0, _blocks.getBlockSupport)(name, [TYPOGRAPHY_SUPPORT_KEY, '__experimentalDefaultControls']);
  return (0, _element.createElement)(_typographyPanel.default, {
    as: TypographyInspectorControl,
    panelId: clientId,
    name: name,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls
  });
}

const hasTypographySupport = blockName => {
  return TYPOGRAPHY_SUPPORT_KEYS.some(key => (0, _blocks.hasBlockSupport)(blockName, key));
};

exports.hasTypographySupport = hasTypographySupport;
//# sourceMappingURL=typography.js.map