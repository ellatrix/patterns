"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePreParsePatterns = usePreParsePatterns;

var _data = require("@wordpress/data");

var _element = require("@wordpress/element");

var _store = require("../store");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const requestIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return callback => {
      setTimeout(() => callback(Date.now()), 0);
    };
  }

  return window.requestIdleCallback || window.requestAnimationFrame;
})();

const cancelIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return clearTimeout;
  }

  return window.cancelIdleCallback || window.cancelAnimationFrame;
})();

function usePreParsePatterns() {
  const {
    patterns,
    isPreviewMode
  } = (0, _data.useSelect)(_select => {
    const {
      __experimentalBlockPatterns,
      __unstableIsPreviewMode
    } = _select(_store.store).getSettings();

    return {
      patterns: __experimentalBlockPatterns,
      isPreviewMode: __unstableIsPreviewMode
    };
  }, []);
  (0, _element.useEffect)(() => {
    if (isPreviewMode) {
      return;
    }

    if (!(patterns !== null && patterns !== void 0 && patterns.length)) {
      return;
    }

    let handle;
    let index = -1;

    const callback = () => {
      index++;

      if (index >= patterns.length) {
        return;
      }

      (0, _data.select)(_store.store).__experimentalGetParsedPattern(patterns[index].name);

      handle = requestIdleCallback(callback);
    };

    handle = requestIdleCallback(callback);
    return () => cancelIdleCallback(handle);
  }, [patterns, isPreviewMode]);
  return null;
}
//# sourceMappingURL=pre-parse-patterns.js.map