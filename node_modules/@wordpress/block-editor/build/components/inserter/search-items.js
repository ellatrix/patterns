"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getItemSearchRank = getItemSearchRank;
exports.searchItems = exports.searchBlockItems = exports.getNormalizedSearchTerms = void 0;

var _removeAccents = _interopRequireDefault(require("remove-accents"));

var _changeCase = require("change-case");

/**
 * External dependencies
 */
// Default search helpers.
const defaultGetName = item => item.name || '';

const defaultGetTitle = item => item.title;

const defaultGetDescription = item => item.description || '';

const defaultGetKeywords = item => item.keywords || [];

const defaultGetCategory = item => item.category;

const defaultGetCollection = () => null;
/**
 * Extracts words from an input string.
 *
 * @param {string} input The input string.
 *
 * @return {Array} Words, extracted from the input string.
 */


function extractWords() {
  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return (0, _changeCase.noCase)(input, {
    splitRegexp: [/([\p{Ll}\p{Lo}\p{N}])([\p{Lu}\p{Lt}])/gu, // One lowercase or digit, followed by one uppercase.
    /([\p{Lu}\p{Lt}])([\p{Lu}\p{Lt}][\p{Ll}\p{Lo}])/gu // One uppercase followed by one uppercase and one lowercase.
    ],
    stripRegexp: /(\p{C}|\p{P}|\p{S})+/giu // Anything that's not a punctuation, symbol or control/format character.

  }).split(' ').filter(Boolean);
}
/**
 * Sanitizes the search input string.
 *
 * @param {string} input The search input to normalize.
 *
 * @return {string} The normalized search input.
 */


function normalizeSearchInput() {
  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  // Disregard diacritics.
  //  Input: "mÃ©dia"
  input = (0, _removeAccents.default)(input); // Accommodate leading slash, matching autocomplete expectations.
  //  Input: "/media"

  input = input.replace(/^\//, ''); // Lowercase.
  //  Input: "MEDIA"

  input = input.toLowerCase();
  return input;
}
/**
 * Converts the search term into a list of normalized terms.
 *
 * @param {string} input The search term to normalize.
 *
 * @return {string[]} The normalized list of search terms.
 */


const getNormalizedSearchTerms = function () {
  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return extractWords(normalizeSearchInput(input));
};

exports.getNormalizedSearchTerms = getNormalizedSearchTerms;

const removeMatchingTerms = (unmatchedTerms, unprocessedTerms) => {
  return unmatchedTerms.filter(term => !getNormalizedSearchTerms(unprocessedTerms).some(unprocessedTerm => unprocessedTerm.includes(term)));
};

const searchBlockItems = (items, categories, collections, searchInput) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  const config = {
    getCategory: item => {
      var _categories$find;

      return (_categories$find = categories.find(_ref => {
        let {
          slug
        } = _ref;
        return slug === item.category;
      })) === null || _categories$find === void 0 ? void 0 : _categories$find.title;
    },
    getCollection: item => {
      var _collections$item$nam;

      return (_collections$item$nam = collections[item.name.split('/')[0]]) === null || _collections$item$nam === void 0 ? void 0 : _collections$item$nam.title;
    }
  };
  return searchItems(items, searchInput, config);
};
/**
 * Filters an item list given a search term.
 *
 * @param {Array}  items       Item list
 * @param {string} searchInput Search input.
 * @param {Object} config      Search Config.
 *
 * @return {Array} Filtered item list.
 */


exports.searchBlockItems = searchBlockItems;

const searchItems = function () {
  let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let searchInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  const rankedItems = items.map(item => {
    return [item, getItemSearchRank(item, searchInput, config)];
  }).filter(_ref2 => {
    let [, rank] = _ref2;
    return rank > 0;
  });
  rankedItems.sort((_ref3, _ref4) => {
    let [, rank1] = _ref3;
    let [, rank2] = _ref4;
    return rank2 - rank1;
  });
  return rankedItems.map(_ref5 => {
    let [item] = _ref5;
    return item;
  });
};
/**
 * Get the search rank for a given item and a specific search term.
 * The better the match, the higher the rank.
 * If the rank equals 0, it should be excluded from the results.
 *
 * @param {Object} item       Item to filter.
 * @param {string} searchTerm Search term.
 * @param {Object} config     Search Config.
 *
 * @return {number} Search Rank.
 */


exports.searchItems = searchItems;

function getItemSearchRank(item, searchTerm) {
  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    getName = defaultGetName,
    getTitle = defaultGetTitle,
    getDescription = defaultGetDescription,
    getKeywords = defaultGetKeywords,
    getCategory = defaultGetCategory,
    getCollection = defaultGetCollection
  } = config;
  const name = getName(item);
  const title = getTitle(item);
  const description = getDescription(item);
  const keywords = getKeywords(item);
  const category = getCategory(item);
  const collection = getCollection(item);
  const normalizedSearchInput = normalizeSearchInput(searchTerm);
  const normalizedTitle = normalizeSearchInput(title);
  let rank = 0; // Prefers exact matches
  // Then prefers if the beginning of the title matches the search term
  // name, keywords, categories, collection, variations match come later.

  if (normalizedSearchInput === normalizedTitle) {
    rank += 30;
  } else if (normalizedTitle.startsWith(normalizedSearchInput)) {
    rank += 20;
  } else {
    const terms = [name, title, description, ...keywords, category, collection].join(' ');
    const normalizedSearchTerms = extractWords(normalizedSearchInput);
    const unmatchedTerms = removeMatchingTerms(normalizedSearchTerms, terms);

    if (unmatchedTerms.length === 0) {
      rank += 10;
    }
  } // Give a better rank to "core" namespaced items.


  if (rank !== 0 && name.startsWith('core/')) {
    const isCoreBlockVariation = name !== item.id; // Give a bit better rank to "core" blocks over "core" block variations.

    rank += isCoreBlockVariation ? 1 : 2;
  }

  return rank;
}
//# sourceMappingURL=search-items.js.map