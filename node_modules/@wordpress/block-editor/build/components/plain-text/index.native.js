"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _reactNative = require("react-native");

var _blockEditor = require("@wordpress/block-editor");

var _style = _interopRequireDefault(require("./style.scss"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
class PlainText extends _element.Component {
  constructor() {
    super(...arguments);
    this.isAndroid = _reactNative.Platform.OS === 'android';
    this.onChangeTextInput = this.onChangeTextInput.bind(this);
    this.onChangeRichText = this.onChangeRichText.bind(this);
  }

  componentDidMount() {
    // If isSelected is true, we should request the focus on this TextInput.
    if (this._input && this._input.isFocused() === false && this.props.isSelected) {
      if (this.isAndroid) {
        /*
         * There seems to be an issue in React Native where the keyboard doesn't show if called shortly after rendering.
         * As a common work around this delay is used.
         * https://github.com/facebook/react-native/issues/19366#issuecomment-400603928
         */
        this.timeoutID = setTimeout(() => {
          this._input.focus();
        }, 100);
      } else {
        this._input.focus();
      }
    }
  }

  componentDidUpdate(prevProps) {
    if (!this.props.isSelected && prevProps.isSelected) {
      var _this$_input;

      (_this$_input = this._input) === null || _this$_input === void 0 ? void 0 : _this$_input.blur();
    }
  }

  componentWillUnmount() {
    if (this.isAndroid) {
      clearTimeout(this.timeoutID);
    }
  }

  focus() {
    var _this$_input2;

    (_this$_input2 = this._input) === null || _this$_input2 === void 0 ? void 0 : _this$_input2.focus();
  }

  blur() {
    var _this$_input3;

    (_this$_input3 = this._input) === null || _this$_input3 === void 0 ? void 0 : _this$_input3.blur();
  }

  getFontSize() {
    const {
      style
    } = this.props;

    if (!(style !== null && style !== void 0 && style.fontSize)) {
      return;
    }

    const {
      width,
      height
    } = _reactNative.Dimensions.get('window');

    const cssUnitOptions = {
      height,
      width
    };
    return {
      fontSize: parseFloat((0, _blockEditor.getPxFromCssUnit)(style.fontSize, cssUnitOptions))
    };
  }

  replaceLineBreakTags(value) {
    return value === null || value === void 0 ? void 0 : value.replace(RegExp('<br>', 'gim'), '\n');
  }

  onChangeTextInput(event) {
    const {
      onChange
    } = this.props;
    onChange(event.nativeEvent.text);
  }

  onChangeRichText(value) {
    const {
      onChange
    } = this.props; // The <br> tags have to be replaced with new line characters
    // as the content of plain text shouldn't contain HTML tags.

    onChange(this.replaceLineBreakTags(value));
  }

  render() {
    const {
      style,
      __experimentalVersion,
      onFocus,
      ...otherProps
    } = this.props;
    const textStyles = [style || _style.default['block-editor-plain-text'], this.getFontSize()];

    if (__experimentalVersion === 2) {
      const disableFormattingProps = {
        withoutInteractiveFormatting: true,
        disableEditingMenu: true,
        __unstableDisableFormats: true,
        disableSuggestions: true
      };
      const forcePlainTextProps = {
        preserveWhiteSpace: true,
        __unstablePastePlainText: true,
        multiline: false
      };
      const fontProps = {
        fontFamily: style === null || style === void 0 ? void 0 : style.fontFamily,
        fontSize: style === null || style === void 0 ? void 0 : style.fontSize,
        fontWeight: style === null || style === void 0 ? void 0 : style.fontWeight
      };
      return (0, _element.createElement)(_blockEditor.RichText, (0, _extends2.default)({}, otherProps, disableFormattingProps, forcePlainTextProps, fontProps, {
        identifier: "content",
        style: style,
        onChange: this.onChangeRichText,
        unstableOnFocus: onFocus
      }));
    }

    return (0, _element.createElement)(_reactNative.TextInput, (0, _extends2.default)({}, this.props, {
      ref: x => this._input = x,
      onChange: this.onChangeTextInput,
      onFocus: this.props.onFocus // Always assign onFocus as a props.
      ,
      onBlur: this.props.onBlur // Always assign onBlur as a props.
      ,
      fontFamily: this.props.style && this.props.style.fontFamily || _style.default['block-editor-plain-text'].fontFamily,
      style: textStyles,
      scrollEnabled: false
    }));
  }

}

exports.default = PlainText;
//# sourceMappingURL=index.native.js.map