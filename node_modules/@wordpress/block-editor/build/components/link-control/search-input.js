"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _compose = require("@wordpress/compose");

var _i18n = require("@wordpress/i18n");

var _ = require("../");

var _searchResults = _interopRequireDefault(require("./search-results"));

var _constants = require("./constants");

var _useSearchHandler = _interopRequireDefault(require("./use-search-handler"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
// Must be a function as otherwise URLInput will default
// to the fetchLinkSuggestions passed in block editor settings
// which will cause an unintended http request.
const noopSearchHandler = () => Promise.resolve([]);

const noop = () => {};

const LinkControlSearchInput = (0, _element.forwardRef)((_ref, ref) => {
  let {
    value,
    children,
    currentLink = {},
    className = null,
    placeholder = null,
    withCreateSuggestion = false,
    onCreateSuggestion = noop,
    onChange = noop,
    onSelect = noop,
    showSuggestions = true,
    renderSuggestions = props => (0, _element.createElement)(_searchResults.default, props),
    fetchSuggestions = null,
    allowDirectEntry = true,
    showInitialSuggestions = false,
    suggestionsQuery = {},
    withURLSuggestion = true,
    createSuggestionButtonText,
    useLabel = false
  } = _ref;
  const genericSearchHandler = (0, _useSearchHandler.default)(suggestionsQuery, allowDirectEntry, withCreateSuggestion, withURLSuggestion);
  const searchHandler = showSuggestions ? fetchSuggestions || genericSearchHandler : noopSearchHandler;
  const instanceId = (0, _compose.useInstanceId)(LinkControlSearchInput);
  const [focusedSuggestion, setFocusedSuggestion] = (0, _element.useState)();
  /**
   * Handles the user moving between different suggestions. Does not handle
   * choosing an individual item.
   *
   * @param {string} selection  the url of the selected suggestion.
   * @param {Object} suggestion the suggestion object.
   */

  const onInputChange = (selection, suggestion) => {
    onChange(selection);
    setFocusedSuggestion(suggestion);
  };

  const handleRenderSuggestions = props => renderSuggestions({ ...props,
    instanceId,
    withCreateSuggestion,
    createSuggestionButtonText,
    suggestionsQuery,
    handleSuggestionClick: suggestion => {
      if (props.handleSuggestionClick) {
        props.handleSuggestionClick(suggestion);
      }

      onSuggestionSelected(suggestion);
    }
  });

  const onSuggestionSelected = async selectedSuggestion => {
    let suggestion = selectedSuggestion;

    if (_constants.CREATE_TYPE === selectedSuggestion.type) {
      // Create a new page and call onSelect with the output from the onCreateSuggestion callback.
      try {
        var _suggestion;

        suggestion = await onCreateSuggestion(selectedSuggestion.title);

        if ((_suggestion = suggestion) !== null && _suggestion !== void 0 && _suggestion.url) {
          onSelect(suggestion);
        }
      } catch (e) {}

      return;
    }

    if (allowDirectEntry || suggestion && Object.keys(suggestion).length >= 1) {
      const {
        id,
        url,
        ...restLinkProps
      } = currentLink !== null && currentLink !== void 0 ? currentLink : {};
      onSelect( // Some direct entries don't have types or IDs, and we still need to clear the previous ones.
      { ...restLinkProps,
        ...suggestion
      }, suggestion);
    }
  };

  const inputClasses = (0, _classnames.default)(className, {
    'has-no-label': !useLabel
  });
  return (0, _element.createElement)("div", {
    className: "block-editor-link-control__search-input-container"
  }, (0, _element.createElement)(_.URLInput, {
    __nextHasNoMarginBottom: true,
    label: useLabel ? 'URL' : undefined,
    className: inputClasses,
    value: value,
    onChange: onInputChange,
    placeholder: placeholder !== null && placeholder !== void 0 ? placeholder : (0, _i18n.__)('Search or type url'),
    __experimentalRenderSuggestions: showSuggestions ? handleRenderSuggestions : null,
    __experimentalFetchLinkSuggestions: searchHandler,
    __experimentalHandleURLSuggestions: true,
    __experimentalShowInitialSuggestions: showInitialSuggestions,
    onSubmit: (suggestion, event) => {
      var _value$trim;

      const hasSuggestion = suggestion || focusedSuggestion; // If there is no suggestion and the value (ie: any manually entered URL) is empty
      // then don't allow submission otherwise we get empty links.

      if (!hasSuggestion && !(value !== null && value !== void 0 && (_value$trim = value.trim()) !== null && _value$trim !== void 0 && _value$trim.length)) {
        event.preventDefault();
      } else {
        onSuggestionSelected(hasSuggestion || {
          url: value
        });
      }
    },
    ref: ref
  }), children);
});
var _default = LinkControlSearchInput;
exports.default = _default;
//# sourceMappingURL=search-input.js.map