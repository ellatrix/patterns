{"version":3,"sources":["@wordpress/block-editor/src/components/font-sizes/fluid-utils.js"],"names":["DEFAULT_MAXIMUM_VIEWPORT_WIDTH","DEFAULT_MINIMUM_VIEWPORT_WIDTH","DEFAULT_SCALE_FACTOR","DEFAULT_MINIMUM_FONT_SIZE_FACTOR","DEFAULT_MINIMUM_FONT_SIZE_LIMIT","getComputedFluidTypographyValue","minimumFontSize","maximumFontSize","fontSize","minimumViewPortWidth","maximumViewPortWidth","scaleFactor","minimumFontSizeFactor","minimumFontSizeLimit","getTypographyValueAndUnit","fontSizeParsed","unit","minimumFontSizeLimitParsed","coerceTo","value","calculatedMinimumFontSize","roundToPrecision","minimumFontSizeParsed","fontSizeUnit","maximumFontSizeParsed","minimumFontSizeRem","maximumViewPortWidthParsed","minumumViewPortWidthParsed","minViewPortWidthOffsetValue","viewPortWidthOffset","linearFactor","linearFactorScaled","fluidTargetFontSize","rawValue","options","isFinite","rootSizeValue","acceptableUnits","acceptableUnitsGroup","join","regexUnits","RegExp","matches","match","length","returnValue","parseFloat","digits","base","Math","pow","Number","round","undefined"],"mappings":"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","sourcesContent":["/**\n * The fluid utilities must match the backend equivalent.\n * See: gutenberg_get_typography_font_size_value() in lib/block-supports/typography.php\n * ---------------------------------------------------------------\n */\n\n// Defaults.\nconst DEFAULT_MAXIMUM_VIEWPORT_WIDTH = '1600px';\nconst DEFAULT_MINIMUM_VIEWPORT_WIDTH = '768px';\nconst DEFAULT_SCALE_FACTOR = 1;\nconst DEFAULT_MINIMUM_FONT_SIZE_FACTOR = 0.75;\nconst DEFAULT_MINIMUM_FONT_SIZE_LIMIT = '14px';\n\n/**\n * Computes a fluid font-size value that uses clamp(). A minimum and maximum\n * font size OR a single font size can be specified.\n *\n * If a single font size is specified, it is scaled up and down by\n * minimumFontSizeFactor and maximumFontSizeFactor to arrive at the minimum and\n * maximum sizes.\n *\n * @example\n * ```js\n * // Calculate fluid font-size value from a minimum and maximum value.\n * const fontSize = getComputedFluidTypographyValue( {\n *     minimumFontSize: '20px',\n *     maximumFontSize: '45px'\n * } );\n * // Calculate fluid font-size value from a single font size.\n * const fontSize = getComputedFluidTypographyValue( {\n *     fontSize: '30px',\n * } );\n * ```\n *\n * @param {Object}        args\n * @param {?string}       args.minimumViewPortWidth  Minimum viewport size from which type will have fluidity. Optional if fontSize is specified.\n * @param {?string}       args.maximumViewPortWidth  Maximum size up to which type will have fluidity. Optional if fontSize is specified.\n * @param {string|number} [args.fontSize]            Size to derive maximumFontSize and minimumFontSize from, if necessary. Optional if minimumFontSize and maximumFontSize are specified.\n * @param {?string}       args.maximumFontSize       Maximum font size for any clamp() calculation. Optional.\n * @param {?string}       args.minimumFontSize       Minimum font size for any clamp() calculation. Optional.\n * @param {?number}       args.scaleFactor           A scale factor to determine how fast a font scales within boundaries. Optional.\n * @param {?number}       args.minimumFontSizeFactor How much to scale defaultFontSize by to derive minimumFontSize. Optional.\n * @param {?string}       args.minimumFontSizeLimit  The smallest a calculated font size may be. Optional.\n *\n * @return {string|null} A font-size value using clamp().\n */\nexport function getComputedFluidTypographyValue( {\n\tminimumFontSize,\n\tmaximumFontSize,\n\tfontSize,\n\tminimumViewPortWidth = DEFAULT_MINIMUM_VIEWPORT_WIDTH,\n\tmaximumViewPortWidth = DEFAULT_MAXIMUM_VIEWPORT_WIDTH,\n\tscaleFactor = DEFAULT_SCALE_FACTOR,\n\tminimumFontSizeFactor = DEFAULT_MINIMUM_FONT_SIZE_FACTOR,\n\tminimumFontSizeLimit,\n} ) {\n\t// Validate incoming settings and set defaults.\n\tminimumFontSizeLimit = !! getTypographyValueAndUnit( minimumFontSizeLimit )\n\t\t? minimumFontSizeLimit\n\t\t: DEFAULT_MINIMUM_FONT_SIZE_LIMIT;\n\n\t/*\n\t * Calculates missing minimumFontSize and maximumFontSize from\n\t * defaultFontSize if provided.\n\t */\n\tif ( fontSize ) {\n\t\t// Parses default font size.\n\t\tconst fontSizeParsed = getTypographyValueAndUnit( fontSize );\n\n\t\t// Protect against invalid units.\n\t\tif ( ! fontSizeParsed?.unit ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Parses the minimum font size limit, so we can perform checks using it.\n\t\tconst minimumFontSizeLimitParsed = getTypographyValueAndUnit(\n\t\t\tminimumFontSizeLimit,\n\t\t\t{\n\t\t\t\tcoerceTo: fontSizeParsed.unit,\n\t\t\t}\n\t\t);\n\n\t\t// Don't enforce minimum font size if a font size has explicitly set a min and max value.\n\t\tif (\n\t\t\t!! minimumFontSizeLimitParsed?.value &&\n\t\t\t! minimumFontSize &&\n\t\t\t! maximumFontSize\n\t\t) {\n\t\t\t/*\n\t\t\t * If a minimum size was not passed to this function\n\t\t\t * and the user-defined font size is lower than $minimum_font_size_limit,\n\t\t\t * do not calculate a fluid value.\n\t\t\t */\n\t\t\tif ( fontSizeParsed?.value <= minimumFontSizeLimitParsed?.value ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// If no fluid max font size is available use the incoming value.\n\t\tif ( ! maximumFontSize ) {\n\t\t\tmaximumFontSize = `${ fontSizeParsed.value }${ fontSizeParsed.unit }`;\n\t\t}\n\n\t\t/*\n\t\t * If no minimumFontSize is provided, create one using\n\t\t * the given font size multiplied by the min font size scale factor.\n\t\t */\n\t\tif ( ! minimumFontSize ) {\n\t\t\tconst calculatedMinimumFontSize = roundToPrecision(\n\t\t\t\tfontSizeParsed.value * minimumFontSizeFactor,\n\t\t\t\t3\n\t\t\t);\n\n\t\t\t// Only use calculated min font size if it's > $minimum_font_size_limit value.\n\t\t\tif (\n\t\t\t\t!! minimumFontSizeLimitParsed?.value &&\n\t\t\t\tcalculatedMinimumFontSize < minimumFontSizeLimitParsed?.value\n\t\t\t) {\n\t\t\t\tminimumFontSize = `${ minimumFontSizeLimitParsed.value }${ minimumFontSizeLimitParsed.unit }`;\n\t\t\t} else {\n\t\t\t\tminimumFontSize = `${ calculatedMinimumFontSize }${ fontSizeParsed.unit }`;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Grab the minimum font size and normalize it in order to use the value for calculations.\n\tconst minimumFontSizeParsed = getTypographyValueAndUnit( minimumFontSize );\n\n\t// We get a 'preferred' unit to keep units consistent when calculating,\n\t// otherwise the result will not be accurate.\n\tconst fontSizeUnit = minimumFontSizeParsed?.unit || 'rem';\n\n\t// Grabs the maximum font size and normalize it in order to use the value for calculations.\n\tconst maximumFontSizeParsed = getTypographyValueAndUnit( maximumFontSize, {\n\t\tcoerceTo: fontSizeUnit,\n\t} );\n\n\t// Checks for mandatory min and max sizes, and protects against unsupported units.\n\tif ( ! minimumFontSizeParsed || ! maximumFontSizeParsed ) {\n\t\treturn null;\n\t}\n\n\t// Uses rem for accessible fluid target font scaling.\n\tconst minimumFontSizeRem = getTypographyValueAndUnit( minimumFontSize, {\n\t\tcoerceTo: 'rem',\n\t} );\n\n\t// Viewport widths defined for fluid typography. Normalize units\n\tconst maximumViewPortWidthParsed = getTypographyValueAndUnit(\n\t\tmaximumViewPortWidth,\n\t\t{ coerceTo: fontSizeUnit }\n\t);\n\tconst minumumViewPortWidthParsed = getTypographyValueAndUnit(\n\t\tminimumViewPortWidth,\n\t\t{ coerceTo: fontSizeUnit }\n\t);\n\n\t// Protect against unsupported units.\n\tif (\n\t\t! maximumViewPortWidthParsed ||\n\t\t! minumumViewPortWidthParsed ||\n\t\t! minimumFontSizeRem\n\t) {\n\t\treturn null;\n\t}\n\n\t// Build CSS rule.\n\t// Borrowed from https://websemantics.uk/tools/responsive-font-calculator/.\n\tconst minViewPortWidthOffsetValue = roundToPrecision(\n\t\tminumumViewPortWidthParsed.value / 100,\n\t\t3\n\t);\n\n\tconst viewPortWidthOffset =\n\t\troundToPrecision( minViewPortWidthOffsetValue, 3 ) + fontSizeUnit;\n\tconst linearFactor =\n\t\t100 *\n\t\t( ( maximumFontSizeParsed.value - minimumFontSizeParsed.value ) /\n\t\t\t( maximumViewPortWidthParsed.value -\n\t\t\t\tminumumViewPortWidthParsed.value ) );\n\tconst linearFactorScaled = roundToPrecision(\n\t\t( linearFactor || 1 ) * scaleFactor,\n\t\t3\n\t);\n\tconst fluidTargetFontSize = `${ minimumFontSizeRem.value }${ minimumFontSizeRem.unit } + ((1vw - ${ viewPortWidthOffset }) * ${ linearFactorScaled })`;\n\n\treturn `clamp(${ minimumFontSize }, ${ fluidTargetFontSize }, ${ maximumFontSize })`;\n}\n\n/**\n * Internal method that checks a string for a unit and value and returns an array consisting of `'value'` and `'unit'`, e.g., [ '42', 'rem' ].\n * A raw font size of `value + unit` is expected. If the value is an integer, it will convert to `value + 'px'`.\n *\n * @param {string|number}    rawValue Raw size value from theme.json.\n * @param {Object|undefined} options  Calculation options.\n *\n * @return {{ unit: string, value: number }|null} An object consisting of `'value'` and `'unit'` properties.\n */\nexport function getTypographyValueAndUnit( rawValue, options = {} ) {\n\tif ( typeof rawValue !== 'string' && typeof rawValue !== 'number' ) {\n\t\treturn null;\n\t}\n\n\t// Converts numeric values to pixel values by default.\n\tif ( isFinite( rawValue ) ) {\n\t\trawValue = `${ rawValue }px`;\n\t}\n\n\tconst { coerceTo, rootSizeValue, acceptableUnits } = {\n\t\tcoerceTo: '',\n\t\t// Default browser font size. Later we could inject some JS to compute this `getComputedStyle( document.querySelector( \"html\" ) ).fontSize`.\n\t\trootSizeValue: 16,\n\t\tacceptableUnits: [ 'rem', 'px', 'em' ],\n\t\t...options,\n\t};\n\n\tconst acceptableUnitsGroup = acceptableUnits?.join( '|' );\n\tconst regexUnits = new RegExp(\n\t\t`^(\\\\d*\\\\.?\\\\d+)(${ acceptableUnitsGroup }){1,1}$`\n\t);\n\n\tconst matches = rawValue.match( regexUnits );\n\n\t// We need a number value and a unit.\n\tif ( ! matches || matches.length < 3 ) {\n\t\treturn null;\n\t}\n\n\tlet [ , value, unit ] = matches;\n\n\tlet returnValue = parseFloat( value );\n\n\tif ( 'px' === coerceTo && ( 'em' === unit || 'rem' === unit ) ) {\n\t\treturnValue = returnValue * rootSizeValue;\n\t\tunit = coerceTo;\n\t}\n\n\tif ( 'px' === unit && ( 'em' === coerceTo || 'rem' === coerceTo ) ) {\n\t\treturnValue = returnValue / rootSizeValue;\n\t\tunit = coerceTo;\n\t}\n\n\t/*\n\t * No calculation is required if swapping between em and rem yet,\n\t * since we assume a root size value. Later we might like to differentiate between\n\t * :root font size (rem) and parent element font size (em) relativity.\n\t */\n\tif (\n\t\t( 'em' === coerceTo || 'rem' === coerceTo ) &&\n\t\t( 'em' === unit || 'rem' === unit )\n\t) {\n\t\tunit = coerceTo;\n\t}\n\n\treturn {\n\t\tvalue: roundToPrecision( returnValue, 3 ),\n\t\tunit,\n\t};\n}\n\n/**\n * Returns a value rounded to defined precision.\n * Returns `undefined` if the value is not a valid finite number.\n *\n * @param {number} value  Raw value.\n * @param {number} digits The number of digits to appear after the decimal point\n *\n * @return {number|undefined} Value rounded to standard precision.\n */\nexport function roundToPrecision( value, digits = 3 ) {\n\tconst base = Math.pow( 10, digits );\n\treturn Number.isFinite( value )\n\t\t? parseFloat( Math.round( value * base ) / base )\n\t\t: undefined;\n}\n"]}