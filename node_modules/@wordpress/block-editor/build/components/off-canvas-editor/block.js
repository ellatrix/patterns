"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _blocks = require("@wordpress/blocks");

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _icons = require("@wordpress/icons");

var _data = require("@wordpress/data");

var _i18n = require("@wordpress/i18n");

var _leaf = _interopRequireDefault(require("./leaf"));

var _button = require("../block-mover/button");

var _blockContents = _interopRequireDefault(require("./block-contents"));

var _blockSettingsDropdown = _interopRequireDefault(require("../block-settings-menu/block-settings-dropdown"));

var _context = require("./context");

var _utils = require("./utils");

var _store = require("../../store");

var _useBlockDisplayInformation = _interopRequireDefault(require("../use-block-display-information"));

var _blockLock = require("../block-lock");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function ListViewBlock(_ref) {
  let {
    block: {
      clientId
    },
    isDragged,
    isSelected,
    isBranchSelected,
    selectBlock,
    position,
    level,
    rowCount,
    siblingBlockCount,
    showBlockMovers,
    path,
    isExpanded,
    selectedClientIds,
    preventAnnouncement
  } = _ref;
  const cellRef = (0, _element.useRef)(null);
  const [isHovered, setIsHovered] = (0, _element.useState)(false);
  const {
    isLocked,
    isContentLocked
  } = (0, _blockLock.useBlockLock)(clientId);
  const forceSelectionContentLock = (0, _data.useSelect)(select => {
    if (isSelected) {
      return false;
    }

    if (!isContentLocked) {
      return false;
    }

    return select(_store.store).hasSelectedInnerBlock(clientId, true);
  }, [isContentLocked, clientId, isSelected]);
  const isFirstSelectedBlock = forceSelectionContentLock || isSelected && selectedClientIds[0] === clientId;
  const isLastSelectedBlock = forceSelectionContentLock || isSelected && selectedClientIds[selectedClientIds.length - 1] === clientId;
  const {
    toggleBlockHighlight
  } = (0, _data.useDispatch)(_store.store);
  const blockInformation = (0, _useBlockDisplayInformation.default)(clientId);
  const block = (0, _data.useSelect)(select => select(_store.store).getBlock(clientId), [clientId]); // If ListView has experimental features related to the Persistent List View,
  // only focus the selected list item on mount; otherwise the list would always
  // try to steal the focus from the editor canvas.

  (0, _element.useEffect)(() => {
    if (!isTreeGridMounted && isSelected) {
      cellRef.current.focus();
    }
  }, []);
  const onMouseEnter = (0, _element.useCallback)(() => {
    setIsHovered(true);
    toggleBlockHighlight(clientId, true);
  }, [clientId, setIsHovered, toggleBlockHighlight]);
  const onMouseLeave = (0, _element.useCallback)(() => {
    setIsHovered(false);
    toggleBlockHighlight(clientId, false);
  }, [clientId, setIsHovered, toggleBlockHighlight]);
  const selectEditorBlock = (0, _element.useCallback)(event => {
    selectBlock(event, clientId);
    event.preventDefault();
  }, [clientId, selectBlock]);
  const updateSelection = (0, _element.useCallback)(newClientId => {
    selectBlock(undefined, newClientId);
  }, [selectBlock]);
  const {
    isTreeGridMounted,
    expand,
    collapse,
    LeafMoreMenu
  } = (0, _context.useListViewContext)();
  const toggleExpanded = (0, _element.useCallback)(event => {
    // Prevent shift+click from opening link in a new window when toggling.
    event.preventDefault();
    event.stopPropagation();

    if (isExpanded === true) {
      collapse(clientId);
    } else if (isExpanded === false) {
      expand(clientId);
    }
  }, [clientId, expand, collapse, isExpanded]);
  const instanceId = (0, _compose.useInstanceId)(ListViewBlock);

  if (!block) {
    return null;
  } // When a block hides its toolbar it also hides the block settings menu,
  // since that menu is part of the toolbar in the editor canvas.
  // List View respects this by also hiding the block settings menu.


  const showBlockActions = !!block && (0, _blocks.hasBlockSupport)(block.name, '__experimentalToolbar', true);
  const descriptionId = `list-view-block-select-button__${instanceId}`;
  const blockPositionDescription = (0, _utils.getBlockPositionDescription)(position, siblingBlockCount, level);
  let blockAriaLabel = (0, _i18n.__)('Link');

  if (blockInformation) {
    blockAriaLabel = isLocked ? (0, _i18n.sprintf)( // translators: %s: The title of the block. This string indicates a link to select the locked block.
    (0, _i18n.__)('%s link (locked)'), blockInformation.title) : (0, _i18n.sprintf)( // translators: %s: The title of the block. This string indicates a link to select the block.
    (0, _i18n.__)('%s link'), blockInformation.title);
  }

  const settingsAriaLabel = blockInformation ? (0, _i18n.sprintf)( // translators: %s: The title of the block.
  (0, _i18n.__)('Options for %s block'), blockInformation.title) : (0, _i18n.__)('Options');
  const hasSiblings = siblingBlockCount > 0;
  const hasRenderedMovers = showBlockMovers && hasSiblings;
  const moverCellClassName = (0, _classnames.default)('block-editor-list-view-block__mover-cell', {
    'is-visible': isHovered || isSelected
  });
  const listViewBlockSettingsClassName = (0, _classnames.default)('block-editor-list-view-block__menu-cell', {
    'is-visible': isHovered || isFirstSelectedBlock
  });
  let colSpan;

  if (hasRenderedMovers) {
    colSpan = 1;
  } else if (!showBlockActions) {
    colSpan = 2;
  }

  const classes = (0, _classnames.default)({
    'is-selected': isSelected || forceSelectionContentLock,
    'is-first-selected': isFirstSelectedBlock,
    'is-last-selected': isLastSelectedBlock,
    'is-branch-selected': isBranchSelected,
    'is-dragging': isDragged,
    'has-single-cell': !showBlockActions
  }); // Only include all selected blocks if the currently clicked on block
  // is one of the selected blocks. This ensures that if a user attempts
  // to alter a block that isn't part of the selection, they're still able
  // to do so.

  const dropdownClientIds = selectedClientIds.includes(clientId) ? selectedClientIds : [clientId];
  const MoreMenuComponent = LeafMoreMenu ? LeafMoreMenu : _blockSettingsDropdown.default;
  return (0, _element.createElement)(_leaf.default, {
    className: classes,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onFocus: onMouseEnter,
    onBlur: onMouseLeave,
    level: level,
    position: position,
    rowCount: rowCount,
    path: path,
    id: `list-view-block-${clientId}`,
    "data-block": clientId,
    isExpanded: isContentLocked ? undefined : isExpanded,
    "aria-selected": !!isSelected || forceSelectionContentLock
  }, (0, _element.createElement)(_components.__experimentalTreeGridCell, {
    className: "block-editor-list-view-block__contents-cell",
    colSpan: colSpan,
    ref: cellRef,
    "aria-label": blockAriaLabel,
    "aria-selected": !!isSelected || forceSelectionContentLock,
    "aria-expanded": isContentLocked ? undefined : isExpanded,
    "aria-describedby": descriptionId
  }, _ref2 => {
    let {
      ref,
      tabIndex,
      onFocus
    } = _ref2;
    return (0, _element.createElement)("div", {
      className: "block-editor-list-view-block__contents-container"
    }, (0, _element.createElement)(_blockContents.default, {
      block: block,
      onClick: selectEditorBlock,
      onToggleExpanded: toggleExpanded,
      isSelected: isSelected,
      position: position,
      siblingBlockCount: siblingBlockCount,
      level: level,
      ref: ref,
      tabIndex: tabIndex,
      onFocus: onFocus,
      isExpanded: isExpanded,
      selectedClientIds: selectedClientIds,
      preventAnnouncement: preventAnnouncement
    }), (0, _element.createElement)("div", {
      className: "block-editor-list-view-block-select-button__description",
      id: descriptionId
    }, blockPositionDescription));
  }), hasRenderedMovers && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.__experimentalTreeGridCell, {
    className: moverCellClassName,
    withoutGridItem: true
  }, (0, _element.createElement)(_components.__experimentalTreeGridItem, null, _ref3 => {
    let {
      ref,
      tabIndex,
      onFocus
    } = _ref3;
    return (0, _element.createElement)(_button.BlockMoverUpButton, {
      orientation: "vertical",
      clientIds: [clientId],
      ref: ref,
      tabIndex: tabIndex,
      onFocus: onFocus
    });
  }), (0, _element.createElement)(_components.__experimentalTreeGridItem, null, _ref4 => {
    let {
      ref,
      tabIndex,
      onFocus
    } = _ref4;
    return (0, _element.createElement)(_button.BlockMoverDownButton, {
      orientation: "vertical",
      clientIds: [clientId],
      ref: ref,
      tabIndex: tabIndex,
      onFocus: onFocus
    });
  }))), showBlockActions && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.__experimentalTreeGridCell, {
    className: listViewBlockSettingsClassName,
    "aria-selected": !!isSelected || forceSelectionContentLock
  }, _ref5 => {
    let {
      ref,
      tabIndex,
      onFocus
    } = _ref5;
    return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(MoreMenuComponent, {
      clientIds: dropdownClientIds,
      block: block,
      clientId: clientId,
      icon: _icons.moreVertical,
      label: settingsAriaLabel,
      toggleProps: {
        ref,
        className: 'block-editor-list-view-block__menu',
        tabIndex,
        onFocus
      },
      disableOpenOnArrowDown: true,
      __experimentalSelectBlock: updateSelection
    }));
  })));
}

var _default = (0, _element.memo)(ListViewBlock);

exports.default = _default;
//# sourceMappingURL=block.js.map