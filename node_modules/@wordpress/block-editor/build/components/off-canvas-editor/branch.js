"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _appender = require("./appender");

var _block = _interopRequireDefault(require("./block"));

var _context = require("./context");

var _utils = require("./utils");

var _store = require("../../store");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Given a block, returns the total number of blocks in that subtree. This is used to help determine
 * the list position of a block.
 *
 * When a block is collapsed, we do not count their children as part of that total. In the current drag
 * implementation dragged blocks and their children are not counted.
 *
 * @param {Object}  block               block tree
 * @param {Object}  expandedState       state that notes which branches are collapsed
 * @param {Array}   draggedClientIds    a list of dragged client ids
 * @param {boolean} isExpandedByDefault flag to determine the default fallback expanded state.
 * @return {number} block count
 */
function countBlocks(block, expandedState, draggedClientIds, isExpandedByDefault) {
  var _expandedState$block$;

  const isDragged = draggedClientIds === null || draggedClientIds === void 0 ? void 0 : draggedClientIds.includes(block.clientId);

  if (isDragged) {
    return 0;
  }

  const isExpanded = (_expandedState$block$ = expandedState[block.clientId]) !== null && _expandedState$block$ !== void 0 ? _expandedState$block$ : isExpandedByDefault;

  if (isExpanded) {
    return 1 + block.innerBlocks.reduce(countReducer(expandedState, draggedClientIds, isExpandedByDefault), 0);
  }

  return 1;
}

const countReducer = (expandedState, draggedClientIds, isExpandedByDefault) => (count, block) => {
  var _expandedState$block$2;

  const isDragged = draggedClientIds === null || draggedClientIds === void 0 ? void 0 : draggedClientIds.includes(block.clientId);

  if (isDragged) {
    return count;
  }

  const isExpanded = (_expandedState$block$2 = expandedState[block.clientId]) !== null && _expandedState$block$2 !== void 0 ? _expandedState$block$2 : isExpandedByDefault;

  if (isExpanded && block.innerBlocks.length > 0) {
    return count + countBlocks(block, expandedState, draggedClientIds, isExpandedByDefault);
  }

  return count + 1;
};

const noop = () => {};

function ListViewBranch(props) {
  const {
    blocks,
    selectBlock = noop,
    showBlockMovers,
    selectedClientIds,
    level = 1,
    path = '',
    isBranchSelected = false,
    listPosition = 0,
    fixedListWindow,
    isExpanded,
    parentId,
    shouldShowInnerBlocks = true
  } = props;
  const isContentLocked = (0, _data.useSelect)(select => {
    return !!(parentId && select(_store.store).getTemplateLock(parentId) === 'contentOnly');
  }, [parentId]);
  const {
    expandedState,
    draggedClientIds
  } = (0, _context.useListViewContext)();

  if (isContentLocked) {
    return null;
  } // Only show the appender at the first level.


  const showAppender = level === 1;
  const filteredBlocks = blocks.filter(Boolean);
  const blockCount = filteredBlocks.length; // The appender means an extra row in List View, so add 1 to the row count.

  const rowCount = showAppender ? blockCount + 1 : blockCount;
  let nextPosition = listPosition;
  return (0, _element.createElement)(_element.Fragment, null, filteredBlocks.map((block, index) => {
    var _expandedState$client;

    const {
      clientId,
      innerBlocks
    } = block;

    if (index > 0) {
      nextPosition += countBlocks(filteredBlocks[index - 1], expandedState, draggedClientIds, isExpanded);
    }

    const {
      itemInView
    } = fixedListWindow;
    const blockInView = itemInView(nextPosition);
    const position = index + 1;
    const updatedPath = path.length > 0 ? `${path}_${position}` : `${position}`;
    const hasNestedBlocks = !!(innerBlocks !== null && innerBlocks !== void 0 && innerBlocks.length);
    const shouldExpand = hasNestedBlocks && shouldShowInnerBlocks ? (_expandedState$client = expandedState[clientId]) !== null && _expandedState$client !== void 0 ? _expandedState$client : isExpanded : undefined;
    const isDragged = !!(draggedClientIds !== null && draggedClientIds !== void 0 && draggedClientIds.includes(clientId));
    const showBlock = isDragged || blockInView; // Make updates to the selected or dragged blocks synchronous,
    // but asynchronous for any other block.

    const isSelected = (0, _utils.isClientIdSelected)(clientId, selectedClientIds);
    const isSelectedBranch = isBranchSelected || isSelected && hasNestedBlocks;
    return (0, _element.createElement)(_data.AsyncModeProvider, {
      key: clientId,
      value: !isSelected
    }, showBlock && (0, _element.createElement)(_block.default, {
      block: block,
      selectBlock: selectBlock,
      isSelected: isSelected,
      isBranchSelected: isSelectedBranch,
      isDragged: isDragged,
      level: level,
      position: position,
      rowCount: rowCount,
      siblingBlockCount: blockCount,
      showBlockMovers: showBlockMovers,
      path: updatedPath,
      isExpanded: shouldExpand,
      listPosition: nextPosition,
      selectedClientIds: selectedClientIds
    }), !showBlock && (0, _element.createElement)("tr", null, (0, _element.createElement)("td", {
      className: "block-editor-list-view-placeholder"
    })), hasNestedBlocks && shouldExpand && !isDragged && (0, _element.createElement)(ListViewBranch, {
      parentId: clientId,
      blocks: innerBlocks,
      selectBlock: selectBlock,
      showBlockMovers: showBlockMovers,
      level: level + 1,
      path: updatedPath,
      listPosition: nextPosition + 1,
      fixedListWindow: fixedListWindow,
      isBranchSelected: isSelectedBranch,
      selectedClientIds: selectedClientIds,
      isExpanded: isExpanded
    }));
  }), showAppender && (0, _element.createElement)(_components.__experimentalTreeGridRow, {
    level: level,
    setSize: rowCount,
    positionInSet: rowCount,
    isExpanded: true
  }, (0, _element.createElement)(_components.__experimentalTreeGridCell, null, treeGridCellProps => (0, _element.createElement)(_appender.Appender, (0, _extends2.default)({
    clientId: parentId,
    nestingLevel: level,
    blockCount: blockCount
  }, treeGridCellProps)))));
}

var _default = (0, _element.memo)(ListViewBranch);

exports.default = _default;
//# sourceMappingURL=branch.js.map