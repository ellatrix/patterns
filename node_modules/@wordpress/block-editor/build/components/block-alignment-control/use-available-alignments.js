"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useAvailableAlignments;

var _data = require("@wordpress/data");

var _layout = require("../block-list/layout");

var _store = require("../../store");

var _layouts = require("../../layouts");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const EMPTY_ARRAY = [];
const DEFAULT_CONTROLS = ['none', 'left', 'center', 'right', 'wide', 'full'];
const WIDE_CONTROLS = ['wide', 'full'];

function useAvailableAlignments() {
  let controls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_CONTROLS;

  // Always add the `none` option if not exists.
  if (!controls.includes('none')) {
    controls = ['none', ...controls];
  }

  const {
    wideControlsEnabled = false,
    themeSupportsLayout,
    isBlockBasedTheme
  } = (0, _data.useSelect)(select => {
    const {
      getSettings
    } = select(_store.store);
    const settings = getSettings();
    return {
      wideControlsEnabled: settings.alignWide,
      themeSupportsLayout: settings.supportsLayout,
      isBlockBasedTheme: settings.__unstableIsBlockBasedTheme
    };
  }, []);
  const layout = (0, _layout.useLayout)();
  const layoutType = (0, _layouts.getLayoutType)(layout === null || layout === void 0 ? void 0 : layout.type);
  const layoutAlignments = layoutType.getAlignments(layout, isBlockBasedTheme);

  if (themeSupportsLayout) {
    const alignments = layoutAlignments.filter(_ref => {
      let {
        name: alignmentName
      } = _ref;
      return controls.includes(alignmentName);
    }); // While we treat `none` as an alignment, we shouldn't return it if no
    // other alignments exist.

    if (alignments.length === 1 && alignments[0].name === 'none') {
      return EMPTY_ARRAY;
    }

    return alignments;
  } // Starting here, it's the fallback for themes not supporting the layout config.


  if (layoutType.name !== 'default' && layoutType.name !== 'constrained') {
    return EMPTY_ARRAY;
  }

  const {
    alignments: availableAlignments = DEFAULT_CONTROLS
  } = layout;
  const enabledControls = controls.filter(control => (layout.alignments || // Ignore the global wideAlignment check if the layout explicitely defines alignments.
  wideControlsEnabled || !WIDE_CONTROLS.includes(control)) && availableAlignments.includes(control)).map(enabledControl => ({
    name: enabledControl
  })); // While we treat `none` as an alignment, we shouldn't return it if no
  // other alignments exist.

  if (enabledControls.length === 1 && enabledControls[0].name === 'none') {
    return EMPTY_ARRAY;
  }

  return enabledControls;
}
//# sourceMappingURL=use-available-alignments.js.map