"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGlobalSetting = useGlobalSetting;
exports.useGlobalStyle = useGlobalStyle;
exports.useGlobalStylesReset = void 0;
exports.useSettingsForBlockElement = useSettingsForBlockElement;

var _es = _interopRequireDefault(require("fast-deep-equal/es6"));

var _lodash = require("lodash");

var _element = require("@wordpress/element");

var _data = require("@wordpress/data");

var _blocks = require("@wordpress/blocks");

var _utils = require("./utils");

var _context = require("./context");

var _lockUnlock = require("../../lock-unlock");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const EMPTY_CONFIG = {
  settings: {},
  styles: {}
};
const VALID_SETTINGS = ['appearanceTools', 'useRootPaddingAwareAlignments', 'border.color', 'border.radius', 'border.style', 'border.width', 'shadow.presets', 'shadow.defaultPresets', 'color.background', 'color.custom', 'color.customDuotone', 'color.customGradient', 'color.defaultDuotone', 'color.defaultGradients', 'color.defaultPalette', 'color.duotone', 'color.gradients', 'color.link', 'color.palette', 'color.text', 'custom', 'dimensions.minHeight', 'layout.contentSize', 'layout.definitions', 'layout.wideSize', 'position.fixed', 'position.sticky', 'spacing.customSpacingSize', 'spacing.spacingSizes', 'spacing.spacingScale', 'spacing.blockGap', 'spacing.margin', 'spacing.padding', 'spacing.units', 'typography.fluid', 'typography.customFontSize', 'typography.dropCap', 'typography.fontFamilies', 'typography.fontSizes', 'typography.fontStyle', 'typography.fontWeight', 'typography.letterSpacing', 'typography.lineHeight', 'typography.textDecoration', 'typography.textTransform'];

const useGlobalStylesReset = () => {
  const {
    user: config,
    setUserConfig
  } = (0, _element.useContext)(_context.GlobalStylesContext);
  const canReset = !!config && !(0, _es.default)(config, EMPTY_CONFIG);
  return [canReset, (0, _element.useCallback)(() => setUserConfig(() => EMPTY_CONFIG), [setUserConfig])];
};

exports.useGlobalStylesReset = useGlobalStylesReset;

function useGlobalSetting(propertyPath, blockName) {
  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'all';
  const {
    setUserConfig,
    ...configs
  } = (0, _element.useContext)(_context.GlobalStylesContext);
  const appendedBlockPath = blockName ? '.blocks.' + blockName : '';
  const appendedPropertyPath = propertyPath ? '.' + propertyPath : '';
  const contextualPath = `settings${appendedBlockPath}${appendedPropertyPath}`;
  const globalPath = `settings${appendedPropertyPath}`;
  const sourceKey = source === 'all' ? 'merged' : source;
  const settingValue = (0, _element.useMemo)(() => {
    const configToUse = configs[sourceKey];

    if (!configToUse) {
      throw 'Unsupported source';
    }

    if (propertyPath) {
      var _get;

      return (_get = (0, _lodash.get)(configToUse, contextualPath)) !== null && _get !== void 0 ? _get : (0, _lodash.get)(configToUse, globalPath);
    }

    const result = {};
    VALID_SETTINGS.forEach(setting => {
      var _get2;

      const value = (_get2 = (0, _lodash.get)(configToUse, `settings${appendedBlockPath}.${setting}`)) !== null && _get2 !== void 0 ? _get2 : (0, _lodash.get)(configToUse, `settings.${setting}`);

      if (value) {
        (0, _lodash.set)(result, setting, value);
      }
    });
    return result;
  }, [configs, sourceKey, propertyPath, contextualPath, globalPath, appendedBlockPath]);

  const setSetting = newValue => {
    setUserConfig(currentConfig => {
      // Deep clone `currentConfig` to avoid mutating it later.
      const newUserConfig = JSON.parse(JSON.stringify(currentConfig));
      (0, _lodash.set)(newUserConfig, contextualPath, newValue);
      return newUserConfig;
    });
  };

  return [settingValue, setSetting];
}

function useGlobalStyle(path, blockName) {
  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'all';
  let {
    shouldDecodeEncode = true
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const {
    merged: mergedConfig,
    base: baseConfig,
    user: userConfig,
    setUserConfig
  } = (0, _element.useContext)(_context.GlobalStylesContext);
  const appendedPath = path ? '.' + path : '';
  const finalPath = !blockName ? `styles${appendedPath}` : `styles.blocks.${blockName}${appendedPath}`;

  const setStyle = newValue => {
    setUserConfig(currentConfig => {
      // Deep clone `currentConfig` to avoid mutating it later.
      const newUserConfig = JSON.parse(JSON.stringify(currentConfig));
      (0, _lodash.set)(newUserConfig, finalPath, shouldDecodeEncode ? (0, _utils.getPresetVariableFromValue)(mergedConfig.settings, blockName, path, newValue) : newValue);
      return newUserConfig;
    });
  };

  let rawResult, result;

  switch (source) {
    case 'all':
      rawResult = // The stlyes.css path is allowed to be empty, so don't revert to base if undefined.
      finalPath === 'styles.css' ? (0, _lodash.get)(userConfig, finalPath) : (0, _lodash.get)(mergedConfig, finalPath);
      result = shouldDecodeEncode ? (0, _utils.getValueFromVariable)(mergedConfig, blockName, rawResult) : rawResult;
      break;

    case 'user':
      rawResult = (0, _lodash.get)(userConfig, finalPath);
      result = shouldDecodeEncode ? (0, _utils.getValueFromVariable)(mergedConfig, blockName, rawResult) : rawResult;
      break;

    case 'base':
      rawResult = (0, _lodash.get)(baseConfig, finalPath);
      result = shouldDecodeEncode ? (0, _utils.getValueFromVariable)(baseConfig, blockName, rawResult) : rawResult;
      break;

    default:
      throw 'Unsupported source';
  }

  return [result, setStyle];
}
/**
 * React hook that overrides a global settings object with block and element specific settings.
 *
 * @param {Object}     parentSettings Settings object.
 * @param {blockName?} blockName      Block name.
 * @param {element?}   element        Element name.
 *
 * @return {Object} Merge of settings and supports.
 */


function useSettingsForBlockElement(parentSettings, blockName, element) {
  const {
    supportedStyles,
    supports
  } = (0, _data.useSelect)(select => {
    var _select$getBlockType;

    return {
      supportedStyles: (0, _lockUnlock.unlock)(select(_blocks.store)).getSupportedStyles(blockName, element),
      supports: (_select$getBlockType = select(_blocks.store).getBlockType(blockName)) === null || _select$getBlockType === void 0 ? void 0 : _select$getBlockType.supports
    };
  }, [blockName, element]);
  return (0, _element.useMemo)(() => {
    const updatedSettings = { ...parentSettings
    };

    if (!supportedStyles.includes('fontSize')) {
      updatedSettings.typography = { ...updatedSettings.typography,
        fontSizes: {},
        customFontSize: false
      };
    }

    if (!supportedStyles.includes('fontFamily')) {
      updatedSettings.typography = { ...updatedSettings.typography,
        fontFamilies: {}
      };
    }

    ['lineHeight', 'fontStyle', 'fontWeight', 'letterSpacing', 'textTransform', 'textDecoration'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.typography = { ...updatedSettings.typography,
          [key]: false
        };
      }
    });
    ['contentSize', 'wideSize'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.layout = { ...updatedSettings.layout,
          [key]: false
        };
      }
    });
    ['padding', 'margin', 'blockGap'].forEach(key => {
      var _supports$spacing, _supports$spacing2, _supports$spacing3, _supports$spacing3$ke;

      if (!supportedStyles.includes(key)) {
        updatedSettings.spacing = { ...updatedSettings.spacing,
          [key]: false
        };
      }

      const sides = Array.isArray(supports === null || supports === void 0 ? void 0 : (_supports$spacing = supports.spacing) === null || _supports$spacing === void 0 ? void 0 : _supports$spacing[key]) ? supports === null || supports === void 0 ? void 0 : (_supports$spacing2 = supports.spacing) === null || _supports$spacing2 === void 0 ? void 0 : _supports$spacing2[key] : supports === null || supports === void 0 ? void 0 : (_supports$spacing3 = supports.spacing) === null || _supports$spacing3 === void 0 ? void 0 : (_supports$spacing3$ke = _supports$spacing3[key]) === null || _supports$spacing3$ke === void 0 ? void 0 : _supports$spacing3$ke.sides;

      if (sides !== null && sides !== void 0 && sides.length) {
        var _updatedSettings$spac;

        updatedSettings.spacing = { ...updatedSettings.spacing,
          [key]: { ...((_updatedSettings$spac = updatedSettings.spacing) === null || _updatedSettings$spac === void 0 ? void 0 : _updatedSettings$spac[key]),
            sides
          }
        };
      }
    });

    if (!supportedStyles.includes('minHeight')) {
      updatedSettings.dimensions = { ...updatedSettings.dimensions,
        minHeight: false
      };
    }

    return updatedSettings;
  }, [parentSettings, supportedStyles, supports]);
}
//# sourceMappingURL=hooks.js.map