{"version":3,"sources":["@wordpress/block-editor/src/components/rich-text/use-before-input-rules.js"],"names":["wrapSelectionSettings","useBeforeInputRules","props","__unstableMarkLastChangeAsPersistent","__unstableMarkAutomaticChange","blockEditorStore","propsRef","current","element","onInput","event","inputType","data","value","onChange","pair","find","startChar","endChar","start","end","length","newValue","init","key","ownerDocument","defaultView","newEvent","InputEvent","window","queueMicrotask","target","dispatchEvent","preventDefault","addEventListener","removeEventListener"],"mappings":";;;;;;;AAGA;;AACA;;AACA;;AACA;;AACA;;AAKA;;AAZA;AACA;AACA;;AAOA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,qBAAqB,GAAG,CAAE,GAAF,EAAO,GAAP,EAAY,GAAZ,EAAiB,IAAjB,EAAuB,IAAvB,CAA9B;;AAEO,SAASC,mBAAT,CAA8BC,KAA9B,EAAsC;AAC5C,QAAM;AACLC,IAAAA,oCADK;AAELC,IAAAA;AAFK,MAGF,uBAAaC,YAAb,CAHJ;AAIA,QAAMC,QAAQ,GAAG,qBAAQJ,KAAR,CAAjB;AACAI,EAAAA,QAAQ,CAACC,OAAT,GAAmBL,KAAnB;AACA,SAAO,2BAAgBM,OAAF,IAAe;AACnC,aAASC,OAAT,CAAkBC,KAAlB,EAA0B;AACzB,YAAM;AAAEC,QAAAA,SAAF;AAAaC,QAAAA;AAAb,UAAsBF,KAA5B;AACA,YAAM;AAAEG,QAAAA,KAAF;AAASC,QAAAA;AAAT,UAAsBR,QAAQ,CAACC,OAArC,CAFyB,CAIzB;;AACA,UAAKI,SAAS,KAAK,YAAnB,EAAkC;AACjC;AACA;;AAED,UAAK,2BAAaE,KAAb,CAAL,EAA4B;AAC3B;AACA;;AAED,YAAME,IAAI,GAAG,yBACZ,mCADY,EAEZf,qBAFY,EAGXgB,IAHW,CAIZ;AAAA,YAAE,CAAEC,SAAF,EAAaC,OAAb,CAAF;AAAA,eACCD,SAAS,KAAKL,IAAd,IAAsBM,OAAO,KAAKN,IADnC;AAAA,OAJY,CAAb;;AAQA,UAAK,CAAEG,IAAP,EAAc;AACb;AACA;;AAED,YAAM,CAAEE,SAAF,EAAaC,OAAO,GAAGD,SAAvB,IAAqCF,IAA3C;AACA,YAAMI,KAAK,GAAGN,KAAK,CAACM,KAApB;AACA,YAAMC,GAAG,GAAGP,KAAK,CAACO,GAAN,GAAYH,SAAS,CAACI,MAAlC;AAEA,UAAIC,QAAQ,GAAG,sBAAQT,KAAR,EAAeI,SAAf,EAA0BE,KAA1B,EAAiCA,KAAjC,CAAf;AACAG,MAAAA,QAAQ,GAAG,sBAAQA,QAAR,EAAkBJ,OAAlB,EAA2BE,GAA3B,EAAgCA,GAAhC,CAAX;;AAEAjB,MAAAA,oCAAoC;;AACpCW,MAAAA,QAAQ,CAAEQ,QAAF,CAAR;;AACAlB,MAAAA,6BAA6B;;AAE7B,YAAMmB,IAAI,GAAG,EAAb;;AAEA,WAAM,MAAMC,GAAZ,IAAmBd,KAAnB,EAA2B;AAC1Ba,QAAAA,IAAI,CAAEC,GAAF,CAAJ,GAAcd,KAAK,CAAEc,GAAF,CAAnB;AACA;;AAEDD,MAAAA,IAAI,CAACX,IAAL,GAAYM,OAAZ;AAEA,YAAM;AAAEO,QAAAA;AAAF,UAAoBjB,OAA1B;AACA,YAAM;AAAEkB,QAAAA;AAAF,UAAkBD,aAAxB;AACA,YAAME,QAAQ,GAAG,IAAID,WAAW,CAACE,UAAhB,CAA4B,OAA5B,EAAqCL,IAArC,CAAjB,CA9CyB,CAgDzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAM,MAAAA,MAAM,CAACC,cAAP,CAAuB,MAAM;AAC5BpB,QAAAA,KAAK,CAACqB,MAAN,CAAaC,aAAb,CAA4BL,QAA5B;AACA,OAFD;AAGAjB,MAAAA,KAAK,CAACuB,cAAN;AACA;;AAEDzB,IAAAA,OAAO,CAAC0B,gBAAR,CAA0B,aAA1B,EAAyCzB,OAAzC;AACA,WAAO,MAAM;AACZD,MAAAA,OAAO,CAAC2B,mBAAR,CAA6B,aAA7B,EAA4C1B,OAA5C;AACA,KAFD;AAGA,GAnEM,EAmEJ,EAnEI,CAAP;AAoEA","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useRef } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\nimport { insert, isCollapsed } from '@wordpress/rich-text';\nimport { useDispatch } from '@wordpress/data';\nimport { applyFilters } from '@wordpress/hooks';\n\n/**\n * Internal dependencies\n */\nimport { store as blockEditorStore } from '../../store';\n\n/**\n * When typing over a selection, the selection will we wrapped by a matching\n * character pair. The second character is optional, it defaults to the first\n * character.\n *\n * @type {string[]} Array of character pairs.\n */\nconst wrapSelectionSettings = [ '`', '\"', \"'\", '“”', '‘’' ];\n\nexport function useBeforeInputRules( props ) {\n\tconst {\n\t\t__unstableMarkLastChangeAsPersistent,\n\t\t__unstableMarkAutomaticChange,\n\t} = useDispatch( blockEditorStore );\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onInput( event ) {\n\t\t\tconst { inputType, data } = event;\n\t\t\tconst { value, onChange } = propsRef.current;\n\n\t\t\t// Only run the rules when inserting text.\n\t\t\tif ( inputType !== 'insertText' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isCollapsed( value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst pair = applyFilters(\n\t\t\t\t'blockEditor.wrapSelectionSettings',\n\t\t\t\twrapSelectionSettings\n\t\t\t).find(\n\t\t\t\t( [ startChar, endChar ] ) =>\n\t\t\t\t\tstartChar === data || endChar === data\n\t\t\t);\n\n\t\t\tif ( ! pair ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [ startChar, endChar = startChar ] = pair;\n\t\t\tconst start = value.start;\n\t\t\tconst end = value.end + startChar.length;\n\n\t\t\tlet newValue = insert( value, startChar, start, start );\n\t\t\tnewValue = insert( newValue, endChar, end, end );\n\n\t\t\t__unstableMarkLastChangeAsPersistent();\n\t\t\tonChange( newValue );\n\t\t\t__unstableMarkAutomaticChange();\n\n\t\t\tconst init = {};\n\n\t\t\tfor ( const key in event ) {\n\t\t\t\tinit[ key ] = event[ key ];\n\t\t\t}\n\n\t\t\tinit.data = endChar;\n\n\t\t\tconst { ownerDocument } = element;\n\t\t\tconst { defaultView } = ownerDocument;\n\t\t\tconst newEvent = new defaultView.InputEvent( 'input', init );\n\n\t\t\t// Dispatch an `input` event with the new data. This will trigger the\n\t\t\t// input rules.\n\t\t\t// Postpone the `input` to the next event loop tick so that the dispatch\n\t\t\t// doesn't happen synchronously in the middle of `beforeinput` dispatch.\n\t\t\t// This is closer to how native `input` event would be timed, and also\n\t\t\t// makes sure that the `input` event is dispatched only after the `onChange`\n\t\t\t// call few lines above has fully updated the data store state and rerendered\n\t\t\t// all affected components.\n\t\t\twindow.queueMicrotask( () => {\n\t\t\t\tevent.target.dispatchEvent( newEvent );\n\t\t\t} );\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\telement.addEventListener( 'beforeinput', onInput );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'beforeinput', onInput );\n\t\t};\n\t}, [] );\n}\n"]}