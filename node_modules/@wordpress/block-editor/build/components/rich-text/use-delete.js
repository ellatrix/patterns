"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDelete = useDelete;

var _element = require("@wordpress/element");

var _compose = require("@wordpress/compose");

var _keycodes = require("@wordpress/keycodes");

var _richText = require("@wordpress/rich-text");

/**
 * WordPress dependencies
 */
function useDelete(props) {
  const propsRef = (0, _element.useRef)(props);
  propsRef.current = props;
  return (0, _compose.useRefEffect)(element => {
    function onKeyDown(event) {
      const {
        keyCode
      } = event;

      if (event.defaultPrevented) {
        return;
      }

      const {
        value,
        onMerge,
        onRemove
      } = propsRef.current;

      if (keyCode === _keycodes.DELETE || keyCode === _keycodes.BACKSPACE) {
        const {
          start,
          end,
          text
        } = value;
        const isReverse = keyCode === _keycodes.BACKSPACE;
        const hasActiveFormats = value.activeFormats && !!value.activeFormats.length; // Only process delete if the key press occurs at an uncollapsed edge.

        if (!(0, _richText.isCollapsed)(value) || hasActiveFormats || isReverse && start !== 0 || !isReverse && end !== text.length) {
          return;
        }

        if (onMerge) {
          onMerge(!isReverse);
        } // Only handle remove on Backspace. This serves dual-purpose of being
        // an intentional user interaction distinguishing between Backspace and
        // Delete to remove the empty field, but also to avoid merge & remove
        // causing destruction of two fields (merge, then removed merged).


        if (onRemove && (0, _richText.isEmpty)(value) && isReverse) {
          onRemove(!isReverse);
        }

        event.preventDefault();
      }
    }

    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}
//# sourceMappingURL=use-delete.js.map