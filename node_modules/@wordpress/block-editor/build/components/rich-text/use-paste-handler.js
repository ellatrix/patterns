"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePasteHandler = usePasteHandler;

var _element = require("@wordpress/element");

var _compose = require("@wordpress/compose");

var _dom = require("@wordpress/dom");

var _blocks = require("@wordpress/blocks");

var _richText = require("@wordpress/rich-text");

var _url = require("@wordpress/url");

var _utils = require("./utils");

var _splitValue = require("./split-value");

var _pasting = require("../../utils/pasting");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('@wordpress/rich-text').RichTextValue} RichTextValue */

/**
 * Replaces line separators with line breaks if not multiline.
 * Replaces line breaks with line separators if multiline.
 *
 * @param {RichTextValue} value       Value to adjust.
 * @param {boolean}       isMultiline Whether to adjust to multiline or not.
 *
 * @return {RichTextValue} Adjusted value.
 */
function adjustLines(value, isMultiline) {
  if (isMultiline) {
    return (0, _richText.replace)(value, /\n+/g, _richText.__UNSTABLE_LINE_SEPARATOR);
  }

  return (0, _richText.replace)(value, new RegExp(_richText.__UNSTABLE_LINE_SEPARATOR, 'g'), '\n');
}

function usePasteHandler(props) {
  const propsRef = (0, _element.useRef)(props);
  propsRef.current = props;
  return (0, _compose.useRefEffect)(element => {
    function _onPaste(event) {
      const {
        isSelected,
        disableFormats,
        onChange,
        value,
        formatTypes,
        tagName,
        onReplace,
        onSplit,
        onSplitMiddle,
        __unstableEmbedURLOnPaste,
        multilineTag,
        preserveWhiteSpace,
        pastePlainText
      } = propsRef.current;

      if (!isSelected) {
        return;
      }

      const {
        clipboardData
      } = event;
      let plainText = '';
      let html = ''; // IE11 only supports `Text` as an argument for `getData` and will
      // otherwise throw an invalid argument error, so we try the standard
      // arguments first, then fallback to `Text` if they fail.

      try {
        plainText = clipboardData.getData('text/plain');
        html = clipboardData.getData('text/html');
      } catch (error1) {
        try {
          html = clipboardData.getData('Text');
        } catch (error2) {
          // Some browsers like UC Browser paste plain text by default and
          // don't support clipboardData at all, so allow default
          // behaviour.
          return;
        }
      } // Remove Windows-specific metadata appended within copied HTML text.


      html = removeWindowsFragments(html); // Strip meta tag.

      html = removeCharsetMetaTag(html);
      event.preventDefault(); // Allows us to ask for this information when we get a report.

      window.console.log('Received HTML:\n\n', html);
      window.console.log('Received plain text:\n\n', plainText);

      if (disableFormats) {
        onChange((0, _richText.insert)(value, plainText));
        return;
      }

      const transformed = formatTypes.reduce((accumlator, _ref) => {
        let {
          __unstablePasteRule
        } = _ref;

        // Only allow one transform.
        if (__unstablePasteRule && accumlator === value) {
          accumlator = __unstablePasteRule(value, {
            html,
            plainText
          });
        }

        return accumlator;
      }, value);

      if (transformed !== value) {
        onChange(transformed);
        return;
      }

      const files = [...(0, _dom.getFilesFromDataTransfer)(clipboardData)];
      const isInternal = clipboardData.getData('rich-text') === 'true'; // If the data comes from a rich text instance, we can directly use it
      // without filtering the data. The filters are only meant for externally
      // pasted content and remove inline styles.

      if (isInternal) {
        const pastedMultilineTag = clipboardData.getData('rich-text-multi-line-tag') || undefined;
        let pastedValue = (0, _richText.create)({
          html,
          multilineTag: pastedMultilineTag,
          multilineWrapperTags: pastedMultilineTag === 'li' ? ['ul', 'ol'] : undefined,
          preserveWhiteSpace
        });
        pastedValue = adjustLines(pastedValue, !!multilineTag);
        (0, _utils.addActiveFormats)(pastedValue, value.activeFormats);
        onChange((0, _richText.insert)(value, pastedValue));
        return;
      }

      if (pastePlainText) {
        onChange((0, _richText.insert)(value, (0, _richText.create)({
          text: plainText
        })));
        return;
      }

      if (files !== null && files !== void 0 && files.length) {
        // Allows us to ask for this information when we get a report.
        // eslint-disable-next-line no-console
        window.console.log('Received items:\n\n', files);
      } // Process any attached files, unless we infer that the files in
      // question are redundant "screenshots" of the actual HTML payload,
      // as created by certain office-type programs.
      //
      // @see shouldDismissPastedFiles


      if (files !== null && files !== void 0 && files.length && !(0, _pasting.shouldDismissPastedFiles)(files, html, plainText)) {
        const fromTransforms = (0, _blocks.getBlockTransforms)('from');
        const blocks = files.reduce((accumulator, file) => {
          const transformation = (0, _blocks.findTransform)(fromTransforms, transform => transform.type === 'files' && transform.isMatch([file]));

          if (transformation) {
            accumulator.push(transformation.transform([file]));
          }

          return accumulator;
        }, []).flat();

        if (!blocks.length) {
          return;
        }

        if (onReplace && (0, _richText.isEmpty)(value)) {
          onReplace(blocks);
        } else {
          (0, _splitValue.splitValue)({
            value,
            pastedBlocks: blocks,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        }

        return;
      }

      let mode = onReplace && onSplit ? 'AUTO' : 'INLINE'; // Force the blocks mode when the user is pasting
      // on a new line & the content resembles a shortcode.
      // Otherwise it's going to be detected as inline
      // and the shortcode won't be replaced.

      if (mode === 'AUTO' && (0, _richText.isEmpty)(value) && (0, _utils.isShortcode)(plainText)) {
        mode = 'BLOCKS';
      }

      if (__unstableEmbedURLOnPaste && (0, _richText.isEmpty)(value) && (0, _url.isURL)(plainText.trim())) {
        mode = 'BLOCKS';
      }

      const content = (0, _blocks.pasteHandler)({
        HTML: html,
        plainText,
        mode,
        tagName,
        preserveWhiteSpace
      });

      if (typeof content === 'string') {
        let valueToInsert = (0, _richText.create)({
          html: content
        }); // If the content should be multiline, we should process text
        // separated by a line break as separate lines.

        valueToInsert = adjustLines(valueToInsert, !!multilineTag);
        (0, _utils.addActiveFormats)(valueToInsert, value.activeFormats);
        onChange((0, _richText.insert)(value, valueToInsert));
      } else if (content.length > 0) {
        if (onReplace && (0, _richText.isEmpty)(value)) {
          onReplace(content, content.length - 1, -1);
        } else {
          (0, _splitValue.splitValue)({
            value,
            pastedBlocks: content,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        }
      }
    }

    element.addEventListener('paste', _onPaste);
    return () => {
      element.removeEventListener('paste', _onPaste);
    };
  }, []);
}
/**
 * Normalizes a given string of HTML to remove the Windows-specific "Fragment"
 * comments and any preceding and trailing content.
 *
 * @param {string} html the html to be normalized
 * @return {string} the normalized html
 */


function removeWindowsFragments(html) {
  const startStr = '<!--StartFragment-->';
  const startIdx = html.indexOf(startStr);

  if (startIdx > -1) {
    html = html.substring(startIdx + startStr.length);
  } else {
    // No point looking for EndFragment
    return html;
  }

  const endStr = '<!--EndFragment-->';
  const endIdx = html.indexOf(endStr);

  if (endIdx > -1) {
    html = html.substring(0, endIdx);
  }

  return html;
}
/**
 * Removes the charset meta tag inserted by Chromium.
 * See:
 * - https://github.com/WordPress/gutenberg/issues/33585
 * - https://bugs.chromium.org/p/chromium/issues/detail?id=1264616#c4
 *
 * @param {string} html the html to be stripped of the meta tag.
 * @return {string} the cleaned html
 */


function removeCharsetMetaTag(html) {
  const metaTag = `<meta charset='utf-8'>`;

  if (html.startsWith(metaTag)) {
    return html.slice(metaTag.length);
  }

  return html;
}
//# sourceMappingURL=use-paste-handler.js.map