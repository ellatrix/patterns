"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _data = require("@wordpress/data");

var _block = _interopRequireDefault(require("./block"));

var _context = require("./context");

var _utils = require("./utils");

var _store = require("../../store");

var _useBlockDisplayInformation = _interopRequireDefault(require("../use-block-display-information"));

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Given a block, returns the total number of blocks in that subtree. This is used to help determine
 * the list position of a block.
 *
 * When a block is collapsed, we do not count their children as part of that total. In the current drag
 * implementation dragged blocks and their children are not counted.
 *
 * @param {Object}  block               block tree
 * @param {Object}  expandedState       state that notes which branches are collapsed
 * @param {Array}   draggedClientIds    a list of dragged client ids
 * @param {boolean} isExpandedByDefault flag to determine the default fallback expanded state.
 * @return {number} block count
 */
function countBlocks(block, expandedState, draggedClientIds, isExpandedByDefault) {
  var _expandedState$block$;

  const isDragged = draggedClientIds === null || draggedClientIds === void 0 ? void 0 : draggedClientIds.includes(block.clientId);

  if (isDragged) {
    return 0;
  }

  const isExpanded = (_expandedState$block$ = expandedState[block.clientId]) !== null && _expandedState$block$ !== void 0 ? _expandedState$block$ : isExpandedByDefault;

  if (isExpanded) {
    return 1 + block.innerBlocks.reduce(countReducer(expandedState, draggedClientIds, isExpandedByDefault), 0);
  }

  return 1;
}

const countReducer = (expandedState, draggedClientIds, isExpandedByDefault) => (count, block) => {
  var _expandedState$block$2;

  const isDragged = draggedClientIds === null || draggedClientIds === void 0 ? void 0 : draggedClientIds.includes(block.clientId);

  if (isDragged) {
    return count;
  }

  const isExpanded = (_expandedState$block$2 = expandedState[block.clientId]) !== null && _expandedState$block$2 !== void 0 ? _expandedState$block$2 : isExpandedByDefault;

  if (isExpanded && block.innerBlocks.length > 0) {
    return count + countBlocks(block, expandedState, draggedClientIds, isExpandedByDefault);
  }

  return count + 1;
};

const noop = () => {};

function ListViewBranch(props) {
  const {
    blocks,
    selectBlock = noop,
    showBlockMovers,
    selectedClientIds,
    level = 1,
    path = '',
    isBranchSelected = false,
    listPosition = 0,
    fixedListWindow,
    isExpanded,
    parentId,
    shouldShowInnerBlocks = true,
    isSyncedBranch = false
  } = props;
  const parentBlockInformation = (0, _useBlockDisplayInformation.default)(parentId);
  const syncedBranch = isSyncedBranch || !!(parentBlockInformation !== null && parentBlockInformation !== void 0 && parentBlockInformation.isSynced);
  const canParentExpand = (0, _data.useSelect)(select => {
    if (!parentId) {
      return true;
    }

    const isContentLocked = select(_store.store).getTemplateLock(parentId) === 'contentOnly';
    const canEdit = select(_store.store).canEditBlock(parentId);
    return isContentLocked ? false : canEdit;
  }, [parentId]);
  const {
    expandedState,
    draggedClientIds
  } = (0, _context.useListViewContext)();

  if (!canParentExpand) {
    return null;
  }

  const filteredBlocks = blocks.filter(Boolean);
  const blockCount = filteredBlocks.length;
  let nextPosition = listPosition;
  return (0, _element.createElement)(_element.Fragment, null, filteredBlocks.map((block, index) => {
    var _expandedState$client;

    const {
      clientId,
      innerBlocks
    } = block;

    if (index > 0) {
      nextPosition += countBlocks(filteredBlocks[index - 1], expandedState, draggedClientIds, isExpanded);
    }

    const {
      itemInView
    } = fixedListWindow;
    const blockInView = itemInView(nextPosition);
    const position = index + 1;
    const updatedPath = path.length > 0 ? `${path}_${position}` : `${position}`;
    const hasNestedBlocks = !!(innerBlocks !== null && innerBlocks !== void 0 && innerBlocks.length);
    const shouldExpand = hasNestedBlocks && shouldShowInnerBlocks ? (_expandedState$client = expandedState[clientId]) !== null && _expandedState$client !== void 0 ? _expandedState$client : isExpanded : undefined;
    const isDragged = !!(draggedClientIds !== null && draggedClientIds !== void 0 && draggedClientIds.includes(clientId)); // Make updates to the selected or dragged blocks synchronous,
    // but asynchronous for any other block.

    const isSelected = (0, _utils.isClientIdSelected)(clientId, selectedClientIds);
    const isSelectedBranch = isBranchSelected || isSelected && hasNestedBlocks;
    const showBlock = isDragged || blockInView || isSelected;
    return (0, _element.createElement)(_data.AsyncModeProvider, {
      key: clientId,
      value: !isSelected
    }, showBlock && (0, _element.createElement)(_block.default, {
      block: block,
      selectBlock: selectBlock,
      isSelected: isSelected,
      isBranchSelected: isSelectedBranch,
      isDragged: isDragged,
      level: level,
      position: position,
      rowCount: blockCount,
      siblingBlockCount: blockCount,
      showBlockMovers: showBlockMovers,
      path: updatedPath,
      isExpanded: shouldExpand,
      listPosition: nextPosition,
      selectedClientIds: selectedClientIds,
      isSyncedBranch: syncedBranch
    }), !showBlock && (0, _element.createElement)("tr", null, (0, _element.createElement)("td", {
      className: "block-editor-list-view-placeholder"
    })), hasNestedBlocks && shouldExpand && !isDragged && (0, _element.createElement)(ListViewBranch, {
      parentId: clientId,
      blocks: innerBlocks,
      selectBlock: selectBlock,
      showBlockMovers: showBlockMovers,
      level: level + 1,
      path: updatedPath,
      listPosition: nextPosition + 1,
      fixedListWindow: fixedListWindow,
      isBranchSelected: isSelectedBranch,
      selectedClientIds: selectedClientIds,
      isExpanded: isExpanded,
      isSyncedBranch: syncedBranch
    }));
  }));
}

var _default = (0, _element.memo)(ListViewBranch);

exports.default = _default;
//# sourceMappingURL=branch.js.map