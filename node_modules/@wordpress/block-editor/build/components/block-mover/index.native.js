"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BlockMover = exports.BLOCK_MOVER_DIRECTION_TOP = exports.BLOCK_MOVER_DIRECTION_BOTTOM = void 0;

var _element = require("@wordpress/element");

var _reactNative = require("react-native");

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _moverDescription = require("./mover-description");

var _store = require("../../store");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const BLOCK_MOVER_DIRECTION_TOP = 'blockPageMoverOptions-moveToTop';
exports.BLOCK_MOVER_DIRECTION_TOP = BLOCK_MOVER_DIRECTION_TOP;
const BLOCK_MOVER_DIRECTION_BOTTOM = 'blockPageMoverOptions-moveToBottom';
exports.BLOCK_MOVER_DIRECTION_BOTTOM = BLOCK_MOVER_DIRECTION_BOTTOM;

const BlockMover = _ref => {
  let {
    isFirst,
    isLast,
    canMove,
    onMoveDown,
    onMoveUp,
    onLongMove,
    firstIndex,
    numberOfBlocks,
    rootClientId,
    isStackedHorizontally
  } = _ref;
  const pickerRef = (0, _element.useRef)();
  const [shouldPresentPicker, setShouldPresentPicker] = (0, _element.useState)(false);
  const [blockPageMoverState, setBlockPageMoverState] = (0, _element.useState)(undefined);

  const showBlockPageMover = direction => () => {
    if (!pickerRef.current) {
      setBlockPageMoverState(undefined);
      return;
    }

    setBlockPageMoverState(direction);
    setShouldPresentPicker(true);
  }; // Ensure that the picker is only presented after state updates.


  (0, _element.useEffect)(() => {
    if (shouldPresentPicker) {
      var _pickerRef$current;

      (_pickerRef$current = pickerRef.current) === null || _pickerRef$current === void 0 ? void 0 : _pickerRef$current.presentPicker();
      setShouldPresentPicker(false);
    }
  }, [shouldPresentPicker]);
  const {
    description: {
      backwardButtonHint,
      forwardButtonHint,
      firstBlockTitle,
      lastBlockTitle
    },
    icon: {
      backward: backwardButtonIcon,
      forward: forwardButtonIcon
    },
    title: {
      backward: backwardButtonTitle,
      forward: forwardButtonTitle
    }
  } = (0, _moverDescription.getMoversSetup)(isStackedHorizontally, {
    firstIndex
  });
  const blockPageMoverOptions = [{
    icon: backwardButtonIcon,
    label: (0, _i18n.__)('Move to top'),
    value: BLOCK_MOVER_DIRECTION_TOP,
    onSelect: () => {
      onLongMove()(0);
    }
  }, {
    icon: forwardButtonIcon,
    label: (0, _i18n.__)('Move to bottom'),
    value: BLOCK_MOVER_DIRECTION_BOTTOM,
    onSelect: () => {
      onLongMove()(numberOfBlocks);
    }
  }].filter(el => el.value === blockPageMoverState);

  const onPickerSelect = value => {
    const option = blockPageMoverOptions.find(el => el.value === value);
    if (option && option.onSelect) option.onSelect();
  };

  const onLongPressMoveUp = (0, _element.useCallback)(showBlockPageMover(BLOCK_MOVER_DIRECTION_TOP), []);
  const onLongPressMoveDown = (0, _element.useCallback)(showBlockPageMover(BLOCK_MOVER_DIRECTION_BOTTOM), []);

  if (!canMove || isFirst && isLast && !rootClientId) {
    return null;
  }

  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.ToolbarButton, {
    title: !isFirst ? backwardButtonTitle : firstBlockTitle,
    isDisabled: isFirst,
    onClick: onMoveUp,
    onLongPress: onLongPressMoveUp,
    icon: backwardButtonIcon,
    extraProps: {
      hint: backwardButtonHint
    }
  }), (0, _element.createElement)(_components.ToolbarButton, {
    title: !isLast ? forwardButtonTitle : lastBlockTitle,
    isDisabled: isLast,
    onClick: onMoveDown,
    onLongPress: onLongPressMoveDown,
    icon: forwardButtonIcon,
    extraProps: {
      hint: forwardButtonHint
    }
  }), (0, _element.createElement)(_components.Picker, {
    ref: pickerRef,
    options: blockPageMoverOptions,
    onChange: onPickerSelect,
    title: (0, _i18n.__)('Change block position'),
    leftAlign: true,
    hideCancelButton: _reactNative.Platform.OS !== 'ios'
  }));
};

exports.BlockMover = BlockMover;

var _default = (0, _compose.compose)((0, _data.withSelect)((select, _ref2) => {
  let {
    clientIds
  } = _ref2;
  const {
    getBlockIndex,
    canMoveBlocks,
    getBlockRootClientId,
    getBlockOrder
  } = select(_store.store);
  const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
  const firstClientId = normalizedClientIds[0];
  const rootClientId = getBlockRootClientId(firstClientId);
  const blockOrder = getBlockOrder(rootClientId);
  const firstIndex = getBlockIndex(firstClientId);
  const lastIndex = getBlockIndex(normalizedClientIds[normalizedClientIds.length - 1]);
  return {
    firstIndex,
    numberOfBlocks: blockOrder.length - 1,
    isFirst: firstIndex === 0,
    isLast: lastIndex === blockOrder.length - 1,
    canMove: canMoveBlocks(clientIds, rootClientId),
    rootClientId
  };
}), (0, _data.withDispatch)((dispatch, _ref3) => {
  let {
    clientIds,
    rootClientId
  } = _ref3;
  const {
    moveBlocksDown,
    moveBlocksUp,
    moveBlocksToPosition
  } = dispatch(_store.store);
  return {
    onMoveDown: function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return moveBlocksDown(clientIds, rootClientId, ...args);
    },
    onMoveUp: function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return moveBlocksUp(clientIds, rootClientId, ...args);
    },
    onLongMove: targetIndex => function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return moveBlocksToPosition(clientIds, rootClientId, targetIndex, ...args);
    }
  };
}), _compose.withInstanceId)(BlockMover);

exports.default = _default;
//# sourceMappingURL=index.native.js.map