"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NavigatorProvider = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = require("@emotion/react");

var _isShallowEqual = _interopRequireDefault(require("@wordpress/is-shallow-equal"));

var _context = require("../../ui/context");

var _useCx = require("../../utils/hooks/use-cx");

var _view = require("../../view");

var _context2 = require("../context");

var _router = require("../utils/router");

function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

const MAX_HISTORY_LENGTH = 50;

function screensReducer() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'add':
      return [...state, action.screen];

    case 'remove':
      return state.filter(s => s.id !== action.screen.id);
  }

  return state;
}

var _ref = process.env.NODE_ENV === "production" ? {
  name: "15bx5k",
  styles: "overflow-x:hidden"
} : {
  name: "192ebb7-classes",
  styles: "overflow-x:hidden;label:classes;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbmF2aWdhdG9yL25hdmlnYXRvci1wcm92aWRlci9jb21wb25lbnQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXFQWSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL25hdmlnYXRvci9uYXZpZ2F0b3ItcHJvdmlkZXIvY29tcG9uZW50LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB0eXBlIHsgRm9yd2FyZGVkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIFdvcmRQcmVzcyBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHtcblx0dXNlTWVtbyxcblx0dXNlU3RhdGUsXG5cdHVzZUNhbGxiYWNrLFxuXHR1c2VSZWR1Y2VyLFxuXHR1c2VSZWYsXG5cdHVzZUVmZmVjdCxcbn0gZnJvbSAnQHdvcmRwcmVzcy9lbGVtZW50JztcbmltcG9ydCBpc1NoYWxsb3dFcXVhbCBmcm9tICdAd29yZHByZXNzL2lzLXNoYWxsb3ctZXF1YWwnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQge1xuXHRjb250ZXh0Q29ubmVjdCxcblx0dXNlQ29udGV4dFN5c3RlbSxcblx0V29yZFByZXNzQ29tcG9uZW50UHJvcHMsXG59IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgdXNlQ3ggfSBmcm9tICcuLi8uLi91dGlscy9ob29rcy91c2UtY3gnO1xuaW1wb3J0IHsgVmlldyB9IGZyb20gJy4uLy4uL3ZpZXcnO1xuaW1wb3J0IHsgTmF2aWdhdG9yQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHR5cGUge1xuXHROYXZpZ2F0b3JQcm92aWRlclByb3BzLFxuXHROYXZpZ2F0b3JMb2NhdGlvbixcblx0TmF2aWdhdG9yQ29udGV4dCBhcyBOYXZpZ2F0b3JDb250ZXh0VHlwZSxcblx0U2NyZWVuLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBwYXR0ZXJuTWF0Y2gsIGZpbmRQYXJlbnQgfSBmcm9tICcuLi91dGlscy9yb3V0ZXInO1xuXG50eXBlIE1hdGNoZWRQYXRoID0gUmV0dXJuVHlwZTwgdHlwZW9mIHBhdHRlcm5NYXRjaCA+O1xudHlwZSBTY3JlZW5BY3Rpb24gPSB7IHR5cGU6IHN0cmluZzsgc2NyZWVuOiBTY3JlZW4gfTtcblxuY29uc3QgTUFYX0hJU1RPUllfTEVOR1RIID0gNTA7XG5cbmZ1bmN0aW9uIHNjcmVlbnNSZWR1Y2VyKFxuXHRzdGF0ZTogU2NyZWVuW10gPSBbXSxcblx0YWN0aW9uOiBTY3JlZW5BY3Rpb25cbik6IFNjcmVlbltdIHtcblx0c3dpdGNoICggYWN0aW9uLnR5cGUgKSB7XG5cdFx0Y2FzZSAnYWRkJzpcblx0XHRcdHJldHVybiBbIC4uLnN0YXRlLCBhY3Rpb24uc2NyZWVuIF07XG5cdFx0Y2FzZSAncmVtb3ZlJzpcblx0XHRcdHJldHVybiBzdGF0ZS5maWx0ZXIoICggczogU2NyZWVuICkgPT4gcy5pZCAhPT0gYWN0aW9uLnNjcmVlbi5pZCApO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBVbmNvbm5lY3RlZE5hdmlnYXRvclByb3ZpZGVyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IE5hdmlnYXRvclByb3ZpZGVyUHJvcHMsICdkaXYnID4sXG5cdGZvcndhcmRlZFJlZjogRm9yd2FyZGVkUmVmPCBhbnkgPlxuKSB7XG5cdGNvbnN0IHsgaW5pdGlhbFBhdGgsIGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLm90aGVyUHJvcHMgfSA9XG5cdFx0dXNlQ29udGV4dFN5c3RlbSggcHJvcHMsICdOYXZpZ2F0b3JQcm92aWRlcicgKTtcblxuXHRjb25zdCBbIGxvY2F0aW9uSGlzdG9yeSwgc2V0TG9jYXRpb25IaXN0b3J5IF0gPSB1c2VTdGF0ZTxcblx0XHROYXZpZ2F0b3JMb2NhdGlvbltdXG5cdD4oIFtcblx0XHR7XG5cdFx0XHRwYXRoOiBpbml0aWFsUGF0aCxcblx0XHR9LFxuXHRdICk7XG5cdGNvbnN0IGN1cnJlbnRMb2NhdGlvbkhpc3RvcnkgPSB1c2VSZWY8IE5hdmlnYXRvckxvY2F0aW9uW10gPiggW10gKTtcblx0Y29uc3QgWyBzY3JlZW5zLCBkaXNwYXRjaCBdID0gdXNlUmVkdWNlciggc2NyZWVuc1JlZHVjZXIsIFtdICk7XG5cdGNvbnN0IGN1cnJlbnRTY3JlZW5zID0gdXNlUmVmPCBTY3JlZW5bXSA+KCBbXSApO1xuXHR1c2VFZmZlY3QoICgpID0+IHtcblx0XHRjdXJyZW50U2NyZWVucy5jdXJyZW50ID0gc2NyZWVucztcblx0fSwgWyBzY3JlZW5zIF0gKTtcblx0dXNlRWZmZWN0KCAoKSA9PiB7XG5cdFx0Y3VycmVudExvY2F0aW9uSGlzdG9yeS5jdXJyZW50ID0gbG9jYXRpb25IaXN0b3J5O1xuXHR9LCBbIGxvY2F0aW9uSGlzdG9yeSBdICk7XG5cdGNvbnN0IGN1cnJlbnRNYXRjaCA9IHVzZVJlZjwgTWF0Y2hlZFBhdGggPigpO1xuXHRjb25zdCBtYXRjaGVkUGF0aCA9IHVzZU1lbW8oICgpID0+IHtcblx0XHRsZXQgY3VycmVudFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcblx0XHRpZiAoXG5cdFx0XHRsb2NhdGlvbkhpc3RvcnkubGVuZ3RoID09PSAwIHx8XG5cdFx0XHQoIGN1cnJlbnRQYXRoID1cblx0XHRcdFx0bG9jYXRpb25IaXN0b3J5WyBsb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMSBdLnBhdGggKSA9PT1cblx0XHRcdFx0dW5kZWZpbmVkXG5cdFx0KSB7XG5cdFx0XHRjdXJyZW50TWF0Y2guY3VycmVudCA9IHVuZGVmaW5lZDtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzb2x2ZVBhdGggPSAoIHBhdGg6IHN0cmluZyApID0+IHtcblx0XHRcdGNvbnN0IG5ld01hdGNoID0gcGF0dGVybk1hdGNoKCBwYXRoLCBzY3JlZW5zICk7XG5cblx0XHRcdC8vIElmIHRoZSBuZXcgbWF0Y2ggaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgbWF0Y2gsXG5cdFx0XHQvLyByZXR1cm4gdGhlIHByZXZpb3VzIG9uZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cblx0XHRcdGlmIChcblx0XHRcdFx0Y3VycmVudE1hdGNoLmN1cnJlbnQgJiZcblx0XHRcdFx0bmV3TWF0Y2ggJiZcblx0XHRcdFx0aXNTaGFsbG93RXF1YWwoXG5cdFx0XHRcdFx0bmV3TWF0Y2gucGFyYW1zLFxuXHRcdFx0XHRcdGN1cnJlbnRNYXRjaC5jdXJyZW50LnBhcmFtc1xuXHRcdFx0XHQpICYmXG5cdFx0XHRcdG5ld01hdGNoLmlkID09PSBjdXJyZW50TWF0Y2guY3VycmVudC5pZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50TWF0Y2guY3VycmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ld01hdGNoO1xuXHRcdH07XG5cblx0XHRjb25zdCBuZXdNYXRjaCA9IHJlc29sdmVQYXRoKCBjdXJyZW50UGF0aCApO1xuXHRcdGN1cnJlbnRNYXRjaC5jdXJyZW50ID0gbmV3TWF0Y2g7XG5cdFx0cmV0dXJuIG5ld01hdGNoO1xuXHR9LCBbIHNjcmVlbnMsIGxvY2F0aW9uSGlzdG9yeSBdICk7XG5cblx0Y29uc3QgYWRkU2NyZWVuID0gdXNlQ2FsbGJhY2soXG5cdFx0KCBzY3JlZW46IFNjcmVlbiApID0+IGRpc3BhdGNoKCB7IHR5cGU6ICdhZGQnLCBzY3JlZW4gfSApLFxuXHRcdFtdXG5cdCk7XG5cblx0Y29uc3QgcmVtb3ZlU2NyZWVuID0gdXNlQ2FsbGJhY2soXG5cdFx0KCBzY3JlZW46IFNjcmVlbiApID0+IGRpc3BhdGNoKCB7IHR5cGU6ICdyZW1vdmUnLCBzY3JlZW4gfSApLFxuXHRcdFtdXG5cdCk7XG5cblx0Y29uc3QgZ29CYWNrOiBOYXZpZ2F0b3JDb250ZXh0VHlwZVsgJ2dvQmFjaycgXSA9IHVzZUNhbGxiYWNrKCAoKSA9PiB7XG5cdFx0c2V0TG9jYXRpb25IaXN0b3J5KCAoIHByZXZMb2NhdGlvbkhpc3RvcnkgKSA9PiB7XG5cdFx0XHRpZiAoIHByZXZMb2NhdGlvbkhpc3RvcnkubGVuZ3RoIDw9IDEgKSB7XG5cdFx0XHRcdHJldHVybiBwcmV2TG9jYXRpb25IaXN0b3J5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0Li4ucHJldkxvY2F0aW9uSGlzdG9yeS5zbGljZSggMCwgLTIgKSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC4uLnByZXZMb2NhdGlvbkhpc3RvcnlbIHByZXZMb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMiBdLFxuXHRcdFx0XHRcdGlzQmFjazogdHJ1ZSxcblx0XHRcdFx0XHRoYXNSZXN0b3JlZEZvY3VzOiBmYWxzZSxcblx0XHRcdFx0fSxcblx0XHRcdF07XG5cdFx0fSApO1xuXHR9LCBbXSApO1xuXG5cdGNvbnN0IGdvVG86IE5hdmlnYXRvckNvbnRleHRUeXBlWyAnZ29UbycgXSA9IHVzZUNhbGxiYWNrKFxuXHRcdCggcGF0aCwgb3B0aW9ucyA9IHt9ICkgPT4ge1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRmb2N1c1RhcmdldFNlbGVjdG9yLFxuXHRcdFx0XHRpc0JhY2sgPSBmYWxzZSxcblx0XHRcdFx0Li4ucmVzdE9wdGlvbnNcblx0XHRcdH0gPSBvcHRpb25zO1xuXG5cdFx0XHRjb25zdCBpc05hdmlnYXRpbmdUb1ByZXZpb3VzUGF0aCA9XG5cdFx0XHRcdGlzQmFjayAmJlxuXHRcdFx0XHRjdXJyZW50TG9jYXRpb25IaXN0b3J5LmN1cnJlbnQubGVuZ3RoID4gMSAmJlxuXHRcdFx0XHRjdXJyZW50TG9jYXRpb25IaXN0b3J5LmN1cnJlbnRbXG5cdFx0XHRcdFx0Y3VycmVudExvY2F0aW9uSGlzdG9yeS5jdXJyZW50Lmxlbmd0aCAtIDJcblx0XHRcdFx0XS5wYXRoID09PSBwYXRoO1xuXG5cdFx0XHRpZiAoIGlzTmF2aWdhdGluZ1RvUHJldmlvdXNQYXRoICkge1xuXHRcdFx0XHRnb0JhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRMb2NhdGlvbkhpc3RvcnkoICggcHJldkxvY2F0aW9uSGlzdG9yeSApID0+IHtcblx0XHRcdFx0Y29uc3QgbmV3TG9jYXRpb24gPSB7XG5cdFx0XHRcdFx0Li4ucmVzdE9wdGlvbnMsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHRpc0JhY2ssXG5cdFx0XHRcdFx0aGFzUmVzdG9yZWRGb2N1czogZmFsc2UsXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKCBwcmV2TG9jYXRpb25IaXN0b3J5Lmxlbmd0aCA8IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFsgbmV3TG9jYXRpb24gXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0Li4ucHJldkxvY2F0aW9uSGlzdG9yeS5zbGljZShcblx0XHRcdFx0XHRcdHByZXZMb2NhdGlvbkhpc3RvcnkubGVuZ3RoID4gTUFYX0hJU1RPUllfTEVOR1RIIC0gMVxuXHRcdFx0XHRcdFx0XHQ/IDFcblx0XHRcdFx0XHRcdFx0OiAwLFxuXHRcdFx0XHRcdFx0LTFcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdC8vIEFzc2lnbiBgZm9jdXNUYXJnZXRTZWxlY3RvcmAgdG8gdGhlIHByZXZpb3VzIGxvY2F0aW9uIGluIGhpc3Rvcnlcblx0XHRcdFx0XHQvLyAodGhlIG9uZSB3ZSBqdXN0IG5hdmlnYXRlZCBmcm9tKS5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQuLi5wcmV2TG9jYXRpb25IaXN0b3J5W1xuXHRcdFx0XHRcdFx0XHRwcmV2TG9jYXRpb25IaXN0b3J5Lmxlbmd0aCAtIDFcblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRmb2N1c1RhcmdldFNlbGVjdG9yLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bmV3TG9jYXRpb24sXG5cdFx0XHRcdF07XG5cdFx0XHR9ICk7XG5cdFx0fSxcblx0XHRbIGdvQmFjayBdXG5cdCk7XG5cblx0Y29uc3QgZ29Ub1BhcmVudDogTmF2aWdhdG9yQ29udGV4dFR5cGVbICdnb1RvUGFyZW50JyBdID1cblx0XHR1c2VDYWxsYmFjayggKCkgPT4ge1xuXHRcdFx0Y29uc3QgY3VycmVudFBhdGggPVxuXHRcdFx0XHRjdXJyZW50TG9jYXRpb25IaXN0b3J5LmN1cnJlbnRbXG5cdFx0XHRcdFx0Y3VycmVudExvY2F0aW9uSGlzdG9yeS5jdXJyZW50Lmxlbmd0aCAtIDFcblx0XHRcdFx0XS5wYXRoO1xuXHRcdFx0aWYgKCBjdXJyZW50UGF0aCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBwYXJlbnRQYXRoID0gZmluZFBhcmVudChcblx0XHRcdFx0Y3VycmVudFBhdGgsXG5cdFx0XHRcdGN1cnJlbnRTY3JlZW5zLmN1cnJlbnRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBhcmVudFBhdGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Z29UbyggcGFyZW50UGF0aCwgeyBpc0JhY2s6IHRydWUgfSApO1xuXHRcdH0sIFsgZ29UbyBdICk7XG5cblx0Y29uc3QgbmF2aWdhdG9yQ29udGV4dFZhbHVlOiBOYXZpZ2F0b3JDb250ZXh0VHlwZSA9IHVzZU1lbW8oXG5cdFx0KCkgPT4gKCB7XG5cdFx0XHRsb2NhdGlvbjoge1xuXHRcdFx0XHQuLi5sb2NhdGlvbkhpc3RvcnlbIGxvY2F0aW9uSGlzdG9yeS5sZW5ndGggLSAxIF0sXG5cdFx0XHRcdGlzSW5pdGlhbDogbG9jYXRpb25IaXN0b3J5Lmxlbmd0aCA9PT0gMSxcblx0XHRcdH0sXG5cdFx0XHRwYXJhbXM6IG1hdGNoZWRQYXRoID8gbWF0Y2hlZFBhdGgucGFyYW1zIDoge30sXG5cdFx0XHRtYXRjaDogbWF0Y2hlZFBhdGggPyBtYXRjaGVkUGF0aC5pZCA6IHVuZGVmaW5lZCxcblx0XHRcdGdvVG8sXG5cdFx0XHRnb0JhY2ssXG5cdFx0XHRnb1RvUGFyZW50LFxuXHRcdFx0YWRkU2NyZWVuLFxuXHRcdFx0cmVtb3ZlU2NyZWVuLFxuXHRcdH0gKSxcblx0XHRbXG5cdFx0XHRsb2NhdGlvbkhpc3RvcnksXG5cdFx0XHRtYXRjaGVkUGF0aCxcblx0XHRcdGdvVG8sXG5cdFx0XHRnb0JhY2ssXG5cdFx0XHRnb1RvUGFyZW50LFxuXHRcdFx0YWRkU2NyZWVuLFxuXHRcdFx0cmVtb3ZlU2NyZWVuLFxuXHRcdF1cblx0KTtcblxuXHRjb25zdCBjeCA9IHVzZUN4KCk7XG5cdGNvbnN0IGNsYXNzZXMgPSB1c2VNZW1vKFxuXHRcdC8vIFByZXZlbnRzIGhvcml6b250YWwgb3ZlcmZsb3cgd2hpbGUgYW5pbWF0aW5nIHNjcmVlbiB0cmFuc2l0aW9ucy5cblx0XHQoKSA9PiBjeCggY3NzKCB7IG92ZXJmbG93WDogJ2hpZGRlbicgfSApLCBjbGFzc05hbWUgKSxcblx0XHRbIGNsYXNzTmFtZSwgY3ggXVxuXHQpO1xuXG5cdHJldHVybiAoXG5cdFx0PFZpZXcgcmVmPXsgZm9yd2FyZGVkUmVmIH0gY2xhc3NOYW1lPXsgY2xhc3NlcyB9IHsgLi4ub3RoZXJQcm9wcyB9PlxuXHRcdFx0PE5hdmlnYXRvckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9eyBuYXZpZ2F0b3JDb250ZXh0VmFsdWUgfT5cblx0XHRcdFx0eyBjaGlsZHJlbiB9XG5cdFx0XHQ8L05hdmlnYXRvckNvbnRleHQuUHJvdmlkZXI+XG5cdFx0PC9WaWV3PlxuXHQpO1xufVxuXG4vKipcbiAqIFRoZSBgTmF2aWdhdG9yUHJvdmlkZXJgIGNvbXBvbmVudCBhbGxvd3MgcmVuZGVyaW5nIG5lc3RlZCB2aWV3cy9wYW5lbHMvbWVudXNcbiAqICh2aWEgdGhlIGBOYXZpZ2F0b3JTY3JlZW5gIGNvbXBvbmVudCBhbmQgbmF2aWdhdGUgYmV0d2VlbiB0aGVzZSBkaWZmZXJlbnRcbiAqIHZpZXcgKHZpYSB0aGUgYE5hdmlnYXRvckJ1dHRvbmAgYW5kIGBOYXZpZ2F0b3JCYWNrQnV0dG9uYCBjb21wb25lbnRzIG9yIHRoZVxuICogYHVzZU5hdmlnYXRvcmAgaG9vaykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHtcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JQcm92aWRlciBhcyBOYXZpZ2F0b3JQcm92aWRlcixcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JTY3JlZW4gYXMgTmF2aWdhdG9yU2NyZWVuLFxuICogICBfX2V4cGVyaW1lbnRhbE5hdmlnYXRvckJ1dHRvbiBhcyBOYXZpZ2F0b3JCdXR0b24sXG4gKiAgIF9fZXhwZXJpbWVudGFsTmF2aWdhdG9yQmFja0J1dHRvbiBhcyBOYXZpZ2F0b3JCYWNrQnV0dG9uLFxuICogfSBmcm9tICdAd29yZHByZXNzL2NvbXBvbmVudHMnO1xuICpcbiAqIGNvbnN0IE15TmF2aWdhdGlvbiA9ICgpID0+IChcbiAqICAgPE5hdmlnYXRvclByb3ZpZGVyIGluaXRpYWxQYXRoPVwiL1wiPlxuICogICAgIDxOYXZpZ2F0b3JTY3JlZW4gcGF0aD1cIi9cIj5cbiAqICAgICAgIDxwPlRoaXMgaXMgdGhlIGhvbWUgc2NyZWVuLjwvcD5cbiAqICAgICAgICA8TmF2aWdhdG9yQnV0dG9uIHBhdGg9XCIvY2hpbGRcIj5cbiAqICAgICAgICAgIE5hdmlnYXRlIHRvIGNoaWxkIHNjcmVlbi5cbiAqICAgICAgIDwvTmF2aWdhdG9yQnV0dG9uPlxuICogICAgIDwvTmF2aWdhdG9yU2NyZWVuPlxuICpcbiAqICAgICA8TmF2aWdhdG9yU2NyZWVuIHBhdGg9XCIvY2hpbGRcIj5cbiAqICAgICAgIDxwPlRoaXMgaXMgdGhlIGNoaWxkIHNjcmVlbi48L3A+XG4gKiAgICAgICA8TmF2aWdhdG9yQmFja0J1dHRvbj5cbiAqICAgICAgICAgR28gYmFja1xuICogICAgICAgPC9OYXZpZ2F0b3JCYWNrQnV0dG9uPlxuICogICAgIDwvTmF2aWdhdG9yU2NyZWVuPlxuICogICA8L05hdmlnYXRvclByb3ZpZGVyPlxuICogKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgTmF2aWdhdG9yUHJvdmlkZXIgPSBjb250ZXh0Q29ubmVjdChcblx0VW5jb25uZWN0ZWROYXZpZ2F0b3JQcm92aWRlcixcblx0J05hdmlnYXRvclByb3ZpZGVyJ1xuKTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdG9yUHJvdmlkZXI7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};

function UnconnectedNavigatorProvider(props, forwardedRef) {
  const {
    initialPath,
    children,
    className,
    ...otherProps
  } = (0, _context.useContextSystem)(props, 'NavigatorProvider');
  const [locationHistory, setLocationHistory] = (0, _element.useState)([{
    path: initialPath
  }]);
  const currentLocationHistory = (0, _element.useRef)([]);
  const [screens, dispatch] = (0, _element.useReducer)(screensReducer, []);
  const currentScreens = (0, _element.useRef)([]);
  (0, _element.useEffect)(() => {
    currentScreens.current = screens;
  }, [screens]);
  (0, _element.useEffect)(() => {
    currentLocationHistory.current = locationHistory;
  }, [locationHistory]);
  const currentMatch = (0, _element.useRef)();
  const matchedPath = (0, _element.useMemo)(() => {
    let currentPath;

    if (locationHistory.length === 0 || (currentPath = locationHistory[locationHistory.length - 1].path) === undefined) {
      currentMatch.current = undefined;
      return undefined;
    }

    const resolvePath = path => {
      const newMatch = (0, _router.patternMatch)(path, screens); // If the new match is the same as the current match,
      // return the previous one for performance reasons.

      if (currentMatch.current && newMatch && (0, _isShallowEqual.default)(newMatch.params, currentMatch.current.params) && newMatch.id === currentMatch.current.id) {
        return currentMatch.current;
      }

      return newMatch;
    };

    const newMatch = resolvePath(currentPath);
    currentMatch.current = newMatch;
    return newMatch;
  }, [screens, locationHistory]);
  const addScreen = (0, _element.useCallback)(screen => dispatch({
    type: 'add',
    screen
  }), []);
  const removeScreen = (0, _element.useCallback)(screen => dispatch({
    type: 'remove',
    screen
  }), []);
  const goBack = (0, _element.useCallback)(() => {
    setLocationHistory(prevLocationHistory => {
      if (prevLocationHistory.length <= 1) {
        return prevLocationHistory;
      }

      return [...prevLocationHistory.slice(0, -2), { ...prevLocationHistory[prevLocationHistory.length - 2],
        isBack: true,
        hasRestoredFocus: false
      }];
    });
  }, []);
  const goTo = (0, _element.useCallback)(function (path) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      focusTargetSelector,
      isBack = false,
      ...restOptions
    } = options;
    const isNavigatingToPreviousPath = isBack && currentLocationHistory.current.length > 1 && currentLocationHistory.current[currentLocationHistory.current.length - 2].path === path;

    if (isNavigatingToPreviousPath) {
      goBack();
      return;
    }

    setLocationHistory(prevLocationHistory => {
      const newLocation = { ...restOptions,
        path,
        isBack,
        hasRestoredFocus: false
      };

      if (prevLocationHistory.length < 1) {
        return [newLocation];
      }

      return [...prevLocationHistory.slice(prevLocationHistory.length > MAX_HISTORY_LENGTH - 1 ? 1 : 0, -1), // Assign `focusTargetSelector` to the previous location in history
      // (the one we just navigated from).
      { ...prevLocationHistory[prevLocationHistory.length - 1],
        focusTargetSelector
      }, newLocation];
    });
  }, [goBack]);
  const goToParent = (0, _element.useCallback)(() => {
    const currentPath = currentLocationHistory.current[currentLocationHistory.current.length - 1].path;

    if (currentPath === undefined) {
      return;
    }

    const parentPath = (0, _router.findParent)(currentPath, currentScreens.current);

    if (parentPath === undefined) {
      return;
    }

    goTo(parentPath, {
      isBack: true
    });
  }, [goTo]);
  const navigatorContextValue = (0, _element.useMemo)(() => ({
    location: { ...locationHistory[locationHistory.length - 1],
      isInitial: locationHistory.length === 1
    },
    params: matchedPath ? matchedPath.params : {},
    match: matchedPath ? matchedPath.id : undefined,
    goTo,
    goBack,
    goToParent,
    addScreen,
    removeScreen
  }), [locationHistory, matchedPath, goTo, goBack, goToParent, addScreen, removeScreen]);
  const cx = (0, _useCx.useCx)();
  const classes = (0, _element.useMemo)( // Prevents horizontal overflow while animating screen transitions.
  () => cx(_ref, className), [className, cx]);
  return (0, _element.createElement)(_view.View, (0, _extends2.default)({
    ref: forwardedRef,
    className: classes
  }, otherProps), (0, _element.createElement)(_context2.NavigatorContext.Provider, {
    value: navigatorContextValue
  }, children));
}
/**
 * The `NavigatorProvider` component allows rendering nested views/panels/menus
 * (via the `NavigatorScreen` component and navigate between these different
 * view (via the `NavigatorButton` and `NavigatorBackButton` components or the
 * `useNavigator` hook).
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */


const NavigatorProvider = (0, _context.contextConnect)(UnconnectedNavigatorProvider, 'NavigatorProvider');
exports.NavigatorProvider = NavigatorProvider;
var _default = NavigatorProvider;
exports.default = _default;
//# sourceMappingURL=component.js.map