"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSupportedStyles = void 0;

var _rememo = _interopRequireDefault(require("rememo"));

var _lodash = require("lodash");

var _selectors = require("./selectors");

var _constants = require("../api/constants");

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */
const ROOT_BLOCK_SUPPORTS = ['background', 'backgroundColor', 'color', 'linkColor', 'buttonColor', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'lineHeight', 'padding', 'contentSize', 'wideSize', 'blockGap', 'textDecoration', 'textTransform', 'letterSpacing'];
/**
 * Filters the list of supported styles for a given element.
 *
 * @param {string[]}         blockSupports list of supported styles.
 * @param {string|undefined} name          block name.
 * @param {string|undefined} element       element name.
 *
 * @return {string[]} filtered list of supported styles.
 */

function filterElementBlockSupports(blockSupports, name, element) {
  return blockSupports.filter(support => {
    if (support === 'fontSize' && element === 'heading') {
      return false;
    } // This is only available for links


    if (support === 'textDecoration' && !name && element !== 'link') {
      return false;
    } // This is only available for heading


    if (support === 'textTransform' && !name && !['heading', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(element)) {
      return false;
    } // This is only available for headings


    if (support === 'letterSpacing' && !name && !['heading', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(element)) {
      return false;
    }

    return true;
  });
}
/**
 * Returns the list of supported styles for a given block name and element.
 */


const getSupportedStyles = (0, _rememo.default)((state, name, element) => {
  var _blockType$supports, _blockType$supports$s, _blockType$supports2, _blockType$supports2$, _blockType$supports3, _blockType$supports3$, _blockType$supports3$2, _blockType$supports3$3, _blockType$supports4;

  if (!name) {
    return filterElementBlockSupports(ROOT_BLOCK_SUPPORTS, name, element);
  }

  const blockType = (0, _selectors.getBlockType)(state, name);

  if (!blockType) {
    return [];
  }

  const supportKeys = []; // Check for blockGap support.
  // Block spacing support doesn't map directly to a single style property, so needs to be handled separately.
  // Also, only allow `blockGap` support if serialization has not been skipped, to be sure global spacing can be applied.

  if (blockType !== null && blockType !== void 0 && (_blockType$supports = blockType.supports) !== null && _blockType$supports !== void 0 && (_blockType$supports$s = _blockType$supports.spacing) !== null && _blockType$supports$s !== void 0 && _blockType$supports$s.blockGap && (blockType === null || blockType === void 0 ? void 0 : (_blockType$supports2 = blockType.supports) === null || _blockType$supports2 === void 0 ? void 0 : (_blockType$supports2$ = _blockType$supports2.spacing) === null || _blockType$supports2$ === void 0 ? void 0 : _blockType$supports2$.__experimentalSkipSerialization) !== true && !(blockType !== null && blockType !== void 0 && (_blockType$supports3 = blockType.supports) !== null && _blockType$supports3 !== void 0 && (_blockType$supports3$ = _blockType$supports3.spacing) !== null && _blockType$supports3$ !== void 0 && (_blockType$supports3$2 = _blockType$supports3$.__experimentalSkipSerialization) !== null && _blockType$supports3$2 !== void 0 && (_blockType$supports3$3 = _blockType$supports3$2.some) !== null && _blockType$supports3$3 !== void 0 && _blockType$supports3$3.call(_blockType$supports3$2, spacingType => spacingType === 'blockGap'))) {
    supportKeys.push('blockGap');
  } // check for shadow support


  if (blockType !== null && blockType !== void 0 && (_blockType$supports4 = blockType.supports) !== null && _blockType$supports4 !== void 0 && _blockType$supports4.shadow) {
    supportKeys.push('shadow');
  }

  Object.keys(_constants.__EXPERIMENTAL_STYLE_PROPERTY).forEach(styleName => {
    if (!_constants.__EXPERIMENTAL_STYLE_PROPERTY[styleName].support) {
      return;
    } // Opting out means that, for certain support keys like background color,
    // blocks have to explicitly set the support value false. If the key is
    // unset, we still enable it.


    if (_constants.__EXPERIMENTAL_STYLE_PROPERTY[styleName].requiresOptOut) {
      if (_constants.__EXPERIMENTAL_STYLE_PROPERTY[styleName].support[0] in blockType.supports && (0, _lodash.get)(blockType.supports, _constants.__EXPERIMENTAL_STYLE_PROPERTY[styleName].support) !== false) {
        supportKeys.push(styleName);
        return;
      }
    }

    if ((0, _lodash.get)(blockType.supports, _constants.__EXPERIMENTAL_STYLE_PROPERTY[styleName].support, false)) {
      supportKeys.push(styleName);
    }
  });
  return filterElementBlockSupports(supportKeys, name, element);
}, (state, name) => [state.blockTypes[name]]);
exports.getSupportedStyles = getSupportedStyles;
//# sourceMappingURL=private-selectors.js.map