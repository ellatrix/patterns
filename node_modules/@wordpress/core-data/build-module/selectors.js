/**
 * External dependencies
 */
import createSelector from 'rememo';
import { set } from 'lodash';
/**
 * WordPress dependencies
 */

import { createRegistrySelector } from '@wordpress/data';
import { addQueryArgs } from '@wordpress/url';
import deprecated from '@wordpress/deprecated';
/**
 * Internal dependencies
 */

import { STORE_NAME } from './name';
import { getQueriedItems } from './queried-data';
import { DEFAULT_ENTITY_KEY } from './entities';
import { getNormalizedCommaSeparable, isRawAttribute } from './utils';

/**
 * Shared reference to an empty object for cases where it is important to avoid
 * returning a new object reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 */
const EMPTY_OBJECT = {};
/**
 * Returns true if a request is in progress for embed preview data, or false
 * otherwise.
 *
 * @param state Data state.
 * @param url   URL the preview would be for.
 *
 * @return Whether a request is in progress for an embed preview.
 */

export const isRequestingEmbedPreview = createRegistrySelector(select => (state, url) => {
  return select(STORE_NAME).isResolving('getEmbedPreview', [url]);
});
/**
 * Returns all available authors.
 *
 * @deprecated since 11.3. Callers should use `select( 'core' ).getUsers({ who: 'authors' })` instead.
 *
 * @param      state Data state.
 * @param      query Optional object of query parameters to
 *                   include with request.
 * @return Authors list.
 */

export function getAuthors(state, query) {
  deprecated("select( 'core' ).getAuthors()", {
    since: '5.9',
    alternative: "select( 'core' ).getUsers({ who: 'authors' })"
  });
  const path = addQueryArgs('/wp/v2/users/?who=authors&per_page=100', query);
  return getUserQueryResults(state, path);
}
/**
 * Returns the current user.
 *
 * @param state Data state.
 *
 * @return Current user object.
 */

export function getCurrentUser(state) {
  return state.currentUser;
}
/**
 * Returns all the users returned by a query ID.
 *
 * @param state   Data state.
 * @param queryID Query ID.
 *
 * @return Users list.
 */

export const getUserQueryResults = createSelector((state, queryID) => {
  var _state$users$queries$;

  const queryResults = (_state$users$queries$ = state.users.queries[queryID]) !== null && _state$users$queries$ !== void 0 ? _state$users$queries$ : [];
  return queryResults.map(id => state.users.byId[id]);
}, (state, queryID) => [state.users.queries[queryID], state.users.byId]);
/**
 * Returns the loaded entities for the given kind.
 *
 * @deprecated since WordPress 6.0. Use getEntitiesConfig instead
 * @param      state Data state.
 * @param      kind  Entity kind.
 *
 * @return Array of entities with config matching kind.
 */

export function getEntitiesByKind(state, kind) {
  deprecated("wp.data.select( 'core' ).getEntitiesByKind()", {
    since: '6.0',
    alternative: "wp.data.select( 'core' ).getEntitiesConfig()"
  });
  return getEntitiesConfig(state, kind);
}
/**
 * Returns the loaded entities for the given kind.
 *
 * @param state Data state.
 * @param kind  Entity kind.
 *
 * @return Array of entities with config matching kind.
 */

export function getEntitiesConfig(state, kind) {
  return state.entities.config.filter(entity => entity.kind === kind);
}
/**
 * Returns the entity config given its kind and name.
 *
 * @deprecated since WordPress 6.0. Use getEntityConfig instead
 * @param      state Data state.
 * @param      kind  Entity kind.
 * @param      name  Entity name.
 *
 * @return Entity config
 */

export function getEntity(state, kind, name) {
  deprecated("wp.data.select( 'core' ).getEntity()", {
    since: '6.0',
    alternative: "wp.data.select( 'core' ).getEntityConfig()"
  });
  return getEntityConfig(state, kind, name);
}
/**
 * Returns the entity config given its kind and name.
 *
 * @param state Data state.
 * @param kind  Entity kind.
 * @param name  Entity name.
 *
 * @return Entity config
 */

export function getEntityConfig(state, kind, name) {
  var _state$entities$confi;

  return (_state$entities$confi = state.entities.config) === null || _state$entities$confi === void 0 ? void 0 : _state$entities$confi.find(config => config.kind === kind && config.name === name);
}
/**
 * GetEntityRecord is declared as a *callable interface* with
 * two signatures to work around the fact that TypeScript doesn't
 * allow currying generic functions:
 *
 * ```ts
 * 		type CurriedState = F extends ( state: any, ...args: infer P ) => infer R
 * 			? ( ...args: P ) => R
 * 			: F;
 * 		type Selector = <K extends string | number>(
 *         state: any,
 *         kind: K,
 *         key: K extends string ? 'string value' : false
 *    ) => K;
 * 		type BadlyInferredSignature = CurriedState< Selector >
 *    // BadlyInferredSignature evaluates to:
 *    // (kind: string number, key: false | "string value") => string number
 * ```
 *
 * The signature without the state parameter shipped as CurriedSignature
 * is used in the return value of `select( coreStore )`.
 *
 * See https://github.com/WordPress/gutenberg/pull/41578 for more details.
 */

/**
 * Returns the Entity's record object by key. Returns `null` if the value is not
 * yet received, undefined if the value entity is known to not exist, or the
 * entity object if it exists and is received.
 *
 * @param state State tree
 * @param kind  Entity kind.
 * @param name  Entity name.
 * @param key   Record's key
 * @param query Optional query. If requesting specific
 *              fields, fields must always include the ID.
 *
 * @return Record.
 */
export const getEntityRecord = createSelector((state, kind, name, key, query) => {
  var _state$entities$recor, _state$entities$recor2, _state$entities$recor3, _query$context, _queriedState$items$c;

  const queriedState = (_state$entities$recor = state.entities.records) === null || _state$entities$recor === void 0 ? void 0 : (_state$entities$recor2 = _state$entities$recor[kind]) === null || _state$entities$recor2 === void 0 ? void 0 : (_state$entities$recor3 = _state$entities$recor2[name]) === null || _state$entities$recor3 === void 0 ? void 0 : _state$entities$recor3.queriedData;

  if (!queriedState) {
    return undefined;
  }

  const context = (_query$context = query === null || query === void 0 ? void 0 : query.context) !== null && _query$context !== void 0 ? _query$context : 'default';

  if (query === undefined) {
    var _queriedState$itemIsC;

    // If expecting a complete item, validate that completeness.
    if (!((_queriedState$itemIsC = queriedState.itemIsComplete[context]) !== null && _queriedState$itemIsC !== void 0 && _queriedState$itemIsC[key])) {
      return undefined;
    }

    return queriedState.items[context][key];
  }

  const item = (_queriedState$items$c = queriedState.items[context]) === null || _queriedState$items$c === void 0 ? void 0 : _queriedState$items$c[key];

  if (item && query._fields) {
    var _getNormalizedCommaSe;

    const filteredItem = {};
    const fields = (_getNormalizedCommaSe = getNormalizedCommaSeparable(query._fields)) !== null && _getNormalizedCommaSe !== void 0 ? _getNormalizedCommaSe : [];

    for (let f = 0; f < fields.length; f++) {
      const field = fields[f].split('.');
      let value = item;
      field.forEach(fieldName => {
        value = value[fieldName];
      });
      set(filteredItem, field, value);
    }

    return filteredItem;
  }

  return item;
}, (state, kind, name, recordId, query) => {
  var _query$context2, _state$entities$recor4, _state$entities$recor5, _state$entities$recor6, _state$entities$recor7, _state$entities$recor8, _state$entities$recor9, _state$entities$recor10, _state$entities$recor11, _state$entities$recor12, _state$entities$recor13;

  const context = (_query$context2 = query === null || query === void 0 ? void 0 : query.context) !== null && _query$context2 !== void 0 ? _query$context2 : 'default';
  return [(_state$entities$recor4 = state.entities.records) === null || _state$entities$recor4 === void 0 ? void 0 : (_state$entities$recor5 = _state$entities$recor4[kind]) === null || _state$entities$recor5 === void 0 ? void 0 : (_state$entities$recor6 = _state$entities$recor5[name]) === null || _state$entities$recor6 === void 0 ? void 0 : (_state$entities$recor7 = _state$entities$recor6.queriedData) === null || _state$entities$recor7 === void 0 ? void 0 : (_state$entities$recor8 = _state$entities$recor7.items[context]) === null || _state$entities$recor8 === void 0 ? void 0 : _state$entities$recor8[recordId], (_state$entities$recor9 = state.entities.records) === null || _state$entities$recor9 === void 0 ? void 0 : (_state$entities$recor10 = _state$entities$recor9[kind]) === null || _state$entities$recor10 === void 0 ? void 0 : (_state$entities$recor11 = _state$entities$recor10[name]) === null || _state$entities$recor11 === void 0 ? void 0 : (_state$entities$recor12 = _state$entities$recor11.queriedData) === null || _state$entities$recor12 === void 0 ? void 0 : (_state$entities$recor13 = _state$entities$recor12.itemIsComplete[context]) === null || _state$entities$recor13 === void 0 ? void 0 : _state$entities$recor13[recordId]];
});
/**
 * Returns the Entity's record object by key. Doesn't trigger a resolver nor requests the entity records from the API if the entity record isn't available in the local state.
 *
 * @param state State tree
 * @param kind  Entity kind.
 * @param name  Entity name.
 * @param key   Record's key
 *
 * @return Record.
 */

export function __experimentalGetEntityRecordNoResolver(state, kind, name, key) {
  return getEntityRecord(state, kind, name, key);
}
/**
 * Returns the entity's record object by key,
 * with its attributes mapped to their raw values.
 *
 * @param state State tree.
 * @param kind  Entity kind.
 * @param name  Entity name.
 * @param key   Record's key.
 *
 * @return Object with the entity's raw attributes.
 */

export const getRawEntityRecord = createSelector((state, kind, name, key) => {
  const record = getEntityRecord(state, kind, name, key);
  return record && Object.keys(record).reduce((accumulator, _key) => {
    if (isRawAttribute(getEntityConfig(state, kind, name), _key)) {
      var _record$_key$raw, _record$_key;

      // Because edits are the "raw" attribute values,
      // we return those from record selectors to make rendering,
      // comparisons, and joins with edits easier.
      accumulator[_key] = (_record$_key$raw = (_record$_key = record[_key]) === null || _record$_key === void 0 ? void 0 : _record$_key.raw) !== null && _record$_key$raw !== void 0 ? _record$_key$raw : record[_key];
    } else {
      accumulator[_key] = record[_key];
    }

    return accumulator;
  }, {});
}, (state, kind, name, recordId, query) => {
  var _query$context3, _state$entities$recor14, _state$entities$recor15, _state$entities$recor16, _state$entities$recor17, _state$entities$recor18, _state$entities$recor19, _state$entities$recor20, _state$entities$recor21, _state$entities$recor22, _state$entities$recor23;

  const context = (_query$context3 = query === null || query === void 0 ? void 0 : query.context) !== null && _query$context3 !== void 0 ? _query$context3 : 'default';
  return [state.entities.config, (_state$entities$recor14 = state.entities.records) === null || _state$entities$recor14 === void 0 ? void 0 : (_state$entities$recor15 = _state$entities$recor14[kind]) === null || _state$entities$recor15 === void 0 ? void 0 : (_state$entities$recor16 = _state$entities$recor15[name]) === null || _state$entities$recor16 === void 0 ? void 0 : (_state$entities$recor17 = _state$entities$recor16.queriedData) === null || _state$entities$recor17 === void 0 ? void 0 : (_state$entities$recor18 = _state$entities$recor17.items[context]) === null || _state$entities$recor18 === void 0 ? void 0 : _state$entities$recor18[recordId], (_state$entities$recor19 = state.entities.records) === null || _state$entities$recor19 === void 0 ? void 0 : (_state$entities$recor20 = _state$entities$recor19[kind]) === null || _state$entities$recor20 === void 0 ? void 0 : (_state$entities$recor21 = _state$entities$recor20[name]) === null || _state$entities$recor21 === void 0 ? void 0 : (_state$entities$recor22 = _state$entities$recor21.queriedData) === null || _state$entities$recor22 === void 0 ? void 0 : (_state$entities$recor23 = _state$entities$recor22.itemIsComplete[context]) === null || _state$entities$recor23 === void 0 ? void 0 : _state$entities$recor23[recordId]];
});
/**
 * Returns true if records have been received for the given set of parameters,
 * or false otherwise.
 *
 * @param state State tree
 * @param kind  Entity kind.
 * @param name  Entity name.
 * @param query Optional terms query.
 *
 * @return  Whether entity records have been received.
 */

export function hasEntityRecords(state, kind, name, query) {
  return Array.isArray(getEntityRecords(state, kind, name, query));
}
/**
 * GetEntityRecord is declared as a *callable interface* with
 * two signatures to work around the fact that TypeScript doesn't
 * allow currying generic functions.
 *
 * @see GetEntityRecord
 * @see https://github.com/WordPress/gutenberg/pull/41578
 */

/**
 * Returns the Entity's records.
 *
 * @param state State tree
 * @param kind  Entity kind.
 * @param name  Entity name.
 * @param query Optional terms query. If requesting specific
 *              fields, fields must always include the ID.
 *
 * @return Records.
 */
export const getEntityRecords = (state, kind, name, query) => {
  var _state$entities$recor24, _state$entities$recor25, _state$entities$recor26;

  // Queried data state is prepopulated for all known entities. If this is not
  // assigned for the given parameters, then it is known to not exist.
  const queriedState = (_state$entities$recor24 = state.entities.records) === null || _state$entities$recor24 === void 0 ? void 0 : (_state$entities$recor25 = _state$entities$recor24[kind]) === null || _state$entities$recor25 === void 0 ? void 0 : (_state$entities$recor26 = _state$entities$recor25[name]) === null || _state$entities$recor26 === void 0 ? void 0 : _state$entities$recor26.queriedData;

  if (!queriedState) {
    return null;
  }

  return getQueriedItems(queriedState, query);
};

/**
 * Returns the list of dirty entity records.
 *
 * @param state State tree.
 *
 * @return The list of updated records
 */
export const __experimentalGetDirtyEntityRecords = createSelector(state => {
  const {
    entities: {
      records
    }
  } = state;
  const dirtyRecords = [];
  Object.keys(records).forEach(kind => {
    Object.keys(records[kind]).forEach(name => {
      const primaryKeys = Object.keys(records[kind][name].edits).filter(primaryKey => // The entity record must exist (not be deleted),
      // and it must have edits.
      getEntityRecord(state, kind, name, primaryKey) && hasEditsForEntityRecord(state, kind, name, primaryKey));

      if (primaryKeys.length) {
        const entityConfig = getEntityConfig(state, kind, name);
        primaryKeys.forEach(primaryKey => {
          var _entityConfig$getTitl;

          const entityRecord = getEditedEntityRecord(state, kind, name, primaryKey);
          dirtyRecords.push({
            // We avoid using primaryKey because it's transformed into a string
            // when it's used as an object key.
            key: entityRecord ? entityRecord[entityConfig.key || DEFAULT_ENTITY_KEY] : undefined,
            title: (entityConfig === null || entityConfig === void 0 ? void 0 : (_entityConfig$getTitl = entityConfig.getTitle) === null || _entityConfig$getTitl === void 0 ? void 0 : _entityConfig$getTitl.call(entityConfig, entityRecord)) || '',
            name,
            kind
          });
        });
      }
    });
  });
  return dirtyRecords;
}, state => [state.entities.records]);
/**
 * Returns the list of entities currently being saved.
 *
 * @param state State tree.
 *
 * @return The list of records being saved.
 */

export const __experimentalGetEntitiesBeingSaved = createSelector(state => {
  const {
    entities: {
      records
    }
  } = state;
  const recordsBeingSaved = [];
  Object.keys(records).forEach(kind => {
    Object.keys(records[kind]).forEach(name => {
      const primaryKeys = Object.keys(records[kind][name].saving).filter(primaryKey => isSavingEntityRecord(state, kind, name, primaryKey));

      if (primaryKeys.length) {
        const entityConfig = getEntityConfig(state, kind, name);
        primaryKeys.forEach(primaryKey => {
          var _entityConfig$getTitl2;

          const entityRecord = getEditedEntityRecord(state, kind, name, primaryKey);
          recordsBeingSaved.push({
            // We avoid using primaryKey because it's transformed into a string
            // when it's used as an object key.
            key: entityRecord ? entityRecord[entityConfig.key || DEFAULT_ENTITY_KEY] : undefined,
            title: (entityConfig === null || entityConfig === void 0 ? void 0 : (_entityConfig$getTitl2 = entityConfig.getTitle) === null || _entityConfig$getTitl2 === void 0 ? void 0 : _entityConfig$getTitl2.call(entityConfig, entityRecord)) || '',
            name,
            kind
          });
        });
      }
    });
  });
  return recordsBeingSaved;
}, state => [state.entities.records]);
/**
 * Returns the specified entity record's edits.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return The entity record's edits.
 */

export function getEntityRecordEdits(state, kind, name, recordId) {
  var _state$entities$recor27, _state$entities$recor28, _state$entities$recor29, _state$entities$recor30;

  return (_state$entities$recor27 = state.entities.records) === null || _state$entities$recor27 === void 0 ? void 0 : (_state$entities$recor28 = _state$entities$recor27[kind]) === null || _state$entities$recor28 === void 0 ? void 0 : (_state$entities$recor29 = _state$entities$recor28[name]) === null || _state$entities$recor29 === void 0 ? void 0 : (_state$entities$recor30 = _state$entities$recor29.edits) === null || _state$entities$recor30 === void 0 ? void 0 : _state$entities$recor30[recordId];
}
/**
 * Returns the specified entity record's non transient edits.
 *
 * Transient edits don't create an undo level, and
 * are not considered for change detection.
 * They are defined in the entity's config.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return The entity record's non transient edits.
 */

export const getEntityRecordNonTransientEdits = createSelector((state, kind, name, recordId) => {
  const {
    transientEdits
  } = getEntityConfig(state, kind, name) || {};
  const edits = getEntityRecordEdits(state, kind, name, recordId) || {};

  if (!transientEdits) {
    return edits;
  }

  return Object.keys(edits).reduce((acc, key) => {
    if (!transientEdits[key]) {
      acc[key] = edits[key];
    }

    return acc;
  }, {});
}, (state, kind, name, recordId) => {
  var _state$entities$recor31, _state$entities$recor32, _state$entities$recor33, _state$entities$recor34;

  return [state.entities.config, (_state$entities$recor31 = state.entities.records) === null || _state$entities$recor31 === void 0 ? void 0 : (_state$entities$recor32 = _state$entities$recor31[kind]) === null || _state$entities$recor32 === void 0 ? void 0 : (_state$entities$recor33 = _state$entities$recor32[name]) === null || _state$entities$recor33 === void 0 ? void 0 : (_state$entities$recor34 = _state$entities$recor33.edits) === null || _state$entities$recor34 === void 0 ? void 0 : _state$entities$recor34[recordId]];
});
/**
 * Returns true if the specified entity record has edits,
 * and false otherwise.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return Whether the entity record has edits or not.
 */

export function hasEditsForEntityRecord(state, kind, name, recordId) {
  return isSavingEntityRecord(state, kind, name, recordId) || Object.keys(getEntityRecordNonTransientEdits(state, kind, name, recordId)).length > 0;
}
/**
 * Returns the specified entity record, merged with its edits.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return The entity record, merged with its edits.
 */

export const getEditedEntityRecord = createSelector((state, kind, name, recordId) => ({ ...getRawEntityRecord(state, kind, name, recordId),
  ...getEntityRecordEdits(state, kind, name, recordId)
}), (state, kind, name, recordId, query) => {
  var _query$context4, _state$entities$recor35, _state$entities$recor36, _state$entities$recor37, _state$entities$recor38, _state$entities$recor39, _state$entities$recor40, _state$entities$recor41, _state$entities$recor42, _state$entities$recor43, _state$entities$recor44, _state$entities$recor45, _state$entities$recor46;

  const context = (_query$context4 = query === null || query === void 0 ? void 0 : query.context) !== null && _query$context4 !== void 0 ? _query$context4 : 'default';
  return [state.entities.config, (_state$entities$recor35 = state.entities.records) === null || _state$entities$recor35 === void 0 ? void 0 : (_state$entities$recor36 = _state$entities$recor35[kind]) === null || _state$entities$recor36 === void 0 ? void 0 : (_state$entities$recor37 = _state$entities$recor36[name]) === null || _state$entities$recor37 === void 0 ? void 0 : (_state$entities$recor38 = _state$entities$recor37.queriedData.items[context]) === null || _state$entities$recor38 === void 0 ? void 0 : _state$entities$recor38[recordId], (_state$entities$recor39 = state.entities.records) === null || _state$entities$recor39 === void 0 ? void 0 : (_state$entities$recor40 = _state$entities$recor39[kind]) === null || _state$entities$recor40 === void 0 ? void 0 : (_state$entities$recor41 = _state$entities$recor40[name]) === null || _state$entities$recor41 === void 0 ? void 0 : (_state$entities$recor42 = _state$entities$recor41.queriedData.itemIsComplete[context]) === null || _state$entities$recor42 === void 0 ? void 0 : _state$entities$recor42[recordId], (_state$entities$recor43 = state.entities.records) === null || _state$entities$recor43 === void 0 ? void 0 : (_state$entities$recor44 = _state$entities$recor43[kind]) === null || _state$entities$recor44 === void 0 ? void 0 : (_state$entities$recor45 = _state$entities$recor44[name]) === null || _state$entities$recor45 === void 0 ? void 0 : (_state$entities$recor46 = _state$entities$recor45.edits) === null || _state$entities$recor46 === void 0 ? void 0 : _state$entities$recor46[recordId]];
});
/**
 * Returns true if the specified entity record is autosaving, and false otherwise.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return Whether the entity record is autosaving or not.
 */

export function isAutosavingEntityRecord(state, kind, name, recordId) {
  var _state$entities$recor47, _state$entities$recor48, _state$entities$recor49, _state$entities$recor50, _state$entities$recor51;

  const {
    pending,
    isAutosave
  } = (_state$entities$recor47 = (_state$entities$recor48 = state.entities.records) === null || _state$entities$recor48 === void 0 ? void 0 : (_state$entities$recor49 = _state$entities$recor48[kind]) === null || _state$entities$recor49 === void 0 ? void 0 : (_state$entities$recor50 = _state$entities$recor49[name]) === null || _state$entities$recor50 === void 0 ? void 0 : (_state$entities$recor51 = _state$entities$recor50.saving) === null || _state$entities$recor51 === void 0 ? void 0 : _state$entities$recor51[recordId]) !== null && _state$entities$recor47 !== void 0 ? _state$entities$recor47 : {};
  return Boolean(pending && isAutosave);
}
/**
 * Returns true if the specified entity record is saving, and false otherwise.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return Whether the entity record is saving or not.
 */

export function isSavingEntityRecord(state, kind, name, recordId) {
  var _state$entities$recor52, _state$entities$recor53, _state$entities$recor54, _state$entities$recor55, _state$entities$recor56, _state$entities$recor57;

  return (_state$entities$recor52 = (_state$entities$recor53 = state.entities.records) === null || _state$entities$recor53 === void 0 ? void 0 : (_state$entities$recor54 = _state$entities$recor53[kind]) === null || _state$entities$recor54 === void 0 ? void 0 : (_state$entities$recor55 = _state$entities$recor54[name]) === null || _state$entities$recor55 === void 0 ? void 0 : (_state$entities$recor56 = _state$entities$recor55.saving) === null || _state$entities$recor56 === void 0 ? void 0 : (_state$entities$recor57 = _state$entities$recor56[recordId]) === null || _state$entities$recor57 === void 0 ? void 0 : _state$entities$recor57.pending) !== null && _state$entities$recor52 !== void 0 ? _state$entities$recor52 : false;
}
/**
 * Returns true if the specified entity record is deleting, and false otherwise.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return Whether the entity record is deleting or not.
 */

export function isDeletingEntityRecord(state, kind, name, recordId) {
  var _state$entities$recor58, _state$entities$recor59, _state$entities$recor60, _state$entities$recor61, _state$entities$recor62, _state$entities$recor63;

  return (_state$entities$recor58 = (_state$entities$recor59 = state.entities.records) === null || _state$entities$recor59 === void 0 ? void 0 : (_state$entities$recor60 = _state$entities$recor59[kind]) === null || _state$entities$recor60 === void 0 ? void 0 : (_state$entities$recor61 = _state$entities$recor60[name]) === null || _state$entities$recor61 === void 0 ? void 0 : (_state$entities$recor62 = _state$entities$recor61.deleting) === null || _state$entities$recor62 === void 0 ? void 0 : (_state$entities$recor63 = _state$entities$recor62[recordId]) === null || _state$entities$recor63 === void 0 ? void 0 : _state$entities$recor63.pending) !== null && _state$entities$recor58 !== void 0 ? _state$entities$recor58 : false;
}
/**
 * Returns the specified entity record's last save error.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return The entity record's save error.
 */

export function getLastEntitySaveError(state, kind, name, recordId) {
  var _state$entities$recor64, _state$entities$recor65, _state$entities$recor66, _state$entities$recor67, _state$entities$recor68;

  return (_state$entities$recor64 = state.entities.records) === null || _state$entities$recor64 === void 0 ? void 0 : (_state$entities$recor65 = _state$entities$recor64[kind]) === null || _state$entities$recor65 === void 0 ? void 0 : (_state$entities$recor66 = _state$entities$recor65[name]) === null || _state$entities$recor66 === void 0 ? void 0 : (_state$entities$recor67 = _state$entities$recor66.saving) === null || _state$entities$recor67 === void 0 ? void 0 : (_state$entities$recor68 = _state$entities$recor67[recordId]) === null || _state$entities$recor68 === void 0 ? void 0 : _state$entities$recor68.error;
}
/**
 * Returns the specified entity record's last delete error.
 *
 * @param state    State tree.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record ID.
 *
 * @return The entity record's save error.
 */

export function getLastEntityDeleteError(state, kind, name, recordId) {
  var _state$entities$recor69, _state$entities$recor70, _state$entities$recor71, _state$entities$recor72, _state$entities$recor73;

  return (_state$entities$recor69 = state.entities.records) === null || _state$entities$recor69 === void 0 ? void 0 : (_state$entities$recor70 = _state$entities$recor69[kind]) === null || _state$entities$recor70 === void 0 ? void 0 : (_state$entities$recor71 = _state$entities$recor70[name]) === null || _state$entities$recor71 === void 0 ? void 0 : (_state$entities$recor72 = _state$entities$recor71.deleting) === null || _state$entities$recor72 === void 0 ? void 0 : (_state$entities$recor73 = _state$entities$recor72[recordId]) === null || _state$entities$recor73 === void 0 ? void 0 : _state$entities$recor73.error;
}
/**
 * Returns the current undo offset for the
 * entity records edits history. The offset
 * represents how many items from the end
 * of the history stack we are at. 0 is the
 * last edit, -1 is the second last, and so on.
 *
 * @param state State tree.
 *
 * @return The current undo offset.
 */

function getCurrentUndoOffset(state) {
  return state.undo.offset;
}
/**
 * Returns the previous edit from the current undo offset
 * for the entity records edits history, if any.
 *
 * @param state State tree.
 *
 * @return The edit.
 */


export function getUndoEdit(state) {
  return state.undo[state.undo.length - 2 + getCurrentUndoOffset(state)];
}
/**
 * Returns the next edit from the current undo offset
 * for the entity records edits history, if any.
 *
 * @param state State tree.
 *
 * @return The edit.
 */

export function getRedoEdit(state) {
  return state.undo[state.undo.length + getCurrentUndoOffset(state)];
}
/**
 * Returns true if there is a previous edit from the current undo offset
 * for the entity records edits history, and false otherwise.
 *
 * @param state State tree.
 *
 * @return Whether there is a previous edit or not.
 */

export function hasUndo(state) {
  return Boolean(getUndoEdit(state));
}
/**
 * Returns true if there is a next edit from the current undo offset
 * for the entity records edits history, and false otherwise.
 *
 * @param state State tree.
 *
 * @return Whether there is a next edit or not.
 */

export function hasRedo(state) {
  return Boolean(getRedoEdit(state));
}
/**
 * Return the current theme.
 *
 * @param state Data state.
 *
 * @return The current theme.
 */

export function getCurrentTheme(state) {
  return getEntityRecord(state, 'root', 'theme', state.currentTheme);
}
/**
 * Return the ID of the current global styles object.
 *
 * @param state Data state.
 *
 * @return The current global styles ID.
 */

export function __experimentalGetCurrentGlobalStylesId(state) {
  return state.currentGlobalStylesId;
}
/**
 * Return theme supports data in the index.
 *
 * @param state Data state.
 *
 * @return Index data.
 */

export function getThemeSupports(state) {
  var _getCurrentTheme$them, _getCurrentTheme;

  return (_getCurrentTheme$them = (_getCurrentTheme = getCurrentTheme(state)) === null || _getCurrentTheme === void 0 ? void 0 : _getCurrentTheme.theme_supports) !== null && _getCurrentTheme$them !== void 0 ? _getCurrentTheme$them : EMPTY_OBJECT;
}
/**
 * Returns the embed preview for the given URL.
 *
 * @param state Data state.
 * @param url   Embedded URL.
 *
 * @return Undefined if the preview has not been fetched, otherwise, the preview fetched from the embed preview API.
 */

export function getEmbedPreview(state, url) {
  return state.embedPreviews[url];
}
/**
 * Determines if the returned preview is an oEmbed link fallback.
 *
 * WordPress can be configured to return a simple link to a URL if it is not embeddable.
 * We need to be able to determine if a URL is embeddable or not, based on what we
 * get back from the oEmbed preview API.
 *
 * @param state Data state.
 * @param url   Embedded URL.
 *
 * @return Is the preview for the URL an oEmbed link fallback.
 */

export function isPreviewEmbedFallback(state, url) {
  const preview = state.embedPreviews[url];
  const oEmbedLinkCheck = '<a href="' + url + '">' + url + '</a>';

  if (!preview) {
    return false;
  }

  return preview.html === oEmbedLinkCheck;
}
/**
 * Returns whether the current user can perform the given action on the given
 * REST resource.
 *
 * Calling this may trigger an OPTIONS request to the REST API via the
 * `canUser()` resolver.
 *
 * https://developer.wordpress.org/rest-api/reference/
 *
 * @param state    Data state.
 * @param action   Action to check. One of: 'create', 'read', 'update', 'delete'.
 * @param resource REST resource to check, e.g. 'media' or 'posts'.
 * @param id       Optional ID of the rest resource to check.
 *
 * @return Whether or not the user can perform the action,
 *                             or `undefined` if the OPTIONS request is still being made.
 */

export function canUser(state, action, resource, id) {
  const key = [action, resource, id].filter(Boolean).join('/');
  return state.userPermissions[key];
}
/**
 * Returns whether the current user can edit the given entity.
 *
 * Calling this may trigger an OPTIONS request to the REST API via the
 * `canUser()` resolver.
 *
 * https://developer.wordpress.org/rest-api/reference/
 *
 * @param state    Data state.
 * @param kind     Entity kind.
 * @param name     Entity name.
 * @param recordId Record's id.
 * @return Whether or not the user can edit,
 * or `undefined` if the OPTIONS request is still being made.
 */

export function canUserEditEntityRecord(state, kind, name, recordId) {
  const entityConfig = getEntityConfig(state, kind, name);

  if (!entityConfig) {
    return false;
  }

  const resource = entityConfig.__unstable_rest_base;
  return canUser(state, 'update', resource, recordId);
}
/**
 * Returns the latest autosaves for the post.
 *
 * May return multiple autosaves since the backend stores one autosave per
 * author for each post.
 *
 * @param state    State tree.
 * @param postType The type of the parent post.
 * @param postId   The id of the parent post.
 *
 * @return An array of autosaves for the post, or undefined if there is none.
 */

export function getAutosaves(state, postType, postId) {
  return state.autosaves[postId];
}
/**
 * Returns the autosave for the post and author.
 *
 * @param state    State tree.
 * @param postType The type of the parent post.
 * @param postId   The id of the parent post.
 * @param authorId The id of the author.
 *
 * @return The autosave for the post and author.
 */

export function getAutosave(state, postType, postId, authorId) {
  if (authorId === undefined) {
    return;
  }

  const autosaves = state.autosaves[postId];
  return autosaves === null || autosaves === void 0 ? void 0 : autosaves.find(autosave => autosave.author === authorId);
}
/**
 * Returns true if the REST request for autosaves has completed.
 *
 * @param state    State tree.
 * @param postType The type of the parent post.
 * @param postId   The id of the parent post.
 *
 * @return True if the REST request was completed. False otherwise.
 */

export const hasFetchedAutosaves = createRegistrySelector(select => (state, postType, postId) => {
  return select(STORE_NAME).hasFinishedResolution('getAutosaves', [postType, postId]);
});
/**
 * Returns a new reference when edited values have changed. This is useful in
 * inferring where an edit has been made between states by comparison of the
 * return values using strict equality.
 *
 * @example
 *
 * ```
 * const hasEditOccurred = (
 *    getReferenceByDistinctEdits( beforeState ) !==
 *    getReferenceByDistinctEdits( afterState )
 * );
 * ```
 *
 * @param state Editor state.
 *
 * @return A value whose reference will change only when an edit occurs.
 */

export const getReferenceByDistinctEdits = createSelector( // This unused state argument is listed here for the documentation generating tool (docgen).
state => [], state => [state.undo.length, state.undo.offset, state.undo.flattenedUndo]);
/**
 * Retrieve the frontend template used for a given link.
 *
 * @param state Editor state.
 * @param link  Link.
 *
 * @return The template record.
 */

export function __experimentalGetTemplateForLink(state, link) {
  const records = getEntityRecords(state, 'postType', 'wp_template', {
    'find-template': link
  });

  if (records !== null && records !== void 0 && records.length) {
    return getEditedEntityRecord(state, 'postType', 'wp_template', records[0].id);
  }

  return null;
}
/**
 * Retrieve the current theme's base global styles
 *
 * @param state Editor state.
 *
 * @return The Global Styles object.
 */

export function __experimentalGetCurrentThemeBaseGlobalStyles(state) {
  const currentTheme = getCurrentTheme(state);

  if (!currentTheme) {
    return null;
  }

  return state.themeBaseGlobalStyles[currentTheme.stylesheet];
}
/**
 * Return the ID of the current global styles object.
 *
 * @param state Data state.
 *
 * @return The current global styles ID.
 */

export function __experimentalGetCurrentThemeGlobalStylesVariations(state) {
  const currentTheme = getCurrentTheme(state);

  if (!currentTheme) {
    return null;
  }

  return state.themeGlobalStyleVariations[currentTheme.stylesheet];
}
/**
 * Retrieve the list of registered block patterns.
 *
 * @param state Data state.
 *
 * @return Block pattern list.
 */

export function getBlockPatterns(state) {
  return state.blockPatterns;
}
/**
 * Retrieve the list of registered block pattern categories.
 *
 * @param state Data state.
 *
 * @return Block pattern category list.
 */

export function getBlockPatternCategories(state) {
  return state.blockPatternCategories;
}
//# sourceMappingURL=selectors.js.map