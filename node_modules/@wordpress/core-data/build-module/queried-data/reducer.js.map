{"version":3,"sources":["@wordpress/core-data/src/queried-data/reducer.js"],"names":["mapValues","combineReducers","compose","conservativeMapItem","ifMatchingAction","replaceAction","onSubKey","DEFAULT_ENTITY_KEY","getQueryParts","getContextFromAction","action","query","queryParts","context","getMergedItemIds","itemIds","nextItemIds","page","perPage","receivedAllIds","nextItemIdsStartIndex","size","Math","max","length","mergedItemIds","Array","i","isInNextItemsRange","removeEntitiesById","entities","ids","Object","fromEntries","entries","filter","id","some","itemId","Number","isInteger","items","state","type","key","reduce","accumulator","value","contextState","itemIsComplete","isCompleteQuery","isArray","fields","result","item","receiveQueries","map","queries","removedItems","contextQueries","queryItems","queryId"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { mapValues } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\nimport { compose } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport {\n\tconservativeMapItem,\n\tifMatchingAction,\n\treplaceAction,\n\tonSubKey,\n} from '../utils';\nimport { DEFAULT_ENTITY_KEY } from '../entities';\nimport getQueryParts from './get-query-parts';\n\nfunction getContextFromAction( action ) {\n\tconst { query } = action;\n\tif ( ! query ) {\n\t\treturn 'default';\n\t}\n\n\tconst queryParts = getQueryParts( query );\n\treturn queryParts.context;\n}\n\n/**\n * Returns a merged array of item IDs, given details of the received paginated\n * items. The array is sparse-like with `undefined` entries where holes exist.\n *\n * @param {?Array<number>} itemIds     Original item IDs (default empty array).\n * @param {number[]}       nextItemIds Item IDs to merge.\n * @param {number}         page        Page of items merged.\n * @param {number}         perPage     Number of items per page.\n *\n * @return {number[]} Merged array of item IDs.\n */\nexport function getMergedItemIds( itemIds, nextItemIds, page, perPage ) {\n\tconst receivedAllIds = page === 1 && perPage === -1;\n\tif ( receivedAllIds ) {\n\t\treturn nextItemIds;\n\t}\n\tconst nextItemIdsStartIndex = ( page - 1 ) * perPage;\n\n\t// If later page has already been received, default to the larger known\n\t// size of the existing array, else calculate as extending the existing.\n\tconst size = Math.max(\n\t\titemIds?.length ?? 0,\n\t\tnextItemIdsStartIndex + nextItemIds.length\n\t);\n\n\t// Preallocate array since size is known.\n\tconst mergedItemIds = new Array( size );\n\n\tfor ( let i = 0; i < size; i++ ) {\n\t\t// Preserve existing item ID except for subset of range of next items.\n\t\tconst isInNextItemsRange =\n\t\t\ti >= nextItemIdsStartIndex &&\n\t\t\ti < nextItemIdsStartIndex + nextItemIds.length;\n\n\t\tmergedItemIds[ i ] = isInNextItemsRange\n\t\t\t? nextItemIds[ i - nextItemIdsStartIndex ]\n\t\t\t: itemIds?.[ i ];\n\t}\n\n\treturn mergedItemIds;\n}\n\n/**\n * Helper function to filter out entities with certain IDs.\n * Entities are keyed by their ID.\n *\n * @param {Object} entities Entity objects, keyed by entity ID.\n * @param {Array}  ids      Entity IDs to filter out.\n *\n * @return {Object} Filtered entities.\n */\nfunction removeEntitiesById( entities, ids ) {\n\treturn Object.fromEntries(\n\t\tObject.entries( entities ).filter(\n\t\t\t( [ id ] ) =>\n\t\t\t\t! ids.some( ( itemId ) => {\n\t\t\t\t\tif ( Number.isInteger( itemId ) ) {\n\t\t\t\t\t\treturn itemId === +id;\n\t\t\t\t\t}\n\t\t\t\t\treturn itemId === id;\n\t\t\t\t} )\n\t\t)\n\t);\n}\n\n/**\n * Reducer tracking items state, keyed by ID. Items are assumed to be normal,\n * where identifiers are common across all queries.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nexport function items( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS': {\n\t\t\tconst context = getContextFromAction( action );\n\t\t\tconst key = action.key || DEFAULT_ENTITY_KEY;\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t[ context ]: {\n\t\t\t\t\t...state[ context ],\n\t\t\t\t\t...action.items.reduce( ( accumulator, value ) => {\n\t\t\t\t\t\tconst itemId = value[ key ];\n\t\t\t\t\t\taccumulator[ itemId ] = conservativeMapItem(\n\t\t\t\t\t\t\tstate?.[ context ]?.[ itemId ],\n\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t}, {} ),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\tcase 'REMOVE_ITEMS':\n\t\t\treturn mapValues( state, ( contextState ) =>\n\t\t\t\tremoveEntitiesById( contextState, action.itemIds )\n\t\t\t);\n\t}\n\treturn state;\n}\n\n/**\n * Reducer tracking item completeness, keyed by ID. A complete item is one for\n * which all fields are known. This is used in supporting `_fields` queries,\n * where not all properties associated with an entity are necessarily returned.\n * In such cases, completeness is used as an indication of whether it would be\n * safe to use queried data for a non-`_fields`-limited request.\n *\n * @param {Object<string,Object<string,boolean>>} state  Current state.\n * @param {Object}                                action Dispatched action.\n *\n * @return {Object<string,Object<string,boolean>>} Next state.\n */\nexport function itemIsComplete( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS': {\n\t\t\tconst context = getContextFromAction( action );\n\t\t\tconst { query, key = DEFAULT_ENTITY_KEY } = action;\n\n\t\t\t// An item is considered complete if it is received without an associated\n\t\t\t// fields query. Ideally, this would be implemented in such a way where the\n\t\t\t// complete aggregate of all fields would satisfy completeness. Since the\n\t\t\t// fields are not consistent across all entities, this would require\n\t\t\t// introspection on the REST schema for each entity to know which fields\n\t\t\t// compose a complete item for that entity.\n\t\t\tconst queryParts = query ? getQueryParts( query ) : {};\n\t\t\tconst isCompleteQuery =\n\t\t\t\t! query || ! Array.isArray( queryParts.fields );\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t[ context ]: {\n\t\t\t\t\t...state[ context ],\n\t\t\t\t\t...action.items.reduce( ( result, item ) => {\n\t\t\t\t\t\tconst itemId = item[ key ];\n\n\t\t\t\t\t\t// Defer to completeness if already assigned. Technically the\n\t\t\t\t\t\t// data may be outdated if receiving items for a field subset.\n\t\t\t\t\t\tresult[ itemId ] =\n\t\t\t\t\t\t\tstate?.[ context ]?.[ itemId ] || isCompleteQuery;\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, {} ),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\tcase 'REMOVE_ITEMS':\n\t\t\treturn mapValues( state, ( contextState ) =>\n\t\t\t\tremoveEntitiesById( contextState, action.itemIds )\n\t\t\t);\n\t}\n\n\treturn state;\n}\n\n/**\n * Reducer tracking queries state, keyed by stable query key. Each reducer\n * query object includes `itemIds` and `requestingPageByPerPage`.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nconst receiveQueries = compose( [\n\t// Limit to matching action type so we don't attempt to replace action on\n\t// an unhandled action.\n\tifMatchingAction( ( action ) => 'query' in action ),\n\n\t// Inject query parts into action for use both in `onSubKey` and reducer.\n\treplaceAction( ( action ) => {\n\t\t// `ifMatchingAction` still passes on initialization, where state is\n\t\t// undefined and a query is not assigned. Avoid attempting to parse\n\t\t// parts. `onSubKey` will omit by lack of `stableKey`.\n\t\tif ( action.query ) {\n\t\t\treturn {\n\t\t\t\t...action,\n\t\t\t\t...getQueryParts( action.query ),\n\t\t\t};\n\t\t}\n\n\t\treturn action;\n\t} ),\n\n\tonSubKey( 'context' ),\n\n\t// Queries shape is shared, but keyed by query `stableKey` part. Original\n\t// reducer tracks only a single query object.\n\tonSubKey( 'stableKey' ),\n] )( ( state = null, action ) => {\n\tconst { type, page, perPage, key = DEFAULT_ENTITY_KEY } = action;\n\n\tif ( type !== 'RECEIVE_ITEMS' ) {\n\t\treturn state;\n\t}\n\n\treturn getMergedItemIds(\n\t\tstate || [],\n\t\taction.items.map( ( item ) => item[ key ] ),\n\t\tpage,\n\t\tperPage\n\t);\n} );\n\n/**\n * Reducer tracking queries state.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nconst queries = ( state = {}, action ) => {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS':\n\t\t\treturn receiveQueries( state, action );\n\t\tcase 'REMOVE_ITEMS':\n\t\t\tconst removedItems = action.itemIds.reduce( ( result, itemId ) => {\n\t\t\t\tresult[ itemId ] = true;\n\t\t\t\treturn result;\n\t\t\t}, {} );\n\n\t\t\treturn mapValues( state, ( contextQueries ) => {\n\t\t\t\treturn mapValues( contextQueries, ( queryItems ) => {\n\t\t\t\t\treturn queryItems.filter( ( queryId ) => {\n\t\t\t\t\t\treturn ! removedItems[ queryId ];\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\tdefault:\n\t\t\treturn state;\n\t}\n};\n\nexport default combineReducers( {\n\titems,\n\titemIsComplete,\n\tqueries,\n} );\n"]}