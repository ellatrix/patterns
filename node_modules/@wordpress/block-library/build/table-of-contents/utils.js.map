{"version":3,"sources":["@wordpress/block-library/src/table-of-contents/utils.ts"],"names":["linearToNestedHeadingList","headingList","nestedHeadingList","forEach","heading","key","content","level","endOfSlice","length","i","push","children","slice"],"mappings":";;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,yBAAT,CACNC,WADM,EAEgB;AACtB,QAAMC,iBAAsC,GAAG,EAA/C;AAEAD,EAAAA,WAAW,CAACE,OAAZ,CAAqB,CAAEC,OAAF,EAAWC,GAAX,KAAoB;AACxC,QAAKD,OAAO,CAACE,OAAR,KAAoB,EAAzB,EAA8B;AAC7B;AACA,KAHuC,CAKxC;;;AACA,QAAKF,OAAO,CAACG,KAAR,KAAkBN,WAAW,CAAE,CAAF,CAAX,CAAiBM,KAAxC,EAAgD;AAAA;;AAC/C;AACA;AACA;AACA,UAAK,iBAAAN,WAAW,CAAEI,GAAG,GAAG,CAAR,CAAX,8DAAwBE,KAAxB,IAAgCH,OAAO,CAACG,KAA7C,EAAqD;AACpD;AACA;AACA;AACA,YAAIC,UAAU,GAAGP,WAAW,CAACQ,MAA7B;;AACA,aAAM,IAAIC,CAAC,GAAGL,GAAG,GAAG,CAApB,EAAuBK,CAAC,GAAGT,WAAW,CAACQ,MAAvC,EAA+CC,CAAC,EAAhD,EAAqD;AACpD,cAAKT,WAAW,CAAES,CAAF,CAAX,CAAiBH,KAAjB,KAA2BH,OAAO,CAACG,KAAxC,EAAgD;AAC/CC,YAAAA,UAAU,GAAGE,CAAb;AACA;AACA;AACD,SAVmD,CAYpD;AACA;;;AACAR,QAAAA,iBAAiB,CAACS,IAAlB,CAAwB;AACvBP,UAAAA,OADuB;AAEvBQ,UAAAA,QAAQ,EAAEZ,yBAAyB,CAClCC,WAAW,CAACY,KAAZ,CAAmBR,GAAG,GAAG,CAAzB,EAA4BG,UAA5B,CADkC;AAFZ,SAAxB;AAMA,OApBD,MAoBO;AACN;AACAN,QAAAA,iBAAiB,CAACS,IAAlB,CAAwB;AACvBP,UAAAA,OADuB;AAEvBQ,UAAAA,QAAQ,EAAE;AAFa,SAAxB;AAIA;AACD;AACD,GAtCD;AAwCA,SAAOV,iBAAP;AACA","sourcesContent":["export interface HeadingData {\n\t/** The plain text content of the heading. */\n\tcontent: string;\n\t/** The heading level. */\n\tlevel: number;\n\t/** Link to the heading. */\n\tlink: string;\n}\n\nexport interface NestedHeadingData {\n\t/** The heading content, level, and link. */\n\theading: HeadingData;\n\t/** The sub-headings of this heading, if any. */\n\tchildren: NestedHeadingData[] | null;\n}\n\n/**\n * Takes a flat list of heading parameters and nests them based on each header's\n * immediate parent's level.\n *\n * @param headingList The flat list of headings to nest.\n *\n * @return The nested list of headings.\n */\nexport function linearToNestedHeadingList(\n\theadingList: HeadingData[]\n): NestedHeadingData[] {\n\tconst nestedHeadingList: NestedHeadingData[] = [];\n\n\theadingList.forEach( ( heading, key ) => {\n\t\tif ( heading.content === '' ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure we are only working with the same level as the first iteration in our set.\n\t\tif ( heading.level === headingList[ 0 ].level ) {\n\t\t\t// Check that the next iteration will return a value.\n\t\t\t// If it does and the next level is greater than the current level,\n\t\t\t// the next iteration becomes a child of the current iteration.\n\t\t\tif ( headingList[ key + 1 ]?.level > heading.level ) {\n\t\t\t\t// We must calculate the last index before the next iteration that\n\t\t\t\t// has the same level (siblings). We then use this index to slice\n\t\t\t\t// the array for use in recursion. This prevents duplicate nodes.\n\t\t\t\tlet endOfSlice = headingList.length;\n\t\t\t\tfor ( let i = key + 1; i < headingList.length; i++ ) {\n\t\t\t\t\tif ( headingList[ i ].level === heading.level ) {\n\t\t\t\t\t\tendOfSlice = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We found a child node: Push a new node onto the return array\n\t\t\t\t// with children.\n\t\t\t\tnestedHeadingList.push( {\n\t\t\t\t\theading,\n\t\t\t\t\tchildren: linearToNestedHeadingList(\n\t\t\t\t\t\theadingList.slice( key + 1, endOfSlice )\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t// No child node: Push a new node onto the return array.\n\t\t\t\tnestedHeadingList.push( {\n\t\t\t\t\theading,\n\t\t\t\t\tchildren: null,\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t} );\n\n\treturn nestedHeadingList;\n}\n"]}