"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TableOfContentsEdit;

var _element = require("@wordpress/element");

var _es = _interopRequireDefault(require("fast-deep-equal/es6"));

var _blockEditor = require("@wordpress/block-editor");

var _blocks = require("@wordpress/blocks");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _dom = require("@wordpress/dom");

var _i18n = require("@wordpress/i18n");

var _url = require("@wordpress/url");

var _icon = _interopRequireDefault(require("./icon"));

var _list = _interopRequireDefault(require("./list"));

var _utils = require("./utils");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('./utils').HeadingData} HeadingData */

/**
 * Table of Contents block edit component.
 *
 * @param {Object}                       props                                   The props.
 * @param {Object}                       props.attributes                        The block attributes.
 * @param {HeadingData[]}                props.attributes.headings               A list of data for each heading in the post.
 * @param {boolean}                      props.attributes.onlyIncludeCurrentPage Whether to only include headings from the current page (if the post is paginated).
 * @param {string}                       props.clientId
 * @param {(attributes: Object) => void} props.setAttributes
 *
 * @return {WPComponent} The component.
 */
function TableOfContentsEdit(_ref) {
  let {
    attributes: {
      headings = [],
      onlyIncludeCurrentPage
    },
    clientId,
    setAttributes
  } = _ref;
  const blockProps = (0, _blockEditor.useBlockProps)();
  const canInsertList = (0, _data.useSelect)(select => {
    const {
      getBlockRootClientId,
      canInsertBlockType
    } = select(_blockEditor.store);
    const rootClientId = getBlockRootClientId(clientId);
    return canInsertBlockType('core/list', rootClientId);
  }, [clientId]);
  const {
    __unstableMarkNextChangeAsNotPersistent,
    replaceBlocks
  } = (0, _data.useDispatch)(_blockEditor.store);
  /**
   * The latest heading data, or null if the new data deeply equals the saved
   * headings attribute.
   *
   * Since useSelect forces a re-render when its return value is shallowly
   * inequal to its prior call, we would be re-rendering this block every time
   * the stores change, even if the latest headings were deeply equal to the
   * ones saved in the block attributes.
   *
   * By returning null when they're equal, we reduce that to 2 renders: one
   * when there are new latest headings (and so it returns them), and one when
   * they haven't changed (so it returns null). As long as the latest heading
   * data remains the same, further calls of the useSelect callback will
   * continue to return null, thus preventing any forced re-renders.
   */

  const latestHeadings = (0, _data.useSelect)(select => {
    var _editorSelectors$getP;

    const {
      getBlockAttributes,
      getBlockName,
      getClientIdsWithDescendants,
      __experimentalGetGlobalBlocksByName: getGlobalBlocksByName
    } = select(_blockEditor.store); // FIXME: @wordpress/block-library should not depend on @wordpress/editor.
    // Blocks can be loaded into a *non-post* block editor, so to avoid
    // declaring @wordpress/editor as a dependency, we must access its
    // store by string. When the store is not available, editorSelectors
    // will be null, and the block's saved markup will lack permalinks.
    // eslint-disable-next-line @wordpress/data-no-store-string-literals

    const editorSelectors = select('core/editor');
    const pageBreakClientIds = getGlobalBlocksByName('core/nextpage');
    const isPaginated = pageBreakClientIds.length !== 0; // Get the client ids of all blocks in the editor.

    const allBlockClientIds = getClientIdsWithDescendants(); // If onlyIncludeCurrentPage is true, calculate the page (of a paginated post) this block is part of, so we know which headings to include; otherwise, skip the calculation.

    let tocPage = 1;

    if (isPaginated && onlyIncludeCurrentPage) {
      // We can't use getBlockIndex because it only returns the index
      // relative to sibling blocks.
      const tocIndex = allBlockClientIds.indexOf(clientId);

      for (const [blockIndex, blockClientId] of allBlockClientIds.entries()) {
        // If we've reached blocks after the Table of Contents, we've
        // finished calculating which page the block is on.
        if (blockIndex >= tocIndex) {
          break;
        }

        if (getBlockName(blockClientId) === 'core/nextpage') {
          tocPage++;
        }
      }
    }

    const _latestHeadings = [];
    /** The page (of a paginated post) a heading will be part of. */

    let headingPage = 1;
    /**
     * A permalink to the current post. If the core/editor store is
     * unavailable, this variable will be null.
     */

    const permalink = (_editorSelectors$getP = editorSelectors === null || editorSelectors === void 0 ? void 0 : editorSelectors.getPermalink()) !== null && _editorSelectors$getP !== void 0 ? _editorSelectors$getP : null;
    let headingPageLink = null; // If the core/editor store is available, we can add permalinks to the
    // generated table of contents.

    if (typeof permalink === 'string') {
      headingPageLink = isPaginated ? (0, _url.addQueryArgs)(permalink, {
        page: headingPage
      }) : permalink;
    }

    for (const blockClientId of allBlockClientIds) {
      const blockName = getBlockName(blockClientId);

      if (blockName === 'core/nextpage') {
        headingPage++; // If we're only including headings from the current page (of
        // a paginated post), then exit the loop if we've reached the
        // pages after the one with the Table of Contents block.

        if (onlyIncludeCurrentPage && headingPage > tocPage) {
          break;
        }

        if (typeof permalink === 'string') {
          headingPageLink = (0, _url.addQueryArgs)((0, _url.removeQueryArgs)(permalink, ['page']), {
            page: headingPage
          });
        }
      } // If we're including all headings or we've reached headings on
      // the same page as the Table of Contents block, add them to the
      // list.
      else if (!onlyIncludeCurrentPage || headingPage === tocPage) {
        if (blockName === 'core/heading') {
          const headingAttributes = getBlockAttributes(blockClientId);
          const canBeLinked = typeof headingPageLink === 'string' && typeof headingAttributes.anchor === 'string' && headingAttributes.anchor !== '';

          _latestHeadings.push({
            // Convert line breaks to spaces, and get rid of HTML tags in the headings.
            content: (0, _dom.__unstableStripHTML)(headingAttributes.content.replace(/(<br *\/?>)+/g, ' ')),
            level: headingAttributes.level,
            link: canBeLinked ? `${headingPageLink}#${headingAttributes.anchor}` : null
          });
        }
      }
    }

    if ((0, _es.default)(headings, _latestHeadings)) {
      return null;
    }

    return _latestHeadings;
  }, [clientId, onlyIncludeCurrentPage, headings]);
  (0, _element.useEffect)(() => {
    if (latestHeadings !== null) {
      // This is required to keep undo working and not create 2 undo steps
      // for each heading change.
      __unstableMarkNextChangeAsNotPersistent();

      setAttributes({
        headings: latestHeadings
      });
    }
  }, [latestHeadings]);
  const headingTree = (0, _utils.linearToNestedHeadingList)(headings);
  const toolbarControls = canInsertList && (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_components.ToolbarGroup, null, (0, _element.createElement)(_components.ToolbarButton, {
    onClick: () => replaceBlocks(clientId, (0, _blocks.createBlock)('core/list', {
      ordered: true,
      values: (0, _element.renderToString)((0, _element.createElement)(_list.default, {
        nestedHeadingList: headingTree
      }))
    }))
  }, (0, _i18n.__)('Convert to static list'))));
  const inspectorControls = (0, _element.createElement)(_blockEditor.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Settings')
  }, (0, _element.createElement)(_components.ToggleControl, {
    __nextHasNoMarginBottom: true,
    label: (0, _i18n.__)('Only include current page'),
    checked: onlyIncludeCurrentPage,
    onChange: value => setAttributes({
      onlyIncludeCurrentPage: value
    }),
    help: onlyIncludeCurrentPage ? (0, _i18n.__)('Only including headings from the current page (if the post is paginated).') : (0, _i18n.__)('Toggle to only include headings from the current page (if the post is paginated).')
  }))); // If there are no headings or the only heading is empty.
  // Note that the toolbar controls are intentionally omitted since the
  // "Convert to static list" option is useless to the placeholder state.

  if (headings.length === 0) {
    return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_components.Placeholder, {
      icon: (0, _element.createElement)(_blockEditor.BlockIcon, {
        icon: _icon.default
      }),
      label: (0, _i18n.__)('Table of Contents'),
      instructions: (0, _i18n.__)('Start adding Heading blocks to create a table of contents. Headings with HTML anchors will be linked here.')
    })), inspectorControls);
  }

  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("nav", blockProps, (0, _element.createElement)("ol", {
    inert: "true"
  }, (0, _element.createElement)(_list.default, {
    nestedHeadingList: headingTree
  }))), toolbarControls, inspectorControls);
}
//# sourceMappingURL=edit.js.map