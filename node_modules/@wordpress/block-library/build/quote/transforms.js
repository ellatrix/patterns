"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _blocks = require("@wordpress/blocks");

/**
 * WordPress dependencies
 */
const transforms = {
  from: [{
    type: 'block',
    blocks: ['core/pullquote'],
    transform: _ref => {
      let {
        value,
        citation,
        anchor,
        fontSize,
        style
      } = _ref;
      return (0, _blocks.createBlock)('core/quote', {
        citation,
        anchor,
        fontSize,
        style
      }, [(0, _blocks.createBlock)('core/paragraph', {
        content: value
      })]);
    }
  }, {
    type: 'block',
    blocks: ['core/group'],
    transform: (_ref2, innerBlocks) => {
      let {
        anchor
      } = _ref2;
      return (0, _blocks.createBlock)('core/quote', {
        anchor
      }, innerBlocks);
    }
  }, {
    type: 'prefix',
    prefix: '>',
    transform: content => (0, _blocks.createBlock)('core/quote', {}, [(0, _blocks.createBlock)('core/paragraph', {
      content
    })])
  }, {
    type: 'raw',
    schema: () => ({
      blockquote: {
        children: '*'
      }
    }),
    selector: 'blockquote',
    transform: (node, handler) => {
      return (0, _blocks.createBlock)('core/quote', // Don't try to parse any `cite` out of this content.
      // * There may be more than one cite.
      // * There may be more attribution text than just the cite.
      // * If the cite is nested in the quoted text, it's wrong to
      //   remove it.
      {}, handler({
        HTML: node.innerHTML,
        mode: 'BLOCKS'
      }));
    }
  }, {
    type: 'block',
    isMultiBlock: true,
    blocks: ['*'],
    isMatch: (_ref3, blocks) => {
      let {} = _ref3;

      // When a single block is selected make the tranformation
      // available only to specific blocks that make sense.
      if (blocks.length === 1) {
        return ['core/paragraph', 'core/heading', 'core/list', 'core/pullquote'].includes(blocks[0].name);
      }

      return !blocks.some(_ref4 => {
        let {
          name
        } = _ref4;
        return name === 'core/quote';
      });
    },
    __experimentalConvert: blocks => (0, _blocks.createBlock)('core/quote', {}, blocks.map(block => (0, _blocks.createBlock)(block.name, block.attributes, block.innerBlocks)))
  }],
  to: [{
    type: 'block',
    blocks: ['core/pullquote'],
    isMatch: (_ref5, block) => {
      let {} = _ref5;
      return block.innerBlocks.every(_ref6 => {
        let {
          name
        } = _ref6;
        return name === 'core/paragraph';
      });
    },
    transform: (_ref7, innerBlocks) => {
      let {
        citation,
        anchor,
        fontSize,
        style
      } = _ref7;
      const value = innerBlocks.map(_ref8 => {
        let {
          attributes
        } = _ref8;
        return `${attributes.content}`;
      }).join('<br>');
      return (0, _blocks.createBlock)('core/pullquote', {
        value,
        citation,
        anchor,
        fontSize,
        style
      });
    }
  }, {
    type: 'block',
    blocks: ['core/group'],
    transform: (_ref9, innerBlocks) => {
      let {
        citation,
        anchor
      } = _ref9;
      return (0, _blocks.createBlock)('core/group', {
        anchor
      }, citation ? [...innerBlocks, (0, _blocks.createBlock)('core/paragraph', {
        content: citation
      })] : innerBlocks);
    }
  }, {
    type: 'block',
    blocks: ['*'],
    transform: (_ref10, innerBlocks) => {
      let {
        citation
      } = _ref10;
      return citation ? [...innerBlocks, (0, _blocks.createBlock)('core/paragraph', {
        content: citation
      })] : innerBlocks;
    }
  }]
};
var _default = transforms;
exports.default = _default;
//# sourceMappingURL=transforms.js.map