"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _blockEditor = require("@wordpress/block-editor");

var _dom = require("@wordpress/dom");

/**
 * WordPress dependencies
 */
function MissingBlockWarning(_ref) {
  let {
    attributes,
    convertToHTML,
    clientId
  } = _ref;
  const {
    originalName,
    originalUndelimitedContent
  } = attributes;
  const hasContent = !!originalUndelimitedContent;
  const hasHTMLBlock = (0, _data.useSelect)(select => {
    const {
      canInsertBlockType,
      getBlockRootClientId
    } = select(_blockEditor.store);
    return canInsertBlockType('core/html', getBlockRootClientId(clientId));
  }, [clientId]);
  const actions = [];
  let messageHTML;

  if (hasContent && hasHTMLBlock) {
    messageHTML = (0, _i18n.sprintf)(
    /* translators: %s: block name */
    (0, _i18n.__)('Your site doesn’t include support for the "%s" block. You can leave this block intact, convert its content to a Custom HTML block, or remove it entirely.'), originalName);
    actions.push((0, _element.createElement)(_components.Button, {
      key: "convert",
      onClick: convertToHTML,
      variant: "primary"
    }, (0, _i18n.__)('Keep as HTML')));
  } else {
    messageHTML = (0, _i18n.sprintf)(
    /* translators: %s: block name */
    (0, _i18n.__)('Your site doesn’t include support for the "%s" block. You can leave this block intact or remove it entirely.'), originalName);
  }

  return (0, _element.createElement)("div", (0, _blockEditor.useBlockProps)({
    className: 'has-warning'
  }), (0, _element.createElement)(_blockEditor.Warning, {
    actions: actions
  }, messageHTML), (0, _element.createElement)(_element.RawHTML, null, (0, _dom.safeHTML)(originalUndelimitedContent)));
}

const MissingEdit = (0, _data.withDispatch)((dispatch, _ref2) => {
  let {
    clientId,
    attributes
  } = _ref2;
  const {
    replaceBlock
  } = dispatch(_blockEditor.store);
  return {
    convertToHTML() {
      replaceBlock(clientId, (0, _blocks.createBlock)('core/html', {
        content: attributes.originalUndelimitedContent
      }));
    }

  };
})(MissingBlockWarning);
var _default = MissingEdit;
exports.default = _default;
//# sourceMappingURL=edit.js.map