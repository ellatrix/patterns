"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PageListEdit;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _blocks = require("@wordpress/blocks");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _coreData = require("@wordpress/core-data");

var _data = require("@wordpress/data");

var _useConvertToNavigationLinks = require("./use-convert-to-navigation-links");

var _convertToLinksModal = require("./convert-to-links-modal");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
// We only show the edit option when page count is <= MAX_PAGE_COUNT
// Performance of Navigation Links is not good past this value.
const MAX_PAGE_COUNT = 100;

const NOOP = () => {};

function BlockContent(_ref) {
  let {
    blockProps,
    innerBlocksProps,
    hasResolvedPages,
    blockList,
    pages,
    parentPageID
  } = _ref;

  if (!hasResolvedPages) {
    return (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_components.Spinner, null));
  }

  if (pages === null) {
    return (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_components.Notice, {
      status: 'warning',
      isDismissible: false
    }, (0, _i18n.__)('Page List: Cannot retrieve Pages.')));
  }

  if (pages.length === 0) {
    return (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_components.Notice, {
      status: 'info',
      isDismissible: false
    }, (0, _i18n.__)('Page List: Cannot retrieve Pages.')));
  }

  if (blockList.length === 0) {
    var _parentPageDetails$ti;

    const parentPageDetails = pages.find(page => page.id === parentPageID);

    if (parentPageDetails !== null && parentPageDetails !== void 0 && (_parentPageDetails$ti = parentPageDetails.title) !== null && _parentPageDetails$ti !== void 0 && _parentPageDetails$ti.rendered) {
      return (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_blockEditor.Warning, null, (0, _i18n.sprintf)( // translators: %s: Page title.
      (0, _i18n.__)('Page List: "%s" page has no children.'), parentPageDetails.title.rendered)));
    }

    return (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_components.Notice, {
      status: 'warning',
      isDismissible: false
    }, (0, _i18n.__)('Page List: Cannot retrieve Pages.')));
  }

  if (pages.length > 0) {
    return (0, _element.createElement)("ul", innerBlocksProps);
  }
}

function ConvertToLinks(_ref2) {
  let {
    onClick,
    disabled
  } = _ref2;
  const [isOpen, setOpen] = (0, _element.useState)(false);

  const openModal = () => setOpen(true);

  const closeModal = () => setOpen(false);

  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.BlockControls, {
    group: "other"
  }, (0, _element.createElement)(_components.ToolbarButton, {
    title: (0, _i18n.__)('Edit'),
    onClick: openModal
  }, (0, _i18n.__)('Edit'))), isOpen && (0, _element.createElement)(_convertToLinksModal.ConvertToLinksModal, {
    onClick: onClick,
    onClose: closeModal,
    disabled: disabled
  }));
}

function PageListEdit(_ref3) {
  var _context$style;

  let {
    context,
    clientId,
    attributes,
    setAttributes
  } = _ref3;
  const {
    parentPageID
  } = attributes;
  const {
    records: pages,
    hasResolved: hasResolvedPages
  } = (0, _coreData.useEntityRecords)('postType', 'page', {
    per_page: MAX_PAGE_COUNT,
    _fields: ['id', 'link', 'menu_order', 'parent', 'title', 'type'],
    // TODO: When https://core.trac.wordpress.org/ticket/39037 REST API support for multiple orderby
    // values is resolved, update 'orderby' to [ 'menu_order', 'post_title' ] to provide a consistent
    // sort.
    orderby: 'menu_order',
    order: 'asc'
  });
  const allowConvertToLinks = 'showSubmenuIcon' in context && (pages === null || pages === void 0 ? void 0 : pages.length) > 0 && (pages === null || pages === void 0 ? void 0 : pages.length) <= MAX_PAGE_COUNT;
  const pagesByParentId = (0, _element.useMemo)(() => {
    if (pages === null) {
      return new Map();
    } // TODO: Once the REST API supports passing multiple values to
    // 'orderby', this can be removed.
    // https://core.trac.wordpress.org/ticket/39037


    const sortedPages = pages.sort((a, b) => {
      if (a.menu_order === b.menu_order) {
        return a.title.rendered.localeCompare(b.title.rendered);
      }

      return a.menu_order - b.menu_order;
    });
    return sortedPages.reduce((accumulator, page) => {
      const {
        parent
      } = page;

      if (accumulator.has(parent)) {
        accumulator.get(parent).push(page);
      } else {
        accumulator.set(parent, [page]);
      }

      return accumulator;
    }, new Map());
  }, [pages]);
  const convertToNavigationLinks = (0, _useConvertToNavigationLinks.useConvertToNavigationLinks)({
    clientId,
    pages,
    parentPageID
  });
  const blockProps = (0, _blockEditor.useBlockProps)({
    className: (0, _classnames.default)('wp-block-page-list', {
      'has-text-color': !!context.textColor,
      [(0, _blockEditor.getColorClassName)('color', context.textColor)]: !!context.textColor,
      'has-background': !!context.backgroundColor,
      [(0, _blockEditor.getColorClassName)('background-color', context.backgroundColor)]: !!context.backgroundColor
    }),
    style: { ...((_context$style = context.style) === null || _context$style === void 0 ? void 0 : _context$style.color)
    }
  });

  const getBlockList = function () {
    let parentId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentPageID;
    const childPages = pagesByParentId.get(parentId);

    if (!(childPages !== null && childPages !== void 0 && childPages.length)) {
      return [];
    }

    return childPages.reduce((template, page) => {
      var _page$title, _page$title2;

      const hasChildren = pagesByParentId.has(page.id);
      const pageProps = {
        id: page.id,
        label: (_page$title = page.title) === null || _page$title === void 0 ? void 0 : _page$title.rendered,
        title: (_page$title2 = page.title) === null || _page$title2 === void 0 ? void 0 : _page$title2.rendered,
        link: page.url,
        hasChildren
      };
      let item = null;
      const children = getBlockList(page.id);
      item = (0, _blocks.createBlock)('core/page-list-item', pageProps, children);
      template.push(item);
      return template;
    }, []);
  };

  const makePagesTree = function () {
    let parentId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const childPages = pagesByParentId.get(parentId);

    if (!(childPages !== null && childPages !== void 0 && childPages.length)) {
      return [];
    }

    return childPages.reduce((tree, page) => {
      const hasChildren = pagesByParentId.has(page.id);
      const item = {
        value: page.id,
        label: 'â€” '.repeat(level) + page.title.rendered,
        rawName: page.title.rendered
      };
      tree.push(item);

      if (hasChildren) {
        tree.push(...makePagesTree(page.id, level + 1));
      }

      return tree;
    }, []);
  };

  const pagesTree = (0, _element.useMemo)(makePagesTree, [pagesByParentId]);
  const blockList = (0, _element.useMemo)(getBlockList, [pagesByParentId, parentPageID]);
  const innerBlocksProps = (0, _blockEditor.useInnerBlocksProps)(blockProps, {
    allowedBlocks: ['core/page-list-item'],
    renderAppender: false,
    __unstableDisableDropZone: true,
    templateLock: 'all',
    onInput: NOOP,
    onChange: NOOP,
    value: blockList
  });
  const {
    isNested
  } = (0, _data.useSelect)(select => {
    const {
      getBlockParentsByBlockName
    } = select(_blockEditor.store);
    const blockParents = getBlockParentsByBlockName(clientId, 'core/navigation-submenu', true);
    return {
      isNested: blockParents.length > 0
    };
  }, [clientId]);
  (0, _element.useEffect)(() => {
    setAttributes({
      isNested
    });
  }, [isNested]);
  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.InspectorControls, null, pagesTree.length > 0 && (0, _element.createElement)(_components.PanelBody, null, (0, _element.createElement)(_components.ComboboxControl, {
    className: "editor-page-attributes__parent",
    label: (0, _i18n.__)('Parent page'),
    value: parentPageID,
    options: pagesTree,
    onChange: value => setAttributes({
      parentPageID: value !== null && value !== void 0 ? value : 0
    }),
    help: (0, _i18n.__)('Choose a page to show only its subpages.')
  })), allowConvertToLinks && (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Edit this menu')
  }, (0, _element.createElement)("p", null, _convertToLinksModal.convertDescription), (0, _element.createElement)(_components.Button, {
    variant: "primary",
    disabled: !hasResolvedPages,
    onClick: convertToNavigationLinks
  }, (0, _i18n.__)('Edit')))), allowConvertToLinks && (0, _element.createElement)(ConvertToLinks, {
    disabled: !hasResolvedPages,
    onClick: convertToNavigationLinks
  }), (0, _element.createElement)(BlockContent, {
    blockProps: blockProps,
    innerBlocksProps: innerBlocksProps,
    hasResolvedPages: hasResolvedPages,
    blockList: blockList,
    pages: pages,
    parentPageID: parentPageID
  }));
}
//# sourceMappingURL=edit.js.map