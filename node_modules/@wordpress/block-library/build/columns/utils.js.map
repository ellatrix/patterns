{"version":3,"sources":["@wordpress/block-library/src/columns/utils.js"],"names":["toWidthPrecision","value","unitlessValue","parseFloat","Number","isFinite","toFixed","undefined","getEffectiveColumnWidth","block","totalBlockCount","width","attributes","getTotalColumnsWidth","blocks","length","reduce","sum","getColumnWidths","accumulator","Object","assign","clientId","getRedistributedColumnWidths","availableWidth","totalWidth","newWidth","hasExplicitPercentColumnWidths","every","blockWidth","endsWith","getMappedColumnWidths","widths","map","getWidths","withParsing","innerColumn","innerColumnWidth","getWidthWithUnit","unit","isPercentageUnit","Math","min"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { mapValues } from 'lodash';\n\n/**\n * Returns a column width attribute value rounded to standard precision.\n * Returns `undefined` if the value is not a valid finite number.\n *\n * @param {?number} value Raw value.\n *\n * @return {number} Value rounded to standard precision.\n */\nexport const toWidthPrecision = ( value ) => {\n\tconst unitlessValue = parseFloat( value );\n\treturn Number.isFinite( unitlessValue )\n\t\t? parseFloat( unitlessValue.toFixed( 2 ) )\n\t\t: undefined;\n};\n/**\n * Returns an effective width for a given block. An effective width is equal to\n * its attribute value if set, or a computed value assuming equal distribution.\n *\n * @param {WPBlock} block           Block object.\n * @param {number}  totalBlockCount Total number of blocks in Columns.\n *\n * @return {number} Effective column width.\n */\nexport function getEffectiveColumnWidth( block, totalBlockCount ) {\n\tconst { width = 100 / totalBlockCount } = block.attributes;\n\treturn toWidthPrecision( width );\n}\n\n/**\n * Returns the total width occupied by the given set of column blocks.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {number} Total width occupied by blocks.\n */\nexport function getTotalColumnsWidth(\n\tblocks,\n\ttotalBlockCount = blocks.length\n) {\n\treturn blocks.reduce(\n\t\t( sum, block ) =>\n\t\t\tsum + getEffectiveColumnWidth( block, totalBlockCount ),\n\t\t0\n\t);\n}\n\n/**\n * Returns an object of `clientId` → `width` of effective column widths.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {Object<string,number>} Column widths.\n */\nexport function getColumnWidths( blocks, totalBlockCount = blocks.length ) {\n\treturn blocks.reduce( ( accumulator, block ) => {\n\t\tconst width = getEffectiveColumnWidth( block, totalBlockCount );\n\t\treturn Object.assign( accumulator, { [ block.clientId ]: width } );\n\t}, {} );\n}\n\n/**\n * Returns an object of `clientId` → `width` of column widths as redistributed\n * proportional to their current widths, constrained or expanded to fit within\n * the given available width.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {number}    availableWidth  Maximum width to fit within.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {Object<string,number>} Redistributed column widths.\n */\nexport function getRedistributedColumnWidths(\n\tblocks,\n\tavailableWidth,\n\ttotalBlockCount = blocks.length\n) {\n\tconst totalWidth = getTotalColumnsWidth( blocks, totalBlockCount );\n\n\treturn mapValues( getColumnWidths( blocks, totalBlockCount ), ( width ) => {\n\t\tconst newWidth = ( availableWidth * width ) / totalWidth;\n\t\treturn toWidthPrecision( newWidth );\n\t} );\n}\n\n/**\n * Returns true if column blocks within the provided set are assigned with\n * explicit widths, or false otherwise.\n *\n * @param {WPBlock[]} blocks Block objects.\n *\n * @return {boolean} Whether columns have explicit widths.\n */\nexport function hasExplicitPercentColumnWidths( blocks ) {\n\treturn blocks.every( ( block ) => {\n\t\tconst blockWidth = block.attributes.width;\n\t\treturn Number.isFinite(\n\t\t\tblockWidth?.endsWith?.( '%' )\n\t\t\t\t? parseFloat( blockWidth )\n\t\t\t\t: blockWidth\n\t\t);\n\t} );\n}\n\n/**\n * Returns a copy of the given set of blocks with new widths assigned from the\n * provided object of redistributed column widths.\n *\n * @param {WPBlock[]}             blocks Block objects.\n * @param {Object<string,number>} widths Redistributed column widths.\n *\n * @return {WPBlock[]} blocks Mapped block objects.\n */\nexport function getMappedColumnWidths( blocks, widths ) {\n\treturn blocks.map( ( block ) => ( {\n\t\t...block,\n\t\tattributes: {\n\t\t\t...block.attributes,\n\t\t\twidth: `${ widths[ block.clientId ] }%`,\n\t\t},\n\t} ) );\n}\n\n/**\n * Returns an array with columns widths values, parsed or no depends on `withParsing` flag.\n *\n * @param {WPBlock[]} blocks      Block objects.\n * @param {?boolean}  withParsing Whether value has to be parsed.\n *\n * @return {Array<number,string>} Column widths.\n */\nexport function getWidths( blocks, withParsing = true ) {\n\treturn blocks.map( ( innerColumn ) => {\n\t\tconst innerColumnWidth =\n\t\t\tinnerColumn.attributes.width || 100 / blocks.length;\n\n\t\treturn withParsing ? parseFloat( innerColumnWidth ) : innerColumnWidth;\n\t} );\n}\n\n/**\n * Returns a column width with unit.\n *\n * @param {string} width Column width.\n * @param {string} unit  Column width unit.\n *\n * @return {string} Column width with unit.\n */\nexport function getWidthWithUnit( width, unit ) {\n\twidth = 0 > parseFloat( width ) ? '0' : width;\n\n\tif ( isPercentageUnit( unit ) ) {\n\t\twidth = Math.min( width, 100 );\n\t}\n\n\treturn `${ width }${ unit }`;\n}\n\n/**\n * Returns a boolean whether passed unit is percentage\n *\n * @param {string} unit Column width unit.\n *\n * @return {boolean} \tWhether unit is '%'.\n */\nexport function isPercentageUnit( unit ) {\n\treturn unit === '%';\n}\n"]}