{"version":3,"sources":["@wordpress/block-library/src/table/state.js"],"names":["INHERITED_COLUMN_ATTRIBUTES","createTable","rowCount","columnCount","body","Array","from","length","map","cells","content","tag","getFirstRow","state","isEmptyTableSection","head","foot","getCellAttribute","cellLocation","attributeName","sectionName","rowIndex","columnIndex","updateSelectedCell","selection","updateCell","tableSections","Object","fromEntries","entries","filter","key","includes","selectionSectionName","selectionRowIndex","section","row","cellAttributes","isCellSelected","type","insertRow","firstRow","cellCount","undefined","slice","_","index","firstCellInColumn","inheritedAttributes","deleteRow","insertColumn","isEmptyRow","deleteColumn","cell","toggleSection","every"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { get, mapValues } from 'lodash';\n\nconst INHERITED_COLUMN_ATTRIBUTES = [ 'align' ];\n\n/**\n * Creates a table state.\n *\n * @param {Object} options\n * @param {number} options.rowCount    Row count for the table to create.\n * @param {number} options.columnCount Column count for the table to create.\n *\n * @return {Object} New table state.\n */\nexport function createTable( { rowCount, columnCount } ) {\n\treturn {\n\t\tbody: Array.from( { length: rowCount } ).map( () => ( {\n\t\t\tcells: Array.from( { length: columnCount } ).map( () => ( {\n\t\t\t\tcontent: '',\n\t\t\t\ttag: 'td',\n\t\t\t} ) ),\n\t\t} ) ),\n\t};\n}\n\n/**\n * Returns the first row in the table.\n *\n * @param {Object} state Current table state.\n *\n * @return {Object | undefined} The first table row.\n */\nexport function getFirstRow( state ) {\n\tif ( ! isEmptyTableSection( state.head ) ) {\n\t\treturn state.head[ 0 ];\n\t}\n\tif ( ! isEmptyTableSection( state.body ) ) {\n\t\treturn state.body[ 0 ];\n\t}\n\tif ( ! isEmptyTableSection( state.foot ) ) {\n\t\treturn state.foot[ 0 ];\n\t}\n}\n\n/**\n * Gets an attribute for a cell.\n *\n * @param {Object} state         Current table state.\n * @param {Object} cellLocation  The location of the cell\n * @param {string} attributeName The name of the attribute to get the value of.\n *\n * @return {*} The attribute value.\n */\nexport function getCellAttribute( state, cellLocation, attributeName ) {\n\tconst { sectionName, rowIndex, columnIndex } = cellLocation;\n\treturn get( state, [\n\t\tsectionName,\n\t\trowIndex,\n\t\t'cells',\n\t\tcolumnIndex,\n\t\tattributeName,\n\t] );\n}\n\n/**\n * Returns updated cell attributes after applying the `updateCell` function to the selection.\n *\n * @param {Object}   state      The block attributes.\n * @param {Object}   selection  The selection of cells to update.\n * @param {Function} updateCell A function to update the selected cell attributes.\n *\n * @return {Object} New table state including the updated cells.\n */\nexport function updateSelectedCell( state, selection, updateCell ) {\n\tif ( ! selection ) {\n\t\treturn state;\n\t}\n\n\tconst tableSections = Object.fromEntries(\n\t\tObject.entries( state ).filter( ( [ key ] ) =>\n\t\t\t[ 'head', 'body', 'foot' ].includes( key )\n\t\t)\n\t);\n\tconst { sectionName: selectionSectionName, rowIndex: selectionRowIndex } =\n\t\tselection;\n\n\treturn mapValues( tableSections, ( section, sectionName ) => {\n\t\tif ( selectionSectionName && selectionSectionName !== sectionName ) {\n\t\t\treturn section;\n\t\t}\n\n\t\treturn section.map( ( row, rowIndex ) => {\n\t\t\tif ( selectionRowIndex && selectionRowIndex !== rowIndex ) {\n\t\t\t\treturn row;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcells: row.cells.map( ( cellAttributes, columnIndex ) => {\n\t\t\t\t\tconst cellLocation = {\n\t\t\t\t\t\tsectionName,\n\t\t\t\t\t\tcolumnIndex,\n\t\t\t\t\t\trowIndex,\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ! isCellSelected( cellLocation, selection ) ) {\n\t\t\t\t\t\treturn cellAttributes;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updateCell( cellAttributes );\n\t\t\t\t} ),\n\t\t\t};\n\t\t} );\n\t} );\n}\n\n/**\n * Returns whether the cell at `cellLocation` is included in the selection `selection`.\n *\n * @param {Object} cellLocation An object containing cell location properties.\n * @param {Object} selection    An object containing selection properties.\n *\n * @return {boolean} True if the cell is selected, false otherwise.\n */\nexport function isCellSelected( cellLocation, selection ) {\n\tif ( ! cellLocation || ! selection ) {\n\t\treturn false;\n\t}\n\n\tswitch ( selection.type ) {\n\t\tcase 'column':\n\t\t\treturn (\n\t\t\t\tselection.type === 'column' &&\n\t\t\t\tcellLocation.columnIndex === selection.columnIndex\n\t\t\t);\n\t\tcase 'cell':\n\t\t\treturn (\n\t\t\t\tselection.type === 'cell' &&\n\t\t\t\tcellLocation.sectionName === selection.sectionName &&\n\t\t\t\tcellLocation.columnIndex === selection.columnIndex &&\n\t\t\t\tcellLocation.rowIndex === selection.rowIndex\n\t\t\t);\n\t}\n}\n\n/**\n * Inserts a row in the table state.\n *\n * @param {Object} state               Current table state.\n * @param {Object} options\n * @param {string} options.sectionName Section in which to insert the row.\n * @param {number} options.rowIndex    Row index at which to insert the row.\n * @param {number} options.columnCount Column count for the table to create.\n *\n * @return {Object} New table state.\n */\nexport function insertRow( state, { sectionName, rowIndex, columnCount } ) {\n\tconst firstRow = getFirstRow( state );\n\tconst cellCount =\n\t\tcolumnCount === undefined\n\t\t\t? get( firstRow, [ 'cells', 'length' ] )\n\t\t\t: columnCount;\n\n\t// Bail early if the function cannot determine how many cells to add.\n\tif ( ! cellCount ) {\n\t\treturn state;\n\t}\n\n\treturn {\n\t\t[ sectionName ]: [\n\t\t\t...state[ sectionName ].slice( 0, rowIndex ),\n\t\t\t{\n\t\t\t\tcells: Array.from( { length: cellCount } ).map(\n\t\t\t\t\t( _, index ) => {\n\t\t\t\t\t\tconst firstCellInColumn = get(\n\t\t\t\t\t\t\tfirstRow,\n\t\t\t\t\t\t\t[ 'cells', index ],\n\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst inheritedAttributes = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries( firstCellInColumn ).filter(\n\t\t\t\t\t\t\t\t( [ key ] ) =>\n\t\t\t\t\t\t\t\t\tINHERITED_COLUMN_ATTRIBUTES.includes( key )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...inheritedAttributes,\n\t\t\t\t\t\t\tcontent: '',\n\t\t\t\t\t\t\ttag: sectionName === 'head' ? 'th' : 'td',\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t},\n\t\t\t...state[ sectionName ].slice( rowIndex ),\n\t\t],\n\t};\n}\n\n/**\n * Deletes a row from the table state.\n *\n * @param {Object} state               Current table state.\n * @param {Object} options\n * @param {string} options.sectionName Section in which to delete the row.\n * @param {number} options.rowIndex    Row index to delete.\n *\n * @return {Object} New table state.\n */\nexport function deleteRow( state, { sectionName, rowIndex } ) {\n\treturn {\n\t\t[ sectionName ]: state[ sectionName ].filter(\n\t\t\t( row, index ) => index !== rowIndex\n\t\t),\n\t};\n}\n\n/**\n * Inserts a column in the table state.\n *\n * @param {Object} state               Current table state.\n * @param {Object} options\n * @param {number} options.columnIndex Column index at which to insert the column.\n *\n * @return {Object} New table state.\n */\nexport function insertColumn( state, { columnIndex } ) {\n\tconst tableSections = Object.fromEntries(\n\t\tObject.entries( state ).filter( ( [ key ] ) =>\n\t\t\t[ 'head', 'body', 'foot' ].includes( key )\n\t\t)\n\t);\n\n\treturn mapValues( tableSections, ( section, sectionName ) => {\n\t\t// Bail early if the table section is empty.\n\t\tif ( isEmptyTableSection( section ) ) {\n\t\t\treturn section;\n\t\t}\n\n\t\treturn section.map( ( row ) => {\n\t\t\t// Bail early if the row is empty or it's an attempt to insert past\n\t\t\t// the last possible index of the array.\n\t\t\tif ( isEmptyRow( row ) || row.cells.length < columnIndex ) {\n\t\t\t\treturn row;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcells: [\n\t\t\t\t\t...row.cells.slice( 0, columnIndex ),\n\t\t\t\t\t{\n\t\t\t\t\t\tcontent: '',\n\t\t\t\t\t\ttag: sectionName === 'head' ? 'th' : 'td',\n\t\t\t\t\t},\n\t\t\t\t\t...row.cells.slice( columnIndex ),\n\t\t\t\t],\n\t\t\t};\n\t\t} );\n\t} );\n}\n\n/**\n * Deletes a column from the table state.\n *\n * @param {Object} state               Current table state.\n * @param {Object} options\n * @param {number} options.columnIndex Column index to delete.\n *\n * @return {Object} New table state.\n */\nexport function deleteColumn( state, { columnIndex } ) {\n\tconst tableSections = Object.fromEntries(\n\t\tObject.entries( state ).filter( ( [ key ] ) =>\n\t\t\t[ 'head', 'body', 'foot' ].includes( key )\n\t\t)\n\t);\n\n\treturn mapValues( tableSections, ( section ) => {\n\t\t// Bail early if the table section is empty.\n\t\tif ( isEmptyTableSection( section ) ) {\n\t\t\treturn section;\n\t\t}\n\n\t\treturn section\n\t\t\t.map( ( row ) => ( {\n\t\t\t\tcells:\n\t\t\t\t\trow.cells.length >= columnIndex\n\t\t\t\t\t\t? row.cells.filter(\n\t\t\t\t\t\t\t\t( cell, index ) => index !== columnIndex\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t: row.cells,\n\t\t\t} ) )\n\t\t\t.filter( ( row ) => row.cells.length );\n\t} );\n}\n\n/**\n * Toggles the existence of a section.\n *\n * @param {Object} state       Current table state.\n * @param {string} sectionName Name of the section to toggle.\n *\n * @return {Object} New table state.\n */\nexport function toggleSection( state, sectionName ) {\n\t// Section exists, replace it with an empty row to remove it.\n\tif ( ! isEmptyTableSection( state[ sectionName ] ) ) {\n\t\treturn { [ sectionName ]: [] };\n\t}\n\n\t// Get the length of the first row of the body to use when creating the header.\n\tconst columnCount = get( state, [ 'body', 0, 'cells', 'length' ], 1 );\n\n\t// Section doesn't exist, insert an empty row to create the section.\n\treturn insertRow( state, { sectionName, rowIndex: 0, columnCount } );\n}\n\n/**\n * Determines whether a table section is empty.\n *\n * @param {Object} section Table section state.\n *\n * @return {boolean} True if the table section is empty, false otherwise.\n */\nexport function isEmptyTableSection( section ) {\n\treturn ! section || ! section.length || section.every( isEmptyRow );\n}\n\n/**\n * Determines whether a table row is empty.\n *\n * @param {Object} row Table row state.\n *\n * @return {boolean} True if the table section is empty, false otherwise.\n */\nexport function isEmptyRow( row ) {\n\treturn ! ( row.cells && row.cells.length );\n}\n"]}