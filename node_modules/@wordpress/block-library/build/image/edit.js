"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageEdit = ImageEdit;
exports.pickRelevantMediaFiles = exports.isExternalImage = exports.default = void 0;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _lodash = require("lodash");

var _blob = require("@wordpress/blob");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _blockEditor = require("@wordpress/block-editor");

var _i18n = require("@wordpress/i18n");

var _icons = require("@wordpress/icons");

var _notices = require("@wordpress/notices");

var _image = _interopRequireDefault(require("./image"));

var _constants = require("./constants");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
// Much of this description is duplicated from MediaPlaceholder.
const placeholder = content => {
  return (0, _element.createElement)(_components.Placeholder, {
    className: "block-editor-media-placeholder",
    withIllustration: true,
    icon: _icons.image,
    label: (0, _i18n.__)('Image'),
    instructions: (0, _i18n.__)('Upload an image file, pick one from your media library, or add one with a URL.')
  }, content);
};
/**
 * Module constants
 */


const pickRelevantMediaFiles = (image, size) => {
  var _image$sizes, _image$sizes$size, _image$media_details, _image$media_details$, _image$media_details$2;

  const imageProps = Object.fromEntries(Object.entries(image !== null && image !== void 0 ? image : {}).filter(_ref => {
    let [key] = _ref;
    return ['alt', 'id', 'link', 'caption'].includes(key);
  }));
  imageProps.url = (image === null || image === void 0 ? void 0 : (_image$sizes = image.sizes) === null || _image$sizes === void 0 ? void 0 : (_image$sizes$size = _image$sizes[size]) === null || _image$sizes$size === void 0 ? void 0 : _image$sizes$size.url) || (image === null || image === void 0 ? void 0 : (_image$media_details = image.media_details) === null || _image$media_details === void 0 ? void 0 : (_image$media_details$ = _image$media_details.sizes) === null || _image$media_details$ === void 0 ? void 0 : (_image$media_details$2 = _image$media_details$[size]) === null || _image$media_details$2 === void 0 ? void 0 : _image$media_details$2.source_url) || image.url;
  return imageProps;
};
/**
 * Is the URL a temporary blob URL? A blob URL is one that is used temporarily
 * while the image is being uploaded and will not have an id yet allocated.
 *
 * @param {number=} id  The id of the image.
 * @param {string=} url The url of the image.
 *
 * @return {boolean} Is the URL a Blob URL
 */


exports.pickRelevantMediaFiles = pickRelevantMediaFiles;

const isTemporaryImage = (id, url) => !id && (0, _blob.isBlobURL)(url);
/**
 * Is the url for the image hosted externally. An externally hosted image has no
 * id and is not a blob url.
 *
 * @param {number=} id  The id of the image.
 * @param {string=} url The url of the image.
 *
 * @return {boolean} Is the url an externally hosted url?
 */


const isExternalImage = (id, url) => url && !id && !(0, _blob.isBlobURL)(url);
/**
 * Checks if WP generated default image size. Size generation is skipped
 * when the image is smaller than the said size.
 *
 * @param {Object} image
 * @param {string} defaultSize
 *
 * @return {boolean} Whether or not it has default image size.
 */


exports.isExternalImage = isExternalImage;

function hasDefaultSize(image, defaultSize) {
  var _image$sizes$defaultS, _image$sizes2, _image$media_details$3, _image$media_details2, _image$media_details3;

  return 'url' in ((_image$sizes$defaultS = image === null || image === void 0 ? void 0 : (_image$sizes2 = image.sizes) === null || _image$sizes2 === void 0 ? void 0 : _image$sizes2[defaultSize]) !== null && _image$sizes$defaultS !== void 0 ? _image$sizes$defaultS : {}) || 'source_url' in ((_image$media_details$3 = image === null || image === void 0 ? void 0 : (_image$media_details2 = image.media_details) === null || _image$media_details2 === void 0 ? void 0 : (_image$media_details3 = _image$media_details2.sizes) === null || _image$media_details3 === void 0 ? void 0 : _image$media_details3[defaultSize]) !== null && _image$media_details$3 !== void 0 ? _image$media_details$3 : {});
}

function ImageEdit(_ref2) {
  let {
    attributes,
    setAttributes,
    isSelected,
    className,
    insertBlocksAfter,
    onReplace,
    context,
    clientId
  } = _ref2;
  const {
    url = '',
    alt,
    caption,
    align,
    id,
    width,
    height,
    sizeSlug
  } = attributes;
  const [temporaryURL, setTemporaryURL] = (0, _element.useState)();
  const altRef = (0, _element.useRef)();
  (0, _element.useEffect)(() => {
    altRef.current = alt;
  }, [alt]);
  const captionRef = (0, _element.useRef)();
  (0, _element.useEffect)(() => {
    captionRef.current = caption;
  }, [caption]);
  const ref = (0, _element.useRef)();
  const {
    imageDefaultSize,
    mediaUpload,
    isContentLocked
  } = (0, _data.useSelect)(select => {
    const {
      getSettings,
      __unstableGetContentLockingParent
    } = select(_blockEditor.store);
    const settings = getSettings();
    return {
      imageDefaultSize: settings.imageDefaultSize,
      mediaUpload: settings.mediaUpload,
      isContentLocked: !!__unstableGetContentLockingParent(clientId)
    };
  }, []);
  const {
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);

  function onUploadError(message) {
    createErrorNotice(message, {
      type: 'snackbar'
    });
    setAttributes({
      src: undefined,
      id: undefined,
      url: undefined
    });
    setTemporaryURL(undefined);
  }

  function onSelectImage(media) {
    var _window, _window$wp, _window$wp$media, _window$wp$media$view, _window$wp$media$view2, _window$wp$media$view3;

    if (!media || !media.url) {
      setAttributes({
        url: undefined,
        alt: undefined,
        id: undefined,
        title: undefined,
        caption: undefined
      });
      return;
    }

    if ((0, _blob.isBlobURL)(media.url)) {
      setTemporaryURL(media.url);
      return;
    }

    setTemporaryURL();
    let mediaAttributes = pickRelevantMediaFiles(media, imageDefaultSize); // If a caption text was meanwhile written by the user,
    // make sure the text is not overwritten by empty captions.

    if (captionRef.current && !mediaAttributes.caption) {
      const {
        caption: omittedCaption,
        ...restMediaAttributes
      } = mediaAttributes;
      mediaAttributes = restMediaAttributes;
    }

    let additionalAttributes; // Reset the dimension attributes if changing to a different image.

    if (!media.id || media.id !== id) {
      additionalAttributes = {
        width: undefined,
        height: undefined,
        // Fallback to size "full" if there's no default image size.
        // It means the image is smaller, and the block will use a full-size URL.
        sizeSlug: hasDefaultSize(media, imageDefaultSize) ? imageDefaultSize : 'full'
      };
    } else {
      // Keep the same url when selecting the same file, so "Image Size"
      // option is not changed.
      additionalAttributes = {
        url
      };
    } // Check if default link setting should be used.


    let linkDestination = attributes.linkDestination;

    if (!linkDestination) {
      // Use the WordPress option to determine the proper default.
      // The constants used in Gutenberg do not match WP options so a little more complicated than ideal.
      // TODO: fix this in a follow up PR, requires updating media-text and ui component.
      switch (((_window = window) === null || _window === void 0 ? void 0 : (_window$wp = _window.wp) === null || _window$wp === void 0 ? void 0 : (_window$wp$media = _window$wp.media) === null || _window$wp$media === void 0 ? void 0 : (_window$wp$media$view = _window$wp$media.view) === null || _window$wp$media$view === void 0 ? void 0 : (_window$wp$media$view2 = _window$wp$media$view.settings) === null || _window$wp$media$view2 === void 0 ? void 0 : (_window$wp$media$view3 = _window$wp$media$view2.defaultProps) === null || _window$wp$media$view3 === void 0 ? void 0 : _window$wp$media$view3.link) || _constants.LINK_DESTINATION_NONE) {
        case 'file':
        case _constants.LINK_DESTINATION_MEDIA:
          linkDestination = _constants.LINK_DESTINATION_MEDIA;
          break;

        case 'post':
        case _constants.LINK_DESTINATION_ATTACHMENT:
          linkDestination = _constants.LINK_DESTINATION_ATTACHMENT;
          break;

        case _constants.LINK_DESTINATION_CUSTOM:
          linkDestination = _constants.LINK_DESTINATION_CUSTOM;
          break;

        case _constants.LINK_DESTINATION_NONE:
          linkDestination = _constants.LINK_DESTINATION_NONE;
          break;
      }
    } // Check if the image is linked to it's media.


    let href;

    switch (linkDestination) {
      case _constants.LINK_DESTINATION_MEDIA:
        href = media.url;
        break;

      case _constants.LINK_DESTINATION_ATTACHMENT:
        href = media.link;
        break;
    }

    mediaAttributes.href = href;
    setAttributes({ ...mediaAttributes,
      ...additionalAttributes,
      linkDestination
    });
  }

  function onSelectURL(newURL) {
    if (newURL !== url) {
      setAttributes({
        url: newURL,
        id: undefined,
        width: undefined,
        height: undefined,
        sizeSlug: imageDefaultSize
      });
    }
  }

  function updateAlignment(nextAlign) {
    const extraUpdatedAttributes = ['wide', 'full'].includes(nextAlign) ? {
      width: undefined,
      height: undefined
    } : {};
    setAttributes({ ...extraUpdatedAttributes,
      align: nextAlign
    });
  }

  let isTemp = isTemporaryImage(id, url); // Upload a temporary image on mount.

  (0, _element.useEffect)(() => {
    if (!isTemp) {
      return;
    }

    const file = (0, _blob.getBlobByURL)(url);

    if (file) {
      mediaUpload({
        filesList: [file],
        onFileChange: _ref3 => {
          let [img] = _ref3;
          onSelectImage(img);
        },
        allowedTypes: _constants.ALLOWED_MEDIA_TYPES,
        onError: message => {
          isTemp = false;
          onUploadError(message);
        }
      });
    }
  }, []); // If an image is temporary, revoke the Blob url when it is uploaded (and is
  // no longer temporary).

  (0, _element.useEffect)(() => {
    if (isTemp) {
      setTemporaryURL(url);
      return;
    }

    (0, _blob.revokeBlobURL)(temporaryURL);
  }, [isTemp, url]);
  const isExternal = isExternalImage(id, url);
  const src = isExternal ? url : undefined;
  const mediaPreview = !!url && (0, _element.createElement)("img", {
    alt: (0, _i18n.__)('Edit image'),
    title: (0, _i18n.__)('Edit image'),
    className: 'edit-image-preview',
    src: url
  });
  const borderProps = (0, _blockEditor.__experimentalUseBorderProps)(attributes);
  const classes = (0, _classnames.default)(className, {
    'is-transient': temporaryURL,
    'is-resized': !!width || !!height,
    [`size-${sizeSlug}`]: sizeSlug,
    'has-custom-border': !!borderProps.className || !(0, _lodash.isEmpty)(borderProps.style)
  });
  const blockProps = (0, _blockEditor.useBlockProps)({
    ref,
    className: classes
  });
  return (0, _element.createElement)("figure", blockProps, (temporaryURL || url) && (0, _element.createElement)(_image.default, {
    temporaryURL: temporaryURL,
    attributes: attributes,
    setAttributes: setAttributes,
    isSelected: isSelected,
    insertBlocksAfter: insertBlocksAfter,
    onReplace: onReplace,
    onSelectImage: onSelectImage,
    onSelectURL: onSelectURL,
    onUploadError: onUploadError,
    containerRef: ref,
    context: context,
    clientId: clientId,
    isContentLocked: isContentLocked
  }), !url && !isContentLocked && (0, _element.createElement)(_blockEditor.BlockControls, {
    group: "block"
  }, (0, _element.createElement)(_blockEditor.BlockAlignmentControl, {
    value: align,
    onChange: updateAlignment
  })), (0, _element.createElement)(_blockEditor.MediaPlaceholder, {
    icon: (0, _element.createElement)(_blockEditor.BlockIcon, {
      icon: _icons.image
    }),
    onSelect: onSelectImage,
    onSelectURL: onSelectURL,
    onError: onUploadError,
    placeholder: placeholder,
    accept: "image/*",
    allowedTypes: _constants.ALLOWED_MEDIA_TYPES,
    value: {
      id,
      src
    },
    mediaPreview: mediaPreview,
    disableMediaButtons: temporaryURL || url
  }));
}

var _default = ImageEdit;
exports.default = _default;
//# sourceMappingURL=edit.js.map