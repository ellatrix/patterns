"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _blockEditor = require("@wordpress/block-editor");

var _keycodes = require("@wordpress/keycodes");

var _icons = require("@wordpress/icons");

var _blocks = require("@wordpress/blocks");

var _compose = require("@wordpress/compose");

var _url = require("@wordpress/url");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */
const NEW_TAB_REL = 'noreferrer noopener';

function WidthPanel(_ref) {
  let {
    selectedWidth,
    setAttributes
  } = _ref;

  function handleChange(newWidth) {
    // Check if we are toggling the width off
    const width = selectedWidth === newWidth ? undefined : newWidth; // Update attributes.

    setAttributes({
      width
    });
  }

  return (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Width settings')
  }, (0, _element.createElement)(_components.ButtonGroup, {
    "aria-label": (0, _i18n.__)('Button width')
  }, [25, 50, 75, 100].map(widthValue => {
    return (0, _element.createElement)(_components.Button, {
      key: widthValue,
      isSmall: true,
      variant: widthValue === selectedWidth ? 'primary' : undefined,
      onClick: () => handleChange(widthValue)
    }, widthValue, "%");
  })));
}

function ButtonEdit(props) {
  var _style$border;

  const {
    attributes,
    setAttributes,
    className,
    isSelected,
    onReplace,
    mergeBlocks
  } = props;
  const {
    textAlign,
    linkTarget,
    placeholder,
    rel,
    style,
    text,
    url,
    width
  } = attributes;

  function onToggleOpenInNewTab(value) {
    const newLinkTarget = value ? '_blank' : undefined;
    let updatedRel = rel;

    if (newLinkTarget && !rel) {
      updatedRel = NEW_TAB_REL;
    } else if (!newLinkTarget && rel === NEW_TAB_REL) {
      updatedRel = undefined;
    }

    setAttributes({
      linkTarget: newLinkTarget,
      rel: updatedRel
    });
  }

  function setButtonText(newText) {
    // Remove anchor tags from button text content.
    setAttributes({
      text: newText.replace(/<\/?a[^>]*>/g, '')
    });
  }

  function onKeyDown(event) {
    if (_keycodes.isKeyboardEvent.primary(event, 'k')) {
      startEditing(event);
    } else if (_keycodes.isKeyboardEvent.primaryShift(event, 'k')) {
      var _richTextRef$current;

      unlink();
      (_richTextRef$current = richTextRef.current) === null || _richTextRef$current === void 0 ? void 0 : _richTextRef$current.focus();
    }
  } // Use internal state instead of a ref to make sure that the component
  // re-renders when the popover's anchor updates.


  const [popoverAnchor, setPopoverAnchor] = (0, _element.useState)(null);
  const borderProps = (0, _blockEditor.__experimentalUseBorderProps)(attributes);
  const colorProps = (0, _blockEditor.__experimentalUseColorProps)(attributes);
  const spacingProps = (0, _blockEditor.__experimentalGetSpacingClassesAndStyles)(attributes);
  const ref = (0, _element.useRef)();
  const richTextRef = (0, _element.useRef)();
  const blockProps = (0, _blockEditor.useBlockProps)({
    ref: (0, _compose.useMergeRefs)([setPopoverAnchor, ref]),
    onKeyDown
  });
  const [isEditingURL, setIsEditingURL] = (0, _element.useState)(false);
  const isURLSet = !!url;
  const opensInNewTab = linkTarget === '_blank';

  function startEditing(event) {
    event.preventDefault();
    setIsEditingURL(true);
  }

  function unlink() {
    setAttributes({
      url: undefined,
      linkTarget: undefined,
      rel: undefined
    });
    setIsEditingURL(false);
  }

  (0, _element.useEffect)(() => {
    if (!isSelected) {
      setIsEditingURL(false);
    }
  }, [isSelected]);
  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("div", (0, _extends2.default)({}, blockProps, {
    className: (0, _classnames.default)(blockProps.className, {
      [`has-custom-width wp-block-button__width-${width}`]: width,
      [`has-custom-font-size`]: blockProps.style.fontSize
    })
  }), (0, _element.createElement)(_blockEditor.RichText, {
    ref: richTextRef,
    "aria-label": (0, _i18n.__)('Button text'),
    placeholder: placeholder || (0, _i18n.__)('Add textâ€¦'),
    value: text,
    onChange: value => setButtonText(value),
    withoutInteractiveFormatting: true,
    className: (0, _classnames.default)(className, 'wp-block-button__link', colorProps.className, borderProps.className, {
      [`has-text-align-${textAlign}`]: textAlign,
      // For backwards compatibility add style that isn't
      // provided via block support.
      'no-border-radius': (style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.radius) === 0
    }, (0, _blockEditor.__experimentalGetElementClassName)('button')),
    style: { ...borderProps.style,
      ...colorProps.style,
      ...spacingProps.style
    },
    onSplit: value => (0, _blocks.createBlock)('core/button', { ...attributes,
      text: value
    }),
    onReplace: onReplace,
    onMerge: mergeBlocks,
    identifier: "text"
  })), (0, _element.createElement)(_blockEditor.BlockControls, {
    group: "block"
  }, (0, _element.createElement)(_blockEditor.AlignmentControl, {
    value: textAlign,
    onChange: nextAlign => {
      setAttributes({
        textAlign: nextAlign
      });
    }
  }), !isURLSet && (0, _element.createElement)(_components.ToolbarButton, {
    name: "link",
    icon: _icons.link,
    title: (0, _i18n.__)('Link'),
    shortcut: _keycodes.displayShortcut.primary('k'),
    onClick: startEditing
  }), isURLSet && (0, _element.createElement)(_components.ToolbarButton, {
    name: "link",
    icon: _icons.linkOff,
    title: (0, _i18n.__)('Unlink'),
    shortcut: _keycodes.displayShortcut.primaryShift('k'),
    onClick: unlink,
    isActive: true
  })), isSelected && (isEditingURL || isURLSet) && (0, _element.createElement)(_components.Popover, {
    placement: "bottom",
    onClose: () => {
      var _richTextRef$current2;

      setIsEditingURL(false);
      (_richTextRef$current2 = richTextRef.current) === null || _richTextRef$current2 === void 0 ? void 0 : _richTextRef$current2.focus();
    },
    anchor: popoverAnchor,
    focusOnMount: isEditingURL ? 'firstElement' : false,
    __unstableSlotName: '__unstable-block-tools-after',
    shift: true
  }, (0, _element.createElement)(_blockEditor.__experimentalLinkControl, {
    className: "wp-block-navigation-link__inline-link-input",
    value: {
      url,
      opensInNewTab
    },
    onChange: _ref2 => {
      let {
        url: newURL = '',
        opensInNewTab: newOpensInNewTab
      } = _ref2;
      setAttributes({
        url: (0, _url.prependHTTP)(newURL)
      });

      if (opensInNewTab !== newOpensInNewTab) {
        onToggleOpenInNewTab(newOpensInNewTab);
      }
    },
    onRemove: () => {
      var _richTextRef$current3;

      unlink();
      (_richTextRef$current3 = richTextRef.current) === null || _richTextRef$current3 === void 0 ? void 0 : _richTextRef$current3.focus();
    },
    forceIsEditingLink: isEditingURL
  })), (0, _element.createElement)(_blockEditor.InspectorControls, null, (0, _element.createElement)(WidthPanel, {
    selectedWidth: width,
    setAttributes: setAttributes
  })), (0, _element.createElement)(_blockEditor.InspectorControls, {
    group: "advanced"
  }, (0, _element.createElement)(_components.TextControl, {
    __nextHasNoMarginBottom: true,
    label: (0, _i18n.__)('Link rel'),
    value: rel || '',
    onChange: newRel => setAttributes({
      rel: newRel
    })
  })));
}

var _default = ButtonEdit;
exports.default = _default;
//# sourceMappingURL=edit.js.map