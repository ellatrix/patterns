"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _blockEditor = require("@wordpress/block-editor");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * @param {Object} attributes Block's attributes.
 */
const migrateWithLayout = attributes => {
  if (!!attributes.layout) {
    return attributes;
  }

  const {
    contentJustification,
    orientation,
    ...updatedAttributes
  } = attributes;

  if (contentJustification || orientation) {
    Object.assign(updatedAttributes, {
      layout: {
        type: 'flex',
        ...(contentJustification && {
          justifyContent: contentJustification
        }),
        ...(orientation && {
          orientation
        })
      }
    });
  }

  return updatedAttributes;
};

const deprecated = [{
  attributes: {
    contentJustification: {
      type: 'string'
    },
    orientation: {
      type: 'string',
      default: 'horizontal'
    }
  },
  supports: {
    anchor: true,
    align: ['wide', 'full'],
    __experimentalExposeControlsToChildren: true,
    spacing: {
      blockGap: true,
      margin: ['top', 'bottom'],
      __experimentalDefaultControls: {
        blockGap: true
      }
    }
  },
  isEligible: _ref => {
    let {
      contentJustification,
      orientation
    } = _ref;
    return !!contentJustification || !!orientation;
  },
  migrate: migrateWithLayout,

  save(_ref2) {
    let {
      attributes: {
        contentJustification,
        orientation
      }
    } = _ref2;
    return (0, _element.createElement)("div", _blockEditor.useBlockProps.save({
      className: (0, _classnames.default)({
        [`is-content-justification-${contentJustification}`]: contentJustification,
        'is-vertical': orientation === 'vertical'
      })
    }), (0, _element.createElement)(_blockEditor.InnerBlocks.Content, null));
  }

}, {
  supports: {
    align: ['center', 'left', 'right'],
    anchor: true
  },

  save() {
    return (0, _element.createElement)("div", null, (0, _element.createElement)(_blockEditor.InnerBlocks.Content, null));
  },

  isEligible(_ref3) {
    let {
      align
    } = _ref3;
    return align && ['center', 'left', 'right'].includes(align);
  },

  migrate(attributes) {
    return migrateWithLayout({ ...attributes,
      align: undefined,
      // Floating Buttons blocks shouldn't have been supported in the
      // first place. Most users using them probably expected them to
      // act like content justification controls, so these blocks are
      // migrated to use content justification.
      // As for center-aligned Buttons blocks, the content justification
      // equivalent will create an identical end result in most cases.
      contentJustification: attributes.align
    });
  }

}];
var _default = deprecated;
exports.default = _default;
//# sourceMappingURL=deprecated.js.map