"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useMerge;

var _data = require("@wordpress/data");

var _blockEditor = require("@wordpress/block-editor");

var _useOutdentListItem = _interopRequireDefault(require("./use-outdent-list-item"));

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const {
  name: listItemName
} = {
  $schema: "https://schemas.wp.org/trunk/block.json",
  apiVersion: 2,
  name: "core/list-item",
  title: "List item",
  category: "text",
  parent: ["core/list"],
  description: "Create a list item.",
  textdomain: "default",
  attributes: {
    placeholder: {
      type: "string"
    },
    content: {
      type: "string",
      source: "html",
      selector: "li",
      "default": "",
      __experimentalRole: "content"
    }
  },
  supports: {
    className: false,
    __experimentalSelector: "li",
    typography: {
      fontSize: true,
      lineHeight: true,
      __experimentalFontFamily: true,
      __experimentalFontWeight: true,
      __experimentalFontStyle: true,
      __experimentalTextTransform: true,
      __experimentalTextDecoration: true,
      __experimentalLetterSpacing: true,
      __experimentalDefaultControls: {
        fontSize: true
      }
    }
  }
};

function useMerge(clientId, onMerge) {
  const registry = (0, _data.useRegistry)();
  const {
    getPreviousBlockClientId,
    getNextBlockClientId,
    getBlockOrder,
    getBlockRootClientId,
    getBlockName
  } = (0, _data.useSelect)(_blockEditor.store);
  const {
    mergeBlocks,
    moveBlocksToPosition
  } = (0, _data.useDispatch)(_blockEditor.store);
  const [, outdentListItem] = (0, _useOutdentListItem.default)(clientId);

  function getTrailingId(id) {
    const order = getBlockOrder(id);

    if (!order.length) {
      return id;
    }

    return getTrailingId(order[order.length - 1]);
  }

  function getParentListItemId(id) {
    const listId = getBlockRootClientId(id);
    const parentListItemId = getBlockRootClientId(listId);
    if (!parentListItemId) return;
    if (getBlockName(parentListItemId) !== listItemName) return;
    return parentListItemId;
  }
  /**
   * Return the next list item with respect to the given list item. If none,
   * return the next list item of the parent list item if it exists.
   *
   * @param {string} id A list item client ID.
   * @return {string?} The client ID of the next list item.
   */


  function _getNextId(id) {
    const next = getNextBlockClientId(id);
    if (next) return next;
    const parentListItemId = getParentListItemId(id);
    if (!parentListItemId) return;
    return _getNextId(parentListItemId);
  }
  /**
   * Given a client ID, return the client ID of the list item on the next
   * line, regardless of indentation level.
   *
   * @param {string} id The client ID of the current list item.
   * @return {string?} The client ID of the next list item.
   */


  function getNextId(id) {
    const order = getBlockOrder(id); // If the list item does not have a nested list, return the next list
    // item.

    if (!order.length) {
      return _getNextId(id);
    } // Get the first list item in the nested list.


    return getBlockOrder(order[0])[0];
  }

  return forward => {
    if (forward) {
      const nextBlockClientId = getNextId(clientId);

      if (!nextBlockClientId) {
        onMerge(forward);
        return;
      }

      if (getParentListItemId(nextBlockClientId)) {
        outdentListItem(nextBlockClientId);
      } else {
        registry.batch(() => {
          moveBlocksToPosition(getBlockOrder(nextBlockClientId), nextBlockClientId, getPreviousBlockClientId(nextBlockClientId));
          mergeBlocks(clientId, nextBlockClientId);
        });
      }
    } else {
      // Merging is only done from the top level. For lowel levels, the
      // list item is outdented instead.
      const previousBlockClientId = getPreviousBlockClientId(clientId);

      if (getParentListItemId(clientId)) {
        outdentListItem(clientId);
      } else if (previousBlockClientId) {
        const trailingId = getTrailingId(previousBlockClientId);
        registry.batch(() => {
          moveBlocksToPosition(getBlockOrder(clientId), clientId, previousBlockClientId);
          mergeBlocks(trailingId, clientId);
        });
      } else {
        onMerge(forward);
      }
    }
  };
}
//# sourceMappingURL=use-merge.js.map