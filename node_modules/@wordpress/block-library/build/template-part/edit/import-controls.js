"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplatePartImportControls = TemplatePartImportControls;

var _element = require("@wordpress/element");

var _i18n = require("@wordpress/i18n");

var _data = require("@wordpress/data");

var _components = require("@wordpress/components");

var _blocks = require("@wordpress/blocks");

var _coreData = require("@wordpress/core-data");

var _notices = require("@wordpress/notices");

var _hooks = require("./utils/hooks");

var _transformers = require("./utils/transformers");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const SIDEBARS_QUERY = {
  per_page: -1,
  _fields: 'id,name,description,status,widgets'
};

function TemplatePartImportControls(_ref) {
  let {
    area,
    setAttributes
  } = _ref;
  const [selectedSidebar, setSelectedSidebar] = (0, _element.useState)('');
  const [isBusy, setIsBusy] = (0, _element.useState)(false);
  const registry = (0, _data.useRegistry)();
  const {
    sidebars,
    hasResolved
  } = (0, _data.useSelect)(select => {
    const {
      getSidebars,
      hasFinishedResolution
    } = select(_coreData.store);
    return {
      sidebars: getSidebars(SIDEBARS_QUERY),
      hasResolved: hasFinishedResolution('getSidebars', [SIDEBARS_QUERY])
    };
  }, []);
  const {
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);
  const createFromBlocks = (0, _hooks.useCreateTemplatePartFromBlocks)(area, setAttributes);
  const options = (0, _element.useMemo)(() => {
    const sidebarOptions = (sidebars !== null && sidebars !== void 0 ? sidebars : []).filter(widgetArea => widgetArea.id !== 'wp_inactive_widgets' && widgetArea.widgets.length > 0).map(widgetArea => {
      return {
        value: widgetArea.id,
        label: widgetArea.name
      };
    });

    if (!sidebarOptions.length) {
      return [];
    }

    return [{
      value: '',
      label: (0, _i18n.__)('Select widget area')
    }, ...sidebarOptions];
  }, [sidebars]); // Render an empty node while data is loading to avoid SlotFill re-positioning bug.
  // See: https://github.com/WordPress/gutenberg/issues/15641.

  if (!hasResolved) {
    return (0, _element.createElement)(_components.__experimentalSpacer, {
      marginBottom: "0"
    });
  }

  if (hasResolved && !options.length) {
    return null;
  }

  async function createFromWidgets(event) {
    event.preventDefault();

    if (isBusy || !selectedSidebar) {
      return;
    }

    setIsBusy(true);
    const sidebar = options.find(_ref2 => {
      let {
        value
      } = _ref2;
      return value === selectedSidebar;
    });
    const {
      getWidgets
    } = registry.resolveSelect(_coreData.store); // The widgets API always returns a successful response.

    const widgets = await getWidgets({
      sidebar: sidebar.value,
      _embed: 'about'
    });
    const skippedWidgets = new Set();
    const blocks = widgets.flatMap(widget => {
      const block = (0, _transformers.transformWidgetToBlock)(widget);

      if (block.name !== 'core/legacy-widget') {
        return block;
      }

      const transforms = (0, _blocks.getPossibleBlockTransformations)([block]).filter(item => {
        var _item$transforms, _item$transforms$from, _item$transforms2, _item$transforms2$to;

        // The block without any transformations can't be a wildcard.
        if (!item.transforms) {
          return true;
        }

        const hasWildCardFrom = (_item$transforms = item.transforms) === null || _item$transforms === void 0 ? void 0 : (_item$transforms$from = _item$transforms.from) === null || _item$transforms$from === void 0 ? void 0 : _item$transforms$from.find(from => from.blocks && from.blocks.includes('*'));
        const hasWildCardTo = (_item$transforms2 = item.transforms) === null || _item$transforms2 === void 0 ? void 0 : (_item$transforms2$to = _item$transforms2.to) === null || _item$transforms2$to === void 0 ? void 0 : _item$transforms2$to.find(to => to.blocks && to.blocks.includes('*'));
        return !hasWildCardFrom && !hasWildCardTo;
      }); // Skip the block if we have no matching transformations.

      if (!transforms.length) {
        skippedWidgets.add(widget.id_base);
        return [];
      } // Try transforming the Legacy Widget into a first matching block.


      return (0, _blocks.switchToBlockType)(block, transforms[0].name);
    });
    await createFromBlocks(blocks,
    /* translators: %s: name of the widget area */
    (0, _i18n.sprintf)((0, _i18n.__)('Widget area: %s'), sidebar.label));

    if (skippedWidgets.size) {
      createErrorNotice((0, _i18n.sprintf)(
      /* translators: %s: the list of widgets */
      (0, _i18n.__)('Unable to import the following widgets: %s.'), Array.from(skippedWidgets).join(', ')), {
        type: 'snackbar'
      });
    }

    setIsBusy(false);
  }

  return (0, _element.createElement)(_components.__experimentalSpacer, {
    marginBottom: "4"
  }, (0, _element.createElement)(_components.__experimentalHStack, {
    as: "form",
    onSubmit: createFromWidgets
  }, (0, _element.createElement)(_components.FlexBlock, null, (0, _element.createElement)(_components.SelectControl, {
    label: (0, _i18n.__)('Import widget area'),
    value: selectedSidebar,
    options: options,
    onChange: value => setSelectedSidebar(value),
    disabled: !options.length,
    __next36pxDefaultSize: true,
    __nextHasNoMarginBottom: true
  })), (0, _element.createElement)(_components.FlexItem, {
    style: {
      marginBottom: '8px',
      marginTop: 'auto'
    }
  }, (0, _element.createElement)(_components.Button, {
    variant: "primary",
    type: "submit",
    isBusy: isBusy,
    "aria-disabled": isBusy || !selectedSidebar
  }, (0, _i18n.__)('Import')))));
}
//# sourceMappingURL=import-controls.js.map