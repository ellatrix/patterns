{"version":3,"sources":["@wordpress/block-library/src/query/utils.js"],"names":["getEntitiesInfo","entities","mapping","reduce","accumulator","entity","mapById","mapByName","names","id","name","push","mapToIHasNameAndId","path","map","usePostTypes","postTypes","select","getPostTypes","coreStore","excludedPostTypes","filteredPostTypes","per_page","filter","viewable","slug","includes","postTypesTaxonomiesMap","length","type","taxonomies","postTypesSelectOptions","labels","label","singular_name","value","useTaxonomies","postType","getTaxonomies","filteredTaxonomies","context","useIsPostTypeHierarchical","getPostType","hierarchical","useAllowedControls","attributes","blocksStore","getActiveBlockVariation","queryLoopName","allowedControls","isControlAllowed","key","getTransformedBlocksFromPattern","blocks","queryBlockAttributes","query","inherit","clonedBlocks","block","queryClientIds","blocksQueue","shift","clientId","innerBlocks","forEach","innerBlock","newBlocks","useBlockNameForPatterns","activeVariationName","blockName","activeVariationPatterns","getBlockRootClientId","getPatternsByBlockTypes","blockEditorStore","rootClientId","useScopedBlockVariations","blockVariations","getBlockVariations","variations","isNotConnected","variation","namespace","connectedVariations","usePatterns"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { get } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { useSelect } from '@wordpress/data';\nimport { useMemo } from '@wordpress/element';\nimport { store as coreStore } from '@wordpress/core-data';\nimport { store as blockEditorStore } from '@wordpress/block-editor';\nimport { decodeEntities } from '@wordpress/html-entities';\nimport { cloneBlock, store as blocksStore } from '@wordpress/blocks';\n\n/**\n * Internal dependencies\n */\nimport { name as queryLoopName } from './block.json';\n\n/** @typedef {import('@wordpress/blocks').WPBlockVariation} WPBlockVariation */\n\n/**\n * @typedef IHasNameAndId\n * @property {string|number} id   The entity's id.\n * @property {string}        name The entity's name.\n */\n\n/**\n * The object used in Query block that contains info and helper mappings\n * from an array of IHasNameAndId objects.\n *\n * @typedef {Object} QueryEntitiesInfo\n * @property {IHasNameAndId[]}               entities  The array of entities.\n * @property {Object<string, IHasNameAndId>} mapById   Object mapping with the id as key and the entity as value.\n * @property {Object<string, IHasNameAndId>} mapByName Object mapping with the name as key and the entity as value.\n * @property {string[]}                      names     Array with the entities' names.\n */\n\n/**\n * Returns a helper object with mapping from Objects that implement\n * the `IHasNameAndId` interface. The returned object is used for\n * integration with `FormTokenField` component.\n *\n * @param {IHasNameAndId[]} entities The entities to extract of helper object.\n * @return {QueryEntitiesInfo} The object with the entities information.\n */\nexport const getEntitiesInfo = ( entities ) => {\n\tconst mapping = entities?.reduce(\n\t\t( accumulator, entity ) => {\n\t\t\tconst { mapById, mapByName, names } = accumulator;\n\t\t\tmapById[ entity.id ] = entity;\n\t\t\tmapByName[ entity.name ] = entity;\n\t\t\tnames.push( entity.name );\n\t\t\treturn accumulator;\n\t\t},\n\t\t{ mapById: {}, mapByName: {}, names: [] }\n\t);\n\treturn {\n\t\tentities,\n\t\t...mapping,\n\t};\n};\n\n/**\n * Helper util to map records to add a `name` prop from a\n * provided path, in order to handle all entities in the same\n * fashion(implementing`IHasNameAndId` interface).\n *\n * @param {Object[]} entities The array of entities.\n * @param {string}   path     The path to map a `name` property from the entity.\n * @return {IHasNameAndId[]} An array of enitities that now implement the `IHasNameAndId` interface.\n */\nexport const mapToIHasNameAndId = ( entities, path ) => {\n\treturn ( entities || [] ).map( ( entity ) => ( {\n\t\t...entity,\n\t\tname: decodeEntities( get( entity, path ) ),\n\t} ) );\n};\n\n/**\n * Returns a helper object that contains:\n * 1. An `options` object from the available post types, to be passed to a `SelectControl`.\n * 2. A helper map with available taxonomies per post type.\n *\n * @return {Object} The helper object related to post types.\n */\nexport const usePostTypes = () => {\n\tconst postTypes = useSelect( ( select ) => {\n\t\tconst { getPostTypes } = select( coreStore );\n\t\tconst excludedPostTypes = [ 'attachment' ];\n\t\tconst filteredPostTypes = getPostTypes( { per_page: -1 } )?.filter(\n\t\t\t( { viewable, slug } ) =>\n\t\t\t\tviewable && ! excludedPostTypes.includes( slug )\n\t\t);\n\t\treturn filteredPostTypes;\n\t}, [] );\n\tconst postTypesTaxonomiesMap = useMemo( () => {\n\t\tif ( ! postTypes?.length ) return;\n\t\treturn postTypes.reduce( ( accumulator, type ) => {\n\t\t\taccumulator[ type.slug ] = type.taxonomies;\n\t\t\treturn accumulator;\n\t\t}, {} );\n\t}, [ postTypes ] );\n\tconst postTypesSelectOptions = useMemo(\n\t\t() =>\n\t\t\t( postTypes || [] ).map( ( { labels, slug } ) => ( {\n\t\t\t\tlabel: labels.singular_name,\n\t\t\t\tvalue: slug,\n\t\t\t} ) ),\n\t\t[ postTypes ]\n\t);\n\treturn { postTypesTaxonomiesMap, postTypesSelectOptions };\n};\n\n/**\n * Hook that returns the taxonomies associated with a specific post type.\n *\n * @param {string} postType The post type from which to retrieve the associated taxonomies.\n * @return {Object[]} An array of the associated taxonomies.\n */\nexport const useTaxonomies = ( postType ) => {\n\tconst taxonomies = useSelect(\n\t\t( select ) => {\n\t\t\tconst { getTaxonomies } = select( coreStore );\n\t\t\tconst filteredTaxonomies = getTaxonomies( {\n\t\t\t\ttype: postType,\n\t\t\t\tper_page: -1,\n\t\t\t\tcontext: 'view',\n\t\t\t} );\n\t\t\treturn filteredTaxonomies;\n\t\t},\n\t\t[ postType ]\n\t);\n\treturn taxonomies;\n};\n\n/**\n * Hook that returns whether a specific post type is hierarchical.\n *\n * @param {string} postType The post type to check.\n * @return {boolean} Whether a specific post type is hierarchical.\n */\nexport function useIsPostTypeHierarchical( postType ) {\n\treturn useSelect(\n\t\t( select ) => {\n\t\t\tconst type = select( coreStore ).getPostType( postType );\n\t\t\treturn type?.viewable && type?.hierarchical;\n\t\t},\n\t\t[ postType ]\n\t);\n}\n\n/**\n * Hook that returns the query properties' names defined by the active\n * block variation, to determine which block's filters to show.\n *\n * @param {Object} attributes Block attributes.\n * @return {string[]} An array of the query attributes.\n */\nexport function useAllowedControls( attributes ) {\n\treturn useSelect(\n\t\t( select ) =>\n\t\t\tselect( blocksStore ).getActiveBlockVariation(\n\t\t\t\tqueryLoopName,\n\t\t\t\tattributes\n\t\t\t)?.allowedControls,\n\n\t\t[ attributes ]\n\t);\n}\nexport function isControlAllowed( allowedControls, key ) {\n\t// Every controls is allowed if the list is not defined.\n\tif ( ! allowedControls ) {\n\t\treturn true;\n\t}\n\treturn allowedControls.includes( key );\n}\n\n/**\n * Clones a pattern's blocks and then recurses over that list of blocks,\n * transforming them to retain some `query` attribute properties.\n * For now we retain the `postType` and `inherit` properties as they are\n * fundamental for the expected functionality of the block and don't affect\n * its design and presentation.\n *\n * Returns the cloned/transformed blocks and array of existing Query Loop\n * client ids for further manipulation, in order to avoid multiple recursions.\n *\n * @param {WPBlock[]}        blocks               The list of blocks to look through and transform(mutate).\n * @param {Record<string,*>} queryBlockAttributes The existing Query Loop's attributes.\n * @return {{ newBlocks: WPBlock[], queryClientIds: string[] }} An object with the cloned/transformed blocks and all the Query Loop clients from these blocks.\n */\nexport const getTransformedBlocksFromPattern = (\n\tblocks,\n\tqueryBlockAttributes\n) => {\n\tconst {\n\t\tquery: { postType, inherit },\n\t} = queryBlockAttributes;\n\tconst clonedBlocks = blocks.map( ( block ) => cloneBlock( block ) );\n\tconst queryClientIds = [];\n\tconst blocksQueue = [ ...clonedBlocks ];\n\twhile ( blocksQueue.length > 0 ) {\n\t\tconst block = blocksQueue.shift();\n\t\tif ( block.name === 'core/query' ) {\n\t\t\tblock.attributes.query = {\n\t\t\t\t...block.attributes.query,\n\t\t\t\tpostType,\n\t\t\t\tinherit,\n\t\t\t};\n\t\t\tqueryClientIds.push( block.clientId );\n\t\t}\n\t\tblock.innerBlocks?.forEach( ( innerBlock ) => {\n\t\t\tblocksQueue.push( innerBlock );\n\t\t} );\n\t}\n\treturn { newBlocks: clonedBlocks, queryClientIds };\n};\n\n/**\n * Helper hook that determines if there is an active variation of the block\n * and if there are available specific patterns for this variation.\n * If there are, these patterns are going to be the only ones suggested to\n * the user in setup and replace flow, without including the default ones\n * for Query Loop.\n *\n * If there are no such patterns, the default ones for Query Loop are going\n * to be suggested.\n *\n * @param {string} clientId   The block's client ID.\n * @param {Object} attributes The block's attributes.\n * @return {string} The block name to be used in the patterns suggestions.\n */\nexport function useBlockNameForPatterns( clientId, attributes ) {\n\tconst activeVariationName = useSelect(\n\t\t( select ) =>\n\t\t\tselect( blocksStore ).getActiveBlockVariation(\n\t\t\t\tqueryLoopName,\n\t\t\t\tattributes\n\t\t\t)?.name,\n\t\t[ attributes ]\n\t);\n\tconst blockName = `${ queryLoopName }/${ activeVariationName }`;\n\tconst activeVariationPatterns = useSelect(\n\t\t( select ) => {\n\t\t\tif ( ! activeVariationName ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst { getBlockRootClientId, getPatternsByBlockTypes } =\n\t\t\t\tselect( blockEditorStore );\n\t\t\tconst rootClientId = getBlockRootClientId( clientId );\n\t\t\treturn getPatternsByBlockTypes( blockName, rootClientId );\n\t\t},\n\t\t[ clientId, activeVariationName ]\n\t);\n\treturn activeVariationPatterns?.length ? blockName : queryLoopName;\n}\n\n/**\n * Helper hook that determines if there is an active variation of the block\n * and if there are available specific scoped `block` variations connected with\n * this variation.\n *\n * If there are, these variations are going to be the only ones suggested\n * to the user in setup flow when clicking to `start blank`, without including\n * the default ones for Query Loop.\n *\n * If there are no such scoped `block` variations, the default ones for Query\n * Loop are going to be suggested.\n *\n * The way we determine such variations is with the convention that they have the `namespace`\n * attribute defined as an array. This array should contain the names(`name` property) of any\n * variations they want to be connected to.\n * For example, if we have a `Query Loop` scoped `inserter` variation with the name `products`,\n * we can connect a scoped `block` variation by setting its `namespace` attribute to `['products']`.\n * If the user selects this variation, the `namespace` attribute will be overridden by the\n * main `inserter` variation.\n *\n * @param {Object} attributes The block's attributes.\n * @return {WPBlockVariation[]} The block variations to be suggested in setup flow, when clicking to `start blank`.\n */\nexport function useScopedBlockVariations( attributes ) {\n\tconst { activeVariationName, blockVariations } = useSelect(\n\t\t( select ) => {\n\t\t\tconst { getActiveBlockVariation, getBlockVariations } =\n\t\t\t\tselect( blocksStore );\n\t\t\treturn {\n\t\t\t\tactiveVariationName: getActiveBlockVariation(\n\t\t\t\t\tqueryLoopName,\n\t\t\t\t\tattributes\n\t\t\t\t)?.name,\n\t\t\t\tblockVariations: getBlockVariations( queryLoopName, 'block' ),\n\t\t\t};\n\t\t},\n\t\t[ attributes ]\n\t);\n\tconst variations = useMemo( () => {\n\t\t// Filter out the variations that have defined a `namespace` attribute,\n\t\t// which means they are 'connected' to specific variations of the block.\n\t\tconst isNotConnected = ( variation ) =>\n\t\t\t! variation.attributes?.namespace;\n\t\tif ( ! activeVariationName ) {\n\t\t\treturn blockVariations.filter( isNotConnected );\n\t\t}\n\t\tconst connectedVariations = blockVariations.filter( ( variation ) =>\n\t\t\tvariation.attributes?.namespace?.includes( activeVariationName )\n\t\t);\n\t\tif ( !! connectedVariations.length ) {\n\t\t\treturn connectedVariations;\n\t\t}\n\t\treturn blockVariations.filter( isNotConnected );\n\t}, [ activeVariationName, blockVariations ] );\n\treturn variations;\n}\n\n/**\n * Hook that returns the block patterns for a specific block type.\n *\n * @param {string} clientId The block's client ID.\n * @param {string} name     The block type name.\n * @return {Object[]} An array of valid block patterns.\n */\nexport const usePatterns = ( clientId, name ) => {\n\treturn useSelect(\n\t\t( select ) => {\n\t\t\tconst { getBlockRootClientId, getPatternsByBlockTypes } =\n\t\t\t\tselect( blockEditorStore );\n\t\t\tconst rootClientId = getBlockRootClientId( clientId );\n\t\t\treturn getPatternsByBlockTypes( name, rootClientId );\n\t\t},\n\t\t[ name, clientId ]\n\t);\n};\n"]}