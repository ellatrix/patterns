"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _blocks = require("@wordpress/blocks");

var _blockEditor = require("@wordpress/block-editor");

var _cleanEmptyObject = _interopRequireDefault(require("../utils/clean-empty-object"));

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const migrateToTaxQuery = attributes => {
  var _query$categoryIds, _query$tagIds;

  const {
    query
  } = attributes;
  const {
    categoryIds,
    tagIds,
    ...newQuery
  } = query;

  if ((_query$categoryIds = query.categoryIds) !== null && _query$categoryIds !== void 0 && _query$categoryIds.length || (_query$tagIds = query.tagIds) !== null && _query$tagIds !== void 0 && _query$tagIds.length) {
    var _query$categoryIds2, _query$tagIds2;

    newQuery.taxQuery = {
      category: !!((_query$categoryIds2 = query.categoryIds) !== null && _query$categoryIds2 !== void 0 && _query$categoryIds2.length) ? query.categoryIds : undefined,
      post_tag: !!((_query$tagIds2 = query.tagIds) !== null && _query$tagIds2 !== void 0 && _query$tagIds2.length) ? query.tagIds : undefined
    };
  }

  return { ...attributes,
    query: newQuery
  };
};

const migrateColors = (attributes, innerBlocks) => {
  var _style$elements, _style$elements5, _style$elements6;

  // Remove color style attributes from the Query block.
  const {
    style,
    backgroundColor,
    gradient,
    textColor,
    ...newAttributes
  } = attributes;
  const hasColorStyles = backgroundColor || gradient || textColor || (style === null || style === void 0 ? void 0 : style.color) || (style === null || style === void 0 ? void 0 : (_style$elements = style.elements) === null || _style$elements === void 0 ? void 0 : _style$elements.link); // If the query block doesn't currently have any color styles,
  // nothing needs migrating.

  if (!hasColorStyles) {
    return [attributes, innerBlocks];
  } // Clean color values from style attribute object.


  if (style) {
    newAttributes.style = (0, _cleanEmptyObject.default)({ ...style,
      color: undefined,
      elements: { ...style.elements,
        link: undefined
      }
    });
  } // If the inner blocks are already wrapped in a single group
  // block, add the color support styles to that group block.


  if (hasSingleInnerGroupBlock(innerBlocks)) {
    var _style$elements2, _style$elements3, _style$elements4;

    const groupBlock = innerBlocks[0]; // Create new styles for the group block.

    const hasStyles = (style === null || style === void 0 ? void 0 : style.color) || (style === null || style === void 0 ? void 0 : (_style$elements2 = style.elements) === null || _style$elements2 === void 0 ? void 0 : _style$elements2.link) || groupBlock.attributes.style;
    const newStyles = hasStyles ? (0, _cleanEmptyObject.default)({ ...groupBlock.attributes.style,
      color: style === null || style === void 0 ? void 0 : style.color,
      elements: style !== null && style !== void 0 && (_style$elements3 = style.elements) !== null && _style$elements3 !== void 0 && _style$elements3.link ? {
        link: style === null || style === void 0 ? void 0 : (_style$elements4 = style.elements) === null || _style$elements4 === void 0 ? void 0 : _style$elements4.link
      } : undefined
    }) : undefined; // Create a new Group block from the original.

    const updatedGroupBlock = (0, _blocks.createBlock)('core/group', { ...groupBlock.attributes,
      backgroundColor,
      gradient,
      textColor,
      style: newStyles
    }, groupBlock.innerBlocks);
    return [newAttributes, [updatedGroupBlock]];
  } // When we don't have a single wrapping group block for the inner
  // blocks, wrap the current inner blocks in a group applying the
  // color styles to that.


  const newGroupBlock = (0, _blocks.createBlock)('core/group', {
    backgroundColor,
    gradient,
    textColor,
    style: (0, _cleanEmptyObject.default)({
      color: style === null || style === void 0 ? void 0 : style.color,
      elements: style !== null && style !== void 0 && (_style$elements5 = style.elements) !== null && _style$elements5 !== void 0 && _style$elements5.link ? {
        link: style === null || style === void 0 ? void 0 : (_style$elements6 = style.elements) === null || _style$elements6 === void 0 ? void 0 : _style$elements6.link
      } : undefined
    })
  }, innerBlocks);
  return [newAttributes, [newGroupBlock]];
};

const hasSingleInnerGroupBlock = function () {
  let innerBlocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return innerBlocks.length === 1 && innerBlocks[0].name === 'core/group';
}; // Version with NO wrapper `div` element.


const v1 = {
  attributes: {
    queryId: {
      type: 'number'
    },
    query: {
      type: 'object',
      default: {
        perPage: null,
        pages: 0,
        offset: 0,
        postType: 'post',
        categoryIds: [],
        tagIds: [],
        order: 'desc',
        orderBy: 'date',
        author: '',
        search: '',
        exclude: [],
        sticky: '',
        inherit: true
      }
    },
    layout: {
      type: 'object',
      default: {
        type: 'list'
      }
    }
  },
  supports: {
    html: false
  },

  migrate(attributes) {
    const withTaxQuery = migrateToTaxQuery(attributes);
    const {
      layout,
      ...restWithTaxQuery
    } = withTaxQuery;
    return { ...restWithTaxQuery,
      displayLayout: withTaxQuery.layout
    };
  },

  save() {
    return (0, _element.createElement)(_blockEditor.InnerBlocks.Content, null);
  }

}; // Version with `categoryIds and tagIds`.

const v2 = {
  attributes: {
    queryId: {
      type: 'number'
    },
    query: {
      type: 'object',
      default: {
        perPage: null,
        pages: 0,
        offset: 0,
        postType: 'post',
        categoryIds: [],
        tagIds: [],
        order: 'desc',
        orderBy: 'date',
        author: '',
        search: '',
        exclude: [],
        sticky: '',
        inherit: true
      }
    },
    tagName: {
      type: 'string',
      default: 'div'
    },
    displayLayout: {
      type: 'object',
      default: {
        type: 'list'
      }
    }
  },
  supports: {
    align: ['wide', 'full'],
    html: false,
    color: {
      gradients: true,
      link: true
    },
    __experimentalLayout: true
  },
  isEligible: _ref => {
    let {
      query: {
        categoryIds,
        tagIds
      } = {}
    } = _ref;
    return categoryIds || tagIds;
  },

  migrate(attributes, innerBlocks) {
    const withTaxQuery = migrateToTaxQuery(attributes);
    return migrateColors(withTaxQuery, innerBlocks);
  },

  save(_ref2) {
    let {
      attributes: {
        tagName: Tag = 'div'
      }
    } = _ref2;

    const blockProps = _blockEditor.useBlockProps.save();

    const innerBlocksProps = _blockEditor.useInnerBlocksProps.save(blockProps);

    return (0, _element.createElement)(Tag, innerBlocksProps);
  }

}; // Version with color support prior to moving it to the PostTemplate block.

const v3 = {
  attributes: {
    queryId: {
      type: 'number'
    },
    query: {
      type: 'object',
      default: {
        perPage: null,
        pages: 0,
        offset: 0,
        postType: 'post',
        order: 'desc',
        orderBy: 'date',
        author: '',
        search: '',
        exclude: [],
        sticky: '',
        inherit: true,
        taxQuery: null,
        parents: []
      }
    },
    tagName: {
      type: 'string',
      default: 'div'
    },
    displayLayout: {
      type: 'object',
      default: {
        type: 'list'
      }
    },
    namespace: {
      type: 'string'
    }
  },
  supports: {
    align: ['wide', 'full'],
    html: false,
    color: {
      gradients: true,
      link: true,
      __experimentalDefaultControls: {
        background: true,
        text: true
      }
    },
    __experimentalLayout: true
  },

  isEligible(attributes) {
    var _style$elements7;

    const {
      style,
      backgroundColor,
      gradient,
      textColor
    } = attributes;
    return backgroundColor || gradient || textColor || (style === null || style === void 0 ? void 0 : style.color) || (style === null || style === void 0 ? void 0 : (_style$elements7 = style.elements) === null || _style$elements7 === void 0 ? void 0 : _style$elements7.link);
  },

  migrate: migrateColors,

  save(_ref3) {
    let {
      attributes: {
        tagName: Tag = 'div'
      }
    } = _ref3;

    const blockProps = _blockEditor.useBlockProps.save();

    const innerBlocksProps = _blockEditor.useInnerBlocksProps.save(blockProps);

    return (0, _element.createElement)(Tag, innerBlocksProps);
  }

};
const v4 = {
  attributes: {
    queryId: {
      type: 'number'
    },
    query: {
      type: 'object',
      default: {
        perPage: null,
        pages: 0,
        offset: 0,
        postType: 'post',
        order: 'desc',
        orderBy: 'date',
        author: '',
        search: '',
        exclude: [],
        sticky: '',
        inherit: true,
        taxQuery: null,
        parents: []
      }
    },
    tagName: {
      type: 'string',
      default: 'div'
    },
    displayLayout: {
      type: 'object',
      default: {
        type: 'list'
      }
    },
    namespace: {
      type: 'string'
    }
  },
  supports: {
    align: ['wide', 'full'],
    html: false,
    color: {
      gradients: true,
      link: true,
      __experimentalDefaultControls: {
        background: true,
        text: true
      }
    },
    __experimentalLayout: true
  },

  save(_ref4) {
    let {
      attributes: {
        tagName: Tag = 'div'
      }
    } = _ref4;

    const blockProps = _blockEditor.useBlockProps.save();

    const innerBlocksProps = _blockEditor.useInnerBlocksProps.save(blockProps);

    return (0, _element.createElement)(Tag, innerBlocksProps);
  },

  isEligible: _ref5 => {
    let {
      layout
    } = _ref5;
    return !layout || layout.inherit || layout.contentSize && layout.type !== 'constrained';
  },
  migrate: attributes => {
    const {
      layout = null
    } = attributes;

    if (!layout) {
      return attributes;
    }

    if (layout.inherit || layout.contentSize) {
      return { ...attributes,
        layout: { ...layout,
          type: 'constrained'
        }
      };
    }
  }
};
const deprecated = [v4, v3, v2, v1];
var _default = deprecated;
exports.default = _default;
//# sourceMappingURL=deprecated.js.map