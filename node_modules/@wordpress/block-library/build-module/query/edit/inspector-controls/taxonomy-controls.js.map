{"version":3,"sources":["@wordpress/block-library/src/query/edit/inspector-controls/taxonomy-controls.js"],"names":["FormTokenField","useSelect","store","coreStore","useState","useEffect","useDebounce","useTaxonomies","EMPTY_ARRAY","BASE_QUERY","order","_fields","context","getTermIdByTermValue","terms","termValue","termId","id","find","term","name","termValueLower","toLocaleLowerCase","TaxonomyControls","onChange","query","postType","taxQuery","taxonomies","length","map","taxonomy","termIds","slug","handleChange","newTermIds","TaxonomyItem","search","setSearch","value","setValue","suggestions","setSuggestions","debouncedSearch","searchResults","searchHasResolved","select","getEntityRecords","hasFinishedResolution","selectorArgs","orderby","exclude","per_page","existingTerms","include","sanitizedValue","reduce","accumulator","entity","push","result","onTermsChange","newTermValues","Set","add","Array","from"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { FormTokenField } from '@wordpress/components';\nimport { useSelect } from '@wordpress/data';\nimport { store as coreStore } from '@wordpress/core-data';\nimport { useState, useEffect } from '@wordpress/element';\nimport { useDebounce } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { useTaxonomies } from '../../utils';\n\nconst EMPTY_ARRAY = [];\nconst BASE_QUERY = {\n\torder: 'asc',\n\t_fields: 'id,name',\n\tcontext: 'view',\n};\n\n// Helper function to get the term id based on user input in terms `FormTokenField`.\nconst getTermIdByTermValue = ( terms, termValue ) => {\n\t// First we check for exact match by `term.id` or case sensitive `term.name` match.\n\tconst termId =\n\t\ttermValue?.id || terms?.find( ( term ) => term.name === termValue )?.id;\n\tif ( termId ) {\n\t\treturn termId;\n\t}\n\n\t/**\n\t * Here we make an extra check for entered terms in a non case sensitive way,\n\t * to match user expectations, due to `FormTokenField` behaviour that shows\n\t * suggestions which are case insensitive.\n\t *\n\t * Although WP tries to discourage users to add terms with the same name (case insensitive),\n\t * it's still possible if you manually change the name, as long as the terms have different slugs.\n\t * In this edge case we always apply the first match from the terms list.\n\t */\n\tconst termValueLower = termValue.toLocaleLowerCase();\n\treturn terms?.find(\n\t\t( term ) => term.name.toLocaleLowerCase() === termValueLower\n\t)?.id;\n};\n\nexport function TaxonomyControls( { onChange, query } ) {\n\tconst { postType, taxQuery } = query;\n\n\tconst taxonomies = useTaxonomies( postType );\n\tif ( ! taxonomies || taxonomies.length === 0 ) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t{ taxonomies.map( ( taxonomy ) => {\n\t\t\t\tconst termIds = taxQuery?.[ taxonomy.slug ] || [];\n\t\t\t\tconst handleChange = ( newTermIds ) =>\n\t\t\t\t\tonChange( {\n\t\t\t\t\t\ttaxQuery: {\n\t\t\t\t\t\t\t...taxQuery,\n\t\t\t\t\t\t\t[ taxonomy.slug ]: newTermIds,\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\treturn (\n\t\t\t\t\t<TaxonomyItem\n\t\t\t\t\t\tkey={ taxonomy.slug }\n\t\t\t\t\t\ttaxonomy={ taxonomy }\n\t\t\t\t\t\ttermIds={ termIds }\n\t\t\t\t\t\tonChange={ handleChange }\n\t\t\t\t\t/>\n\t\t\t\t);\n\t\t\t} ) }\n\t\t</>\n\t);\n}\n\n/**\n * Renders a `FormTokenField` for a given taxonomy.\n *\n * @param {Object}   props          The props for the component.\n * @param {Object}   props.taxonomy The taxonomy object.\n * @param {number[]} props.termIds  An array with the block's term ids for the given taxonomy.\n * @param {Function} props.onChange Callback `onChange` function.\n * @return {JSX.Element} The rendered component.\n */\nfunction TaxonomyItem( { taxonomy, termIds, onChange } ) {\n\tconst [ search, setSearch ] = useState( '' );\n\tconst [ value, setValue ] = useState( EMPTY_ARRAY );\n\tconst [ suggestions, setSuggestions ] = useState( EMPTY_ARRAY );\n\tconst debouncedSearch = useDebounce( setSearch, 250 );\n\tconst { searchResults, searchHasResolved } = useSelect(\n\t\t( select ) => {\n\t\t\tif ( ! search ) {\n\t\t\t\treturn { searchResults: EMPTY_ARRAY, searchHasResolved: true };\n\t\t\t}\n\t\t\tconst { getEntityRecords, hasFinishedResolution } =\n\t\t\t\tselect( coreStore );\n\t\t\tconst selectorArgs = [\n\t\t\t\t'taxonomy',\n\t\t\t\ttaxonomy.slug,\n\t\t\t\t{\n\t\t\t\t\t...BASE_QUERY,\n\t\t\t\t\tsearch,\n\t\t\t\t\torderby: 'name',\n\t\t\t\t\texclude: termIds,\n\t\t\t\t\tper_page: 20,\n\t\t\t\t},\n\t\t\t];\n\t\t\treturn {\n\t\t\t\tsearchResults: getEntityRecords( ...selectorArgs ),\n\t\t\t\tsearchHasResolved: hasFinishedResolution(\n\t\t\t\t\t'getEntityRecords',\n\t\t\t\t\tselectorArgs\n\t\t\t\t),\n\t\t\t};\n\t\t},\n\t\t[ search, termIds ]\n\t);\n\t// `existingTerms` are the ones fetched from the API and their type is `{ id: number; name: string }`.\n\t// They are used to extract the terms' names to populate the `FormTokenField` properly\n\t// and to sanitize the provided `termIds`, by setting only the ones that exist.\n\tconst existingTerms = useSelect(\n\t\t( select ) => {\n\t\t\tif ( ! termIds?.length ) return EMPTY_ARRAY;\n\t\t\tconst { getEntityRecords } = select( coreStore );\n\t\t\treturn getEntityRecords( 'taxonomy', taxonomy.slug, {\n\t\t\t\t...BASE_QUERY,\n\t\t\t\tinclude: termIds,\n\t\t\t\tper_page: termIds.length,\n\t\t\t} );\n\t\t},\n\t\t[ termIds ]\n\t);\n\t// Update the `value` state only after the selectors are resolved\n\t// to avoid emptying the input when we're changing terms.\n\tuseEffect( () => {\n\t\tif ( ! termIds?.length ) {\n\t\t\tsetValue( EMPTY_ARRAY );\n\t\t}\n\t\tif ( ! existingTerms?.length ) return;\n\t\t// Returns only the existing entity ids. This prevents the component\n\t\t// from crashing in the editor, when non existing ids are provided.\n\t\tconst sanitizedValue = termIds.reduce( ( accumulator, id ) => {\n\t\t\tconst entity = existingTerms.find( ( term ) => term.id === id );\n\t\t\tif ( entity ) {\n\t\t\t\taccumulator.push( {\n\t\t\t\t\tid,\n\t\t\t\t\tvalue: entity.name,\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn accumulator;\n\t\t}, [] );\n\t\tsetValue( sanitizedValue );\n\t}, [ termIds, existingTerms ] );\n\t// Update suggestions only when the query has resolved.\n\tuseEffect( () => {\n\t\tif ( ! searchHasResolved ) return;\n\t\tsetSuggestions( searchResults.map( ( result ) => result.name ) );\n\t}, [ searchResults, searchHasResolved ] );\n\tconst onTermsChange = ( newTermValues ) => {\n\t\tconst newTermIds = new Set();\n\t\tfor ( const termValue of newTermValues ) {\n\t\t\tconst termId = getTermIdByTermValue( searchResults, termValue );\n\t\t\tif ( termId ) {\n\t\t\t\tnewTermIds.add( termId );\n\t\t\t}\n\t\t}\n\t\tsetSuggestions( EMPTY_ARRAY );\n\t\tonChange( Array.from( newTermIds ) );\n\t};\n\treturn (\n\t\t<div className=\"block-library-query-inspector__taxonomy-control\">\n\t\t\t<FormTokenField\n\t\t\t\tlabel={ taxonomy.name }\n\t\t\t\tvalue={ value }\n\t\t\t\tonInputChange={ debouncedSearch }\n\t\t\t\tsuggestions={ suggestions }\n\t\t\t\tonChange={ onTermsChange }\n\t\t\t\t__experimentalShowHowTo={ false }\n\t\t\t/>\n\t\t</div>\n\t);\n}\n"]}