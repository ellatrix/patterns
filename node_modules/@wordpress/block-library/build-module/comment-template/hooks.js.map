{"version":3,"sources":["@wordpress/block-library/src/comment-template/hooks.js"],"names":["useState","useEffect","useMemo","useSelect","store","blockEditorStore","addQueryArgs","apiFetch","MAX_COMMENTS_PER_PAGE","useCommentQueryArgs","postId","queryArgs","status","order","context","parent","_embed","pageComments","commentsPerPage","defaultCommentsPage","defaultPage","select","getSettings","__experimentalDiscussionSettings","perPage","Math","min","page","useDefaultPageIndex","post","per_page","defaultPages","setDefaultPages","key","path","_fields","method","parse","then","res","pages","parseInt","headers","get","useCommentTree","topLevelComments","commentTree","map","id","_embedded","children","commentId","child"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useState, useEffect, useMemo } from '@wordpress/element';\nimport { useSelect } from '@wordpress/data';\nimport { store as blockEditorStore } from '@wordpress/block-editor';\nimport { addQueryArgs } from '@wordpress/url';\nimport apiFetch from '@wordpress/api-fetch';\n\n// This is limited by WP REST API\nconst MAX_COMMENTS_PER_PAGE = 100;\n\n/**\n * Return an object with the query args needed to fetch the default page of\n * comments.\n *\n * @param {Object} props        Hook props.\n * @param {number} props.postId ID of the post that contains the comments.\n *                              discussion settings.\n *\n * @return {Object} Query args to retrieve the comments.\n */\nexport const useCommentQueryArgs = ( { postId } ) => {\n\t// Initialize the query args that are not going to change.\n\tconst queryArgs = {\n\t\tstatus: 'approve',\n\t\torder: 'asc',\n\t\tcontext: 'embed',\n\t\tparent: 0,\n\t\t_embed: 'children',\n\t};\n\n\t// Get the Discussion settings that may be needed to query the comments.\n\tconst {\n\t\tpageComments,\n\t\tcommentsPerPage,\n\t\tdefaultCommentsPage: defaultPage,\n\t} = useSelect( ( select ) => {\n\t\tconst { getSettings } = select( blockEditorStore );\n\t\tconst { __experimentalDiscussionSettings } = getSettings();\n\t\treturn __experimentalDiscussionSettings;\n\t} );\n\n\t// WP REST API doesn't allow fetching more than max items limit set per single page of data.\n\t// As for the editor performance is more important than completeness of data and fetching only the\n\t// max allowed for single page should be enough for the purpose of design and laying out the page.\n\t// Fetching over the limit would return an error here but would work with backend query.\n\tconst perPage = pageComments\n\t\t? Math.min( commentsPerPage, MAX_COMMENTS_PER_PAGE )\n\t\t: MAX_COMMENTS_PER_PAGE;\n\n\t// Get the number of the default page.\n\tconst page = useDefaultPageIndex( {\n\t\tdefaultPage,\n\t\tpostId,\n\t\tperPage,\n\t\tqueryArgs,\n\t} );\n\n\t// Merge, memoize and return all query arguments, unless the default page's\n\t// number is not known yet.\n\treturn useMemo( () => {\n\t\treturn page\n\t\t\t? {\n\t\t\t\t\t...queryArgs,\n\t\t\t\t\tpost: postId,\n\t\t\t\t\tper_page: perPage,\n\t\t\t\t\tpage,\n\t\t\t  }\n\t\t\t: null;\n\t}, [ postId, perPage, page ] );\n};\n\n/**\n * Return the index of the default page, depending on whether `defaultPage` is\n * `newest` or `oldest`. In the first case, the only way to know the page's\n * index is by using the `X-WP-TotalPages` header, which forces to make an\n * additional request.\n *\n * @param {Object} props             Hook props.\n * @param {string} props.defaultPage Page shown by default (newest/oldest).\n * @param {number} props.postId      ID of the post that contains the comments.\n * @param {number} props.perPage     The number of comments included per page.\n * @param {Object} props.queryArgs   Other query args.\n *\n * @return {number} Index of the default comments page.\n */\nconst useDefaultPageIndex = ( { defaultPage, postId, perPage, queryArgs } ) => {\n\t// Store the default page indices.\n\tconst [ defaultPages, setDefaultPages ] = useState( {} );\n\tconst key = `${ postId }_${ perPage }`;\n\tconst page = defaultPages[ key ] || 0;\n\n\tuseEffect( () => {\n\t\t// Do nothing if the page is already known or not the newest page.\n\t\tif ( page || defaultPage !== 'newest' ) {\n\t\t\treturn;\n\t\t}\n\t\t// We need to fetch comments to know the index. Use HEAD and limit\n\t\t// fields just to ID, to make this call as light as possible.\n\t\tapiFetch( {\n\t\t\tpath: addQueryArgs( '/wp/v2/comments', {\n\t\t\t\t...queryArgs,\n\t\t\t\tpost: postId,\n\t\t\t\tper_page: perPage,\n\t\t\t\t_fields: 'id',\n\t\t\t} ),\n\t\t\tmethod: 'HEAD',\n\t\t\tparse: false,\n\t\t} ).then( ( res ) => {\n\t\t\tconst pages = parseInt( res.headers.get( 'X-WP-TotalPages' ) );\n\t\t\tsetDefaultPages( {\n\t\t\t\t...defaultPages,\n\t\t\t\t[ key ]: pages <= 1 ? 1 : pages, // If there are 0 pages, it means that there are no comments, but there is no 0th page.\n\t\t\t} );\n\t\t} );\n\t}, [ defaultPage, postId, perPage, setDefaultPages ] );\n\n\t// The oldest one is always the first one.\n\treturn defaultPage === 'newest' ? page : 1;\n};\n\n/**\n * Generate a tree structure of comment IDs from a list of comment entities. The\n * children of each comment are obtained from `_embedded`.\n *\n * @typedef {{ commentId: number, children: CommentNode }} CommentNode\n *\n * @param {Object[]} topLevelComments List of comment entities.\n * @return {{ commentTree: CommentNode[]}} Tree of comment IDs.\n */\nexport const useCommentTree = ( topLevelComments ) => {\n\tconst commentTree = useMemo(\n\t\t() =>\n\t\t\ttopLevelComments?.map( ( { id, _embedded } ) => {\n\t\t\t\tconst [ children ] = _embedded?.children || [ [] ];\n\t\t\t\treturn {\n\t\t\t\t\tcommentId: id,\n\t\t\t\t\tchildren: children.map( ( child ) => ( {\n\t\t\t\t\t\tcommentId: child.id,\n\t\t\t\t\t} ) ),\n\t\t\t\t};\n\t\t\t} ),\n\t\t[ topLevelComments ]\n\t);\n\n\treturn commentTree;\n};\n"]}