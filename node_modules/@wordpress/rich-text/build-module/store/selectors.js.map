{"version":3,"sources":["@wordpress/rich-text/src/store/selectors.js"],"names":["createSelector","getFormatTypes","state","Object","values","formatTypes","getFormatType","name","getFormatTypeForBareElement","bareElementTagName","find","className","tagName","getFormatTypeForClassName","elementClassName","indexOf"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,cAAP,MAA2B,QAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,cAAc,GAAGD,cAAc,CACzCE,KAAF,IAAaC,MAAM,CAACC,MAAP,CAAeF,KAAK,CAACG,WAArB,CAD8B,EAEzCH,KAAF,IAAa,CAAEA,KAAK,CAACG,WAAR,CAF8B,CAArC;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CAAwBJ,KAAxB,EAA+BK,IAA/B,EAAsC;AAC5C,SAAOL,KAAK,CAACG,WAAN,CAAmBE,IAAnB,CAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,2BAAT,CAAsCN,KAAtC,EAA6CO,kBAA7C,EAAkE;AACxE,QAAMJ,WAAW,GAAGJ,cAAc,CAAEC,KAAF,CAAlC;AACA,SACCG,WAAW,CAACK,IAAZ,CAAkB,QAA8B;AAAA,QAA5B;AAAEC,MAAAA,SAAF;AAAaC,MAAAA;AAAb,KAA4B;AAC/C,WAAOD,SAAS,KAAK,IAAd,IAAsBF,kBAAkB,KAAKG,OAApD;AACA,GAFD,KAGAP,WAAW,CAACK,IAAZ,CAAkB,SAA8B;AAAA,QAA5B;AAAEC,MAAAA,SAAF;AAAaC,MAAAA;AAAb,KAA4B;AAC/C,WAAOD,SAAS,KAAK,IAAd,IAAsB,QAAQC,OAArC;AACA,GAFD,CAJD;AAQA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,yBAAT,CAAoCX,KAApC,EAA2CY,gBAA3C,EAA8D;AACpE,SAAOb,cAAc,CAAEC,KAAF,CAAd,CAAwBQ,IAAxB,CAA8B,SAAqB;AAAA,QAAnB;AAAEC,MAAAA;AAAF,KAAmB;;AACzD,QAAKA,SAAS,KAAK,IAAnB,EAA0B;AACzB,aAAO,KAAP;AACA;;AAED,WAAQ,IAAIG,gBAAkB,GAAvB,CAA0BC,OAA1B,CAAoC,IAAIJ,SAAW,GAAnD,KAA2D,CAAlE;AACA,GANM,CAAP;AAOA","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @return {Array} Format types.\n */\nexport const getFormatTypes = createSelector(\n\t( state ) => Object.values( state.formatTypes ),\n\t( state ) => [ state.formatTypes ]\n);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name  Format type name.\n *\n * @return {Object?} Format type.\n */\nexport function getFormatType( state, name ) {\n\treturn state.formatTypes[ name ];\n}\n\n/**\n * Gets the format type, if any, that can handle a bare element (without a\n * data-format-type attribute), given the tag name of this element.\n *\n * @param {Object} state              Data state.\n * @param {string} bareElementTagName The tag name of the element to find a\n *                                    format type for.\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForBareElement( state, bareElementTagName ) {\n\tconst formatTypes = getFormatTypes( state );\n\treturn (\n\t\tformatTypes.find( ( { className, tagName } ) => {\n\t\t\treturn className === null && bareElementTagName === tagName;\n\t\t} ) ||\n\t\tformatTypes.find( ( { className, tagName } ) => {\n\t\t\treturn className === null && '*' === tagName;\n\t\t} )\n\t);\n}\n\n/**\n * Gets the format type, if any, that can handle an element, given its classes.\n *\n * @param {Object} state            Data state.\n * @param {string} elementClassName The classes of the element to find a format\n *                                  type for.\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForClassName( state, elementClassName ) {\n\treturn getFormatTypes( state ).find( ( { className } ) => {\n\t\tif ( className === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ` ${ elementClassName } `.indexOf( ` ${ className } ` ) >= 0;\n\t} );\n}\n"]}