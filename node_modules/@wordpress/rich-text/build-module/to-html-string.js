/**
 * WordPress dependencies
 */
import { escapeEditableHTML, escapeAttribute, isValidAttributeName } from '@wordpress/escape-html';
/**
 * Internal dependencies
 */

import { toTree } from './to-tree';
/** @typedef {import('./create').RichTextValue} RichTextValue */

/**
 * Create an HTML string from a Rich Text value. If a `multilineTag` is
 * provided, text separated by a line separator will be wrapped in it.
 *
 * @param {Object}        $1                      Named argements.
 * @param {RichTextValue} $1.value                Rich text value.
 * @param {string}        [$1.multilineTag]       Multiline tag.
 * @param {boolean}       [$1.preserveWhiteSpace] Whether or not to use newline
 *                                                characters for line breaks.
 *
 * @return {string} HTML string.
 */

export function toHTMLString(_ref) {
  let {
    value,
    multilineTag,
    preserveWhiteSpace
  } = _ref;
  const tree = toTree({
    value,
    multilineTag,
    preserveWhiteSpace,
    createEmpty,
    append,
    getLastChild,
    getParent,
    isText,
    getText,
    remove,
    appendText
  });
  return createChildrenHTML(tree.children);
}

function createEmpty() {
  return {};
}

function getLastChild(_ref2) {
  let {
    children
  } = _ref2;
  return children && children[children.length - 1];
}

function append(parent, object) {
  if (typeof object === 'string') {
    object = {
      text: object
    };
  }

  object.parent = parent;
  parent.children = parent.children || [];
  parent.children.push(object);
  return object;
}

function appendText(object, text) {
  object.text += text;
}

function getParent(_ref3) {
  let {
    parent
  } = _ref3;
  return parent;
}

function isText(_ref4) {
  let {
    text
  } = _ref4;
  return typeof text === 'string';
}

function getText(_ref5) {
  let {
    text
  } = _ref5;
  return text;
}

function remove(object) {
  const index = object.parent.children.indexOf(object);

  if (index !== -1) {
    object.parent.children.splice(index, 1);
  }

  return object;
}

function createElementHTML(_ref6) {
  let {
    type,
    attributes,
    object,
    children
  } = _ref6;
  let attributeString = '';

  for (const key in attributes) {
    if (!isValidAttributeName(key)) {
      continue;
    }

    attributeString += ` ${key}="${escapeAttribute(attributes[key])}"`;
  }

  if (object) {
    return `<${type}${attributeString}>`;
  }

  return `<${type}${attributeString}>${createChildrenHTML(children)}</${type}>`;
}

function createChildrenHTML() {
  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return children.map(child => {
    if (child.html !== undefined) {
      return child.html;
    }

    return child.text === undefined ? createElementHTML(child) : escapeEditableHTML(child.text);
  }).join('');
}
//# sourceMappingURL=to-html-string.js.map