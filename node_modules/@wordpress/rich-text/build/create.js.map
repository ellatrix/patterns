{"version":3,"sources":["@wordpress/rich-text/src/create.js"],"names":["createEmptyValue","formats","replacements","text","toFormat","tagName","attributes","formatType","class","richTextStore","getFormatTypeForClassName","replace","className","trim","getFormatTypeForBareElement","type","__experimentalCreatePrepareEditableTree","__experimentalCreateOnChangeEditableValue","name","registeredAttributes","unregisteredAttributes","_attributes","key","__unstableFilterAttributeValue","create","element","html","range","multilineTag","multilineWrapperTags","__unstableIsEditableTree","isEditableTree","preserveWhiteSpace","length","Array","document","createFromElement","createFromMultilineElement","accumulateSelection","accumulator","node","value","parentNode","startContainer","startOffset","endContainer","endOffset","currentLength","start","undefined","nodeType","TEXT_NODE","childNodes","end","filterRange","filter","nodeValue","slice","collapseWhiteSpace","string","removeReservedCharacters","RegExp","ZWNBSP","OBJECT_REPLACEMENT_CHARACTER","currentWrapperTags","hasChildNodes","index","nodeName","toLowerCase","ELEMENT_NODE","getAttribute","encodeURIComponent","innerHTML","format","getAttributes","indexOf","mergeFormats","newFormats","from","children","LINE_SEPARATOR","hasAttributes","i","safeName","test"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\nimport { createElement } from './create-element';\nimport { mergePair } from './concat';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\n/**\n * @typedef {Object} RichTextFormat\n *\n * @property {string} type Format type.\n */\n\n/**\n * @typedef {Array<RichTextFormat>} RichTextFormatList\n */\n\n/**\n * @typedef {Object} RichTextValue\n *\n * @property {string}                    text         Text.\n * @property {Array<RichTextFormatList>} formats      Formats.\n * @property {Array<RichTextFormat>}     replacements Replacements.\n * @property {number|undefined}          start        Selection start.\n * @property {number|undefined}          end          Selection end.\n */\n\nfunction createEmptyValue() {\n\treturn {\n\t\tformats: [],\n\t\treplacements: [],\n\t\ttext: '',\n\t};\n}\n\nfunction toFormat( { tagName, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( richTextStore ).getFormatTypeForClassName(\n\t\t\tattributes.class\n\t\t);\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `\n\t\t\t\t.replace( ` ${ formatType.className } `, ' ' )\n\t\t\t\t.trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType =\n\t\t\tselect( richTextStore ).getFormatTypeForBareElement( tagName );\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type: tagName, attributes } : { type: tagName };\n\t}\n\n\tif (\n\t\tformatType.__experimentalCreatePrepareEditableTree &&\n\t\t! formatType.__experimentalCreateOnChangeEditableValue\n\t) {\n\t\treturn null;\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { type: formatType.name, tagName };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\tconst _attributes = { ...attributes };\n\n\tfor ( const key in formatType.attributes ) {\n\t\tconst name = formatType.attributes[ key ];\n\n\t\tregisteredAttributes[ key ] = _attributes[ name ];\n\n\t\tif ( formatType.__unstableFilterAttributeValue ) {\n\t\t\tregisteredAttributes[ key ] =\n\t\t\t\tformatType.__unstableFilterAttributeValue(\n\t\t\t\t\tkey,\n\t\t\t\t\tregisteredAttributes[ key ]\n\t\t\t\t);\n\t\t}\n\n\t\t// delete the attribute and what's left is considered\n\t\t// to be unregistered.\n\t\tdelete _attributes[ name ];\n\n\t\tif ( typeof registeredAttributes[ key ] === 'undefined' ) {\n\t\t\tdelete registeredAttributes[ key ];\n\t\t}\n\t}\n\n\tfor ( const name in _attributes ) {\n\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t}\n\n\treturn {\n\t\ttype: formatType.name,\n\t\ttagName,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. If\n * `multilineTag` is provided, any content of direct children whose type matches\n * `multilineTag` will be separated by two newlines. The optional functions can\n * be used to filter out content.\n *\n * A value will have the following shape, which you are strongly encouraged not\n * to modify without the use of helper functions:\n *\n * ```js\n * {\n *   text: string,\n *   formats: Array,\n *   replacements: Array,\n *   ?start: number,\n *   ?end: number,\n * }\n * ```\n *\n * As you can see, text and formatting are separated. `text` holds the text,\n * including any replacement characters for objects and lines. `formats`,\n * `objects` and `lines` are all sparse arrays of the same length as `text`. It\n * holds information about the formatting at the relevant text indices. Finally\n * `start` and `end` state which text indices are selected. They are only\n * provided if a `Range` was given.\n *\n * @param {Object}  [$1]                          Optional named arguments.\n * @param {Element} [$1.element]                  Element to create value from.\n * @param {string}  [$1.text]                     Text to create value from.\n * @param {string}  [$1.html]                     HTML to create value from.\n * @param {Range}   [$1.range]                    Range to create value from.\n * @param {string}  [$1.multilineTag]             Multiline tag if the structure is\n *                                                multiline.\n * @param {Array}   [$1.multilineWrapperTags]     Tags where lines can be found if\n *                                                nesting is possible.\n * @param {boolean} [$1.preserveWhiteSpace]       Whether or not to collapse white\n *                                                space characters.\n * @param {boolean} [$1.__unstableIsEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\t__unstableIsEditableTree: isEditableTree,\n\tpreserveWhiteSpace,\n} = {} ) {\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\treplacements: Array( text.length ),\n\t\t\ttext,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\t// It does not matter which document this is, we're just using it to\n\t\t// parse.\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\tif ( ! multilineTag ) {\n\t\treturn createFromElement( {\n\t\t\telement,\n\t\t\trange,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\t}\n\n\treturn createFromMultilineElement( {\n\t\telement,\n\t\trange,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tisEditableTree,\n\t\tpreserveWhiteSpace,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {Object|void} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Collapse any whitespace used for HTML formatting to one space character,\n * because it will also be displayed as such by the browser.\n *\n * @param {string} string\n */\nfunction collapseWhiteSpace( string ) {\n\treturn string.replace( /[\\n\\r\\t]+/g, ' ' );\n}\n\n/**\n * Removes reserved characters used by rich-text (zero width non breaking spaces added by `toTree` and object replacement characters).\n *\n * @param {string} string\n */\nexport function removeReservedCharacters( string ) {\n\t// with the global flag, note that we should create a new regex each time OR reset lastIndex state.\n\treturn string.replace(\n\t\tnew RegExp( `[${ ZWNBSP }${ OBJECT_REPLACEMENT_CHARACTER }]`, 'gu' ),\n\t\t''\n\t);\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}  $1                        Named argements.\n * @param {Element} [$1.element]              Element to create value from.\n * @param {Range}   [$1.range]                Range to create value from.\n * @param {string}  [$1.multilineTag]         Multiline tag if the structure is\n *                                            multiline.\n * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if\n *                                            nesting is possible.\n * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white\n *                                            space characters.\n * @param {Array}   [$1.currentWrapperTags]\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcurrentWrapperTags = [],\n\tisEditableTree,\n\tpreserveWhiteSpace,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst tagName = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tlet filter = removeReservedCharacters;\n\n\t\t\tif ( ! preserveWhiteSpace ) {\n\t\t\t\tfilter = ( string ) =>\n\t\t\t\t\tremoveReservedCharacters( collapseWhiteSpace( string ) );\n\t\t\t}\n\n\t\t\tconst text = filter( node.nodeValue );\n\t\t\trange = filterRange( node, range, filter );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\taccumulator.replacements.length += text.length;\n\t\t\taccumulator.text += text;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== node.ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tisEditableTree &&\n\t\t\t// Ignore any placeholders.\n\t\t\t( node.getAttribute( 'data-rich-text-placeholder' ) ||\n\t\t\t\t// Ignore any line breaks that are not inserted by us.\n\t\t\t\t( tagName === 'br' &&\n\t\t\t\t\t! node.getAttribute( 'data-rich-text-line-break' ) ) )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'script' ) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: tagName,\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-script':\n\t\t\t\t\t\t\t\tnode.getAttribute( 'data-rich-text-script' ) ||\n\t\t\t\t\t\t\t\tencodeURIComponent( node.innerHTML ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, create( { text: '\\n' } ) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst format = toFormat( {\n\t\t\ttagName,\n\t\t\tattributes: getAttributes( { element: node } ),\n\t\t} );\n\n\t\tif (\n\t\t\tmultilineWrapperTags &&\n\t\t\tmultilineWrapperTags.indexOf( tagName ) !== -1\n\t\t) {\n\t\t\tconst value = createFromMultilineElement( {\n\t\t\t\telement: node,\n\t\t\t\trange,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t\tcurrentWrapperTags: [ ...currentWrapperTags, format ],\n\t\t\t\tisEditableTree,\n\t\t\t\tpreserveWhiteSpace,\n\t\t\t} );\n\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\tif ( ! format ) {\n\t\t\tmergePair( accumulator, value );\n\t\t} else if ( value.text.length === 0 ) {\n\t\t\tif ( format.attributes ) {\n\t\t\t\tmergePair( accumulator, {\n\t\t\t\t\tformats: [ , ],\n\t\t\t\t\treplacements: [ format ],\n\t\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\t// Indices should share a reference to the same formats array.\n\t\t\t// Only create a new reference if `formats` changes.\n\t\t\tfunction mergeFormats( formats ) {\n\t\t\t\tif ( mergeFormats.formats === formats ) {\n\t\t\t\t\treturn mergeFormats.newFormats;\n\t\t\t\t}\n\n\t\t\t\tconst newFormats = formats\n\t\t\t\t\t? [ format, ...formats ]\n\t\t\t\t\t: [ format ];\n\n\t\t\t\tmergeFormats.formats = formats;\n\t\t\t\tmergeFormats.newFormats = newFormats;\n\n\t\t\t\treturn newFormats;\n\t\t\t}\n\n\t\t\t// Since the formats parameter can be `undefined`, preset\n\t\t\t// `mergeFormats` with a new reference.\n\t\t\tmergeFormats.newFormats = [ format ];\n\n\t\t\tmergePair( accumulator, {\n\t\t\t\t...value,\n\t\t\t\tformats: Array.from( value.formats, mergeFormats ),\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Creates a rich text value from a DOM element and range that should be\n * multiline.\n *\n * @param {Object}  $1                        Named argements.\n * @param {Element} [$1.element]              Element to create value from.\n * @param {Range}   [$1.range]                Range to create value from.\n * @param {string}  [$1.multilineTag]         Multiline tag if the structure is\n *                                            multiline.\n * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if\n *                                            nesting is possible.\n * @param {Array}   [$1.currentWrapperTags]   Whether to prepend a line\n *                                            separator.\n * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white\n *                                            space characters.\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromMultilineElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcurrentWrapperTags = [],\n\tisEditableTree,\n\tpreserveWhiteSpace,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element || ! element.hasChildNodes() ) {\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.children.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.children[ index ];\n\n\t\tif ( node.nodeName.toLowerCase() !== multilineTag ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags,\n\t\t\tcurrentWrapperTags,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\n\t\t// Multiline value text should be separated by a line separator.\n\t\tif ( index !== 0 || currentWrapperTags.length > 0 ) {\n\t\t\tmergePair( accumulator, {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements:\n\t\t\t\t\tcurrentWrapperTags.length > 0\n\t\t\t\t\t\t? [ currentWrapperTags ]\n\t\t\t\t\t\t: [ , ],\n\t\t\t\ttext: LINE_SEPARATOR,\n\t\t\t} );\n\t\t}\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\t\tmergePair( accumulator, value );\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}  $1         Named argements.\n * @param {Element} $1.element Element to get attributes from.\n *\n * @return {Object|void} Attribute object or `undefined` if the element has no\n *                       attributes.\n */\nfunction getAttributes( { element } ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( name.indexOf( 'data-rich-text-' ) === 0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst safeName = /^on/i.test( name )\n\t\t\t? 'data-disable-rich-text-' + name\n\t\t\t: name;\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ safeName ] = value;\n\t}\n\n\treturn accumulator;\n}\n"]}