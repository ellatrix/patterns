{"version":3,"sources":["@wordpress/data/src/components/use-select/index.js"],"names":["renderQueue","Store","registry","suspense","select","suspendSelect","queueContext","lastMapSelect","lastMapResult","lastMapResultValid","lastIsAsync","subscribe","createSubscriber","stores","listener","onStoreChange","onChange","add","unsubs","map","storeName","unsub","cancel","mapSelect","resubscribe","isAsync","selectValue","updateValue","selectFromStore","mapResult","getValue","listeningStores","current","__unstableMarkListeningStores","useStaticSelect","useMappingSelect","deps","store","selector","result","useSelect","staticSelectMode","staticSelectModeRef","prevMode","nextMode","Error","useSuspenseSelect"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { createQueue } from '@wordpress/priority-queue';\nimport {\n\tuseRef,\n\tuseCallback,\n\tuseMemo,\n\tuseSyncExternalStore,\n\tuseDebugValue,\n} from '@wordpress/element';\nimport isShallowEqual from '@wordpress/is-shallow-equal';\n\n/**\n * Internal dependencies\n */\nimport useRegistry from '../registry-provider/use-registry';\nimport useAsyncMode from '../async-mode-provider/use-async-mode';\n\nconst renderQueue = createQueue();\n\n/**\n * @typedef {import('../../types').StoreDescriptor<C>} StoreDescriptor\n * @template {import('../../types').AnyConfig} C\n */\n/**\n * @typedef {import('../../types').ReduxStoreConfig<State,Actions,Selectors>} ReduxStoreConfig\n * @template State\n * @template {Record<string,import('../../types').ActionCreator>} Actions\n * @template Selectors\n */\n/** @typedef {import('../../types').MapSelect} MapSelect */\n/**\n * @typedef {import('../../types').UseSelectReturn<T>} UseSelectReturn\n * @template {MapSelect|StoreDescriptor<any>} T\n */\n\nfunction Store( registry, suspense ) {\n\tconst select = suspense ? registry.suspendSelect : registry.select;\n\tconst queueContext = {};\n\tlet lastMapSelect;\n\tlet lastMapResult;\n\tlet lastMapResultValid = false;\n\tlet lastIsAsync;\n\tlet subscribe;\n\n\tconst createSubscriber = ( stores ) => ( listener ) => {\n\t\t// Invalidate the value right after subscription was created. React will\n\t\t// call `getValue` after subscribing, to detect store updates that happened\n\t\t// in the interval between the `getValue` call during render and creating\n\t\t// the subscription, which is slightly delayed. We need to ensure that this\n\t\t// second `getValue` call will compute a fresh value.\n\t\tlastMapResultValid = false;\n\n\t\tconst onStoreChange = () => {\n\t\t\t// Invalidate the value on store update, so that a fresh value is computed.\n\t\t\tlastMapResultValid = false;\n\t\t\tlistener();\n\t\t};\n\n\t\tconst onChange = () => {\n\t\t\tif ( lastIsAsync ) {\n\t\t\t\trenderQueue.add( queueContext, onStoreChange );\n\t\t\t} else {\n\t\t\t\tonStoreChange();\n\t\t\t}\n\t\t};\n\n\t\tconst unsubs = stores.map( ( storeName ) => {\n\t\t\treturn registry.subscribe( onChange, storeName );\n\t\t} );\n\n\t\treturn () => {\n\t\t\t// The return value of the subscribe function could be undefined if the store is a custom generic store.\n\t\t\tfor ( const unsub of unsubs ) {\n\t\t\t\tunsub?.();\n\t\t\t}\n\t\t\t// Cancel existing store updates that were already scheduled.\n\t\t\trenderQueue.cancel( queueContext );\n\t\t};\n\t};\n\n\treturn ( mapSelect, resubscribe, isAsync ) => {\n\t\tconst selectValue = () => mapSelect( select, registry );\n\n\t\tfunction updateValue( selectFromStore ) {\n\t\t\t// If the last value is valid, and the `mapSelect` callback hasn't changed,\n\t\t\t// then we can safely return the cached value. The value can change only on\n\t\t\t// store update, and in that case value will be invalidated by the listener.\n\t\t\tif ( lastMapResultValid && mapSelect === lastMapSelect ) {\n\t\t\t\treturn lastMapResult;\n\t\t\t}\n\n\t\t\tconst mapResult = selectFromStore();\n\n\t\t\t// If the new value is shallow-equal to the old one, keep the old one so\n\t\t\t// that we don't trigger unwanted updates that do a `===` check.\n\t\t\tif ( ! isShallowEqual( lastMapResult, mapResult ) ) {\n\t\t\t\tlastMapResult = mapResult;\n\t\t\t}\n\t\t\tlastMapResultValid = true;\n\t\t}\n\n\t\tfunction getValue() {\n\t\t\t// Update the value in case it's been invalidated or `mapSelect` has changed.\n\t\t\tupdateValue( selectValue );\n\t\t\treturn lastMapResult;\n\t\t}\n\n\t\t// When transitioning from async to sync mode, cancel existing store updates\n\t\t// that have been scheduled, and invalidate the value so that it's freshly\n\t\t// computed. It might have been changed by the update we just cancelled.\n\t\tif ( lastIsAsync && ! isAsync ) {\n\t\t\tlastMapResultValid = false;\n\t\t\trenderQueue.cancel( queueContext );\n\t\t}\n\n\t\t// Either initialize the `subscribe` function, or create a new one if `mapSelect`\n\t\t// changed and has dependencies.\n\t\t// Usage without dependencies, `useSelect( ( s ) => { ... } )`, will subscribe\n\t\t// only once, at mount, and won't resubscibe even if `mapSelect` changes.\n\t\tif ( ! subscribe || ( resubscribe && mapSelect !== lastMapSelect ) ) {\n\t\t\t// Find out what stores the `mapSelect` callback is selecting from and\n\t\t\t// use that list to create subscriptions to specific stores.\n\t\t\tconst listeningStores = { current: null };\n\t\t\tupdateValue( () =>\n\t\t\t\tregistry.__unstableMarkListeningStores(\n\t\t\t\t\tselectValue,\n\t\t\t\t\tlisteningStores\n\t\t\t\t)\n\t\t\t);\n\t\t\tsubscribe = createSubscriber( listeningStores.current );\n\t\t} else {\n\t\t\tupdateValue( selectValue );\n\t\t}\n\n\t\tlastIsAsync = isAsync;\n\t\tlastMapSelect = mapSelect;\n\n\t\t// Return a pair of functions that can be passed to `useSyncExternalStore`.\n\t\treturn { subscribe, getValue };\n\t};\n}\n\nfunction useStaticSelect( storeName ) {\n\treturn useRegistry().select( storeName );\n}\n\nfunction useMappingSelect( suspense, mapSelect, deps ) {\n\tconst registry = useRegistry();\n\tconst isAsync = useAsyncMode();\n\tconst store = useMemo( () => Store( registry, suspense ), [ registry ] );\n\tconst selector = useCallback( mapSelect, deps );\n\tconst { subscribe, getValue } = store( selector, !! deps, isAsync );\n\tconst result = useSyncExternalStore( subscribe, getValue, getValue );\n\tuseDebugValue( result );\n\treturn result;\n}\n\n/**\n * Custom react hook for retrieving props from registered selectors.\n *\n * In general, this custom React hook follows the\n * [rules of hooks](https://reactjs.org/docs/hooks-rules.html).\n *\n * @template {MapSelect | StoreDescriptor<any>} T\n * @param {T}         mapSelect Function called on every state change. The returned value is\n *                              exposed to the component implementing this hook. The function\n *                              receives the `registry.select` method on the first argument\n *                              and the `registry` on the second argument.\n *                              When a store key is passed, all selectors for the store will be\n *                              returned. This is only meant for usage of these selectors in event\n *                              callbacks, not for data needed to create the element tree.\n * @param {unknown[]} deps      If provided, this memoizes the mapSelect so the same `mapSelect` is\n *                              invoked on every state change unless the dependencies change.\n *\n * @example\n * ```js\n * import { useSelect } from '@wordpress/data';\n * import { store as myCustomStore } from 'my-custom-store';\n *\n * function HammerPriceDisplay( { currency } ) {\n *   const price = useSelect( ( select ) => {\n *     return select( myCustomStore ).getPrice( 'hammer', currency );\n *   }, [ currency ] );\n *   return new Intl.NumberFormat( 'en-US', {\n *     style: 'currency',\n *     currency,\n *   } ).format( price );\n * }\n *\n * // Rendered in the application:\n * // <HammerPriceDisplay currency=\"USD\" />\n * ```\n *\n * In the above example, when `HammerPriceDisplay` is rendered into an\n * application, the price will be retrieved from the store state using the\n * `mapSelect` callback on `useSelect`. If the currency prop changes then\n * any price in the state for that currency is retrieved. If the currency prop\n * doesn't change and other props are passed in that do change, the price will\n * not change because the dependency is just the currency.\n *\n * When data is only used in an event callback, the data should not be retrieved\n * on render, so it may be useful to get the selectors function instead.\n *\n * **Don't use `useSelect` this way when calling the selectors in the render\n * function because your component won't re-render on a data change.**\n *\n * ```js\n * import { useSelect } from '@wordpress/data';\n * import { store as myCustomStore } from 'my-custom-store';\n *\n * function Paste( { children } ) {\n *   const { getSettings } = useSelect( myCustomStore );\n *   function onPaste() {\n *     // Do something with the settings.\n *     const settings = getSettings();\n *   }\n *   return <div onPaste={ onPaste }>{ children }</div>;\n * }\n * ```\n * @return {UseSelectReturn<T>} A custom react hook.\n */\nexport default function useSelect( mapSelect, deps ) {\n\t// On initial call, on mount, determine the mode of this `useSelect` call\n\t// and then never allow it to change on subsequent updates.\n\tconst staticSelectMode = typeof mapSelect !== 'function';\n\tconst staticSelectModeRef = useRef( staticSelectMode );\n\n\tif ( staticSelectMode !== staticSelectModeRef.current ) {\n\t\tconst prevMode = staticSelectModeRef.current ? 'static' : 'mapping';\n\t\tconst nextMode = staticSelectMode ? 'static' : 'mapping';\n\t\tthrow new Error(\n\t\t\t`Switching useSelect from ${ prevMode } to ${ nextMode } is not allowed`\n\t\t);\n\t}\n\n\t/* eslint-disable react-hooks/rules-of-hooks */\n\t// `staticSelectMode` is not allowed to change during the hook instance's,\n\t// lifetime, so the rules of hooks are not really violated.\n\treturn staticSelectMode\n\t\t? useStaticSelect( mapSelect )\n\t\t: useMappingSelect( false, mapSelect, deps );\n\t/* eslint-enable react-hooks/rules-of-hooks */\n}\n\n/**\n * A variant of the `useSelect` hook that has the same API, but will throw a\n * suspense Promise if any of the called selectors is in an unresolved state.\n *\n * @param {Function} mapSelect Function called on every state change. The\n *                             returned value is exposed to the component\n *                             using this hook. The function receives the\n *                             `registry.suspendSelect` method as the first\n *                             argument and the `registry` as the second one.\n * @param {Array}    deps      A dependency array used to memoize the `mapSelect`\n *                             so that the same `mapSelect` is invoked on every\n *                             state change unless the dependencies change.\n *\n * @return {Object} Data object returned by the `mapSelect` function.\n */\nexport function useSuspenseSelect( mapSelect, deps ) {\n\treturn useMappingSelect( true, mapSelect, deps );\n}\n"]}