{"version":3,"sources":["@wordpress/reusable-blocks/src/store/actions.js"],"names":["store","blockEditorStore","createBlock","isReusableBlock","parse","serialize","__","__experimentalConvertBlockToStatic","clientId","registry","oldBlock","select","getBlock","reusableBlock","getEditedEntityRecord","attributes","ref","newBlocks","content","dispatch","replaceBlocks","__experimentalConvertBlocksToReusable","clientIds","title","getBlocksByClientId","status","updatedRecord","saveEntityRecord","newBlock","id","__experimentalSetEditingReusableBlock","__experimentalDeleteReusableBlock","allBlocks","getBlocks","associatedBlocks","filter","block","associatedBlockClientIds","map","length","removeBlocks","deleteEntityRecord","isEditing","type"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { store as blockEditorStore } from '@wordpress/block-editor';\nimport {\n\tcreateBlock,\n\tisReusableBlock,\n\tparse,\n\tserialize,\n} from '@wordpress/blocks';\nimport { __ } from '@wordpress/i18n';\n\n/**\n * Returns a generator converting a reusable block into a static block.\n *\n * @param {string} clientId The client ID of the block to attach.\n */\nexport const __experimentalConvertBlockToStatic =\n\t( clientId ) =>\n\t( { registry } ) => {\n\t\tconst oldBlock = registry\n\t\t\t.select( blockEditorStore )\n\t\t\t.getBlock( clientId );\n\t\tconst reusableBlock = registry\n\t\t\t.select( 'core' )\n\t\t\t.getEditedEntityRecord(\n\t\t\t\t'postType',\n\t\t\t\t'wp_block',\n\t\t\t\toldBlock.attributes.ref\n\t\t\t);\n\n\t\tconst newBlocks = parse(\n\t\t\ttypeof reusableBlock.content === 'function'\n\t\t\t\t? reusableBlock.content( reusableBlock )\n\t\t\t\t: reusableBlock.content\n\t\t);\n\t\tregistry\n\t\t\t.dispatch( blockEditorStore )\n\t\t\t.replaceBlocks( oldBlock.clientId, newBlocks );\n\t};\n\n/**\n * Returns a generator converting one or more static blocks into a reusable block.\n *\n * @param {string[]} clientIds The client IDs of the block to detach.\n * @param {string}   title     Reusable block title.\n */\nexport const __experimentalConvertBlocksToReusable =\n\t( clientIds, title ) =>\n\tasync ( { registry, dispatch } ) => {\n\t\tconst reusableBlock = {\n\t\t\ttitle: title || __( 'Untitled Reusable block' ),\n\t\t\tcontent: serialize(\n\t\t\t\tregistry\n\t\t\t\t\t.select( blockEditorStore )\n\t\t\t\t\t.getBlocksByClientId( clientIds )\n\t\t\t),\n\t\t\tstatus: 'publish',\n\t\t};\n\n\t\tconst updatedRecord = await registry\n\t\t\t.dispatch( 'core' )\n\t\t\t.saveEntityRecord( 'postType', 'wp_block', reusableBlock );\n\n\t\tconst newBlock = createBlock( 'core/block', {\n\t\t\tref: updatedRecord.id,\n\t\t} );\n\t\tregistry\n\t\t\t.dispatch( blockEditorStore )\n\t\t\t.replaceBlocks( clientIds, newBlock );\n\t\tdispatch.__experimentalSetEditingReusableBlock(\n\t\t\tnewBlock.clientId,\n\t\t\ttrue\n\t\t);\n\t};\n\n/**\n * Returns a generator deleting a reusable block.\n *\n * @param {string} id The ID of the reusable block to delete.\n */\nexport const __experimentalDeleteReusableBlock =\n\t( id ) =>\n\tasync ( { registry } ) => {\n\t\tconst reusableBlock = registry\n\t\t\t.select( 'core' )\n\t\t\t.getEditedEntityRecord( 'postType', 'wp_block', id );\n\n\t\t// Don't allow a reusable block with a temporary ID to be deleted.\n\t\tif ( ! reusableBlock ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove any other blocks that reference this reusable block.\n\t\tconst allBlocks = registry.select( blockEditorStore ).getBlocks();\n\t\tconst associatedBlocks = allBlocks.filter(\n\t\t\t( block ) => isReusableBlock( block ) && block.attributes.ref === id\n\t\t);\n\t\tconst associatedBlockClientIds = associatedBlocks.map(\n\t\t\t( block ) => block.clientId\n\t\t);\n\n\t\t// Remove the parsed block.\n\t\tif ( associatedBlockClientIds.length ) {\n\t\t\tregistry\n\t\t\t\t.dispatch( blockEditorStore )\n\t\t\t\t.removeBlocks( associatedBlockClientIds );\n\t\t}\n\n\t\tawait registry\n\t\t\t.dispatch( 'core' )\n\t\t\t.deleteEntityRecord( 'postType', 'wp_block', id );\n\t};\n\n/**\n * Returns an action descriptor for SET_EDITING_REUSABLE_BLOCK action.\n *\n * @param {string}  clientId  The clientID of the reusable block to target.\n * @param {boolean} isEditing Whether the block should be in editing state.\n * @return {Object} Action descriptor.\n */\nexport function __experimentalSetEditingReusableBlock( clientId, isEditing ) {\n\treturn {\n\t\ttype: 'SET_EDITING_REUSABLE_BLOCK',\n\t\tclientId,\n\t\tisEditing,\n\t};\n}\n"]}