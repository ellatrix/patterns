"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__experimentalDeleteReusableBlock = exports.__experimentalConvertBlocksToReusable = exports.__experimentalConvertBlockToStatic = void 0;
exports.__experimentalSetEditingReusableBlock = __experimentalSetEditingReusableBlock;

var _blockEditor = require("@wordpress/block-editor");

var _blocks = require("@wordpress/blocks");

var _i18n = require("@wordpress/i18n");

/**
 * WordPress dependencies
 */

/**
 * Returns a generator converting a reusable block into a static block.
 *
 * @param {string} clientId The client ID of the block to attach.
 */
const __experimentalConvertBlockToStatic = clientId => _ref => {
  let {
    registry
  } = _ref;
  const oldBlock = registry.select(_blockEditor.store).getBlock(clientId);
  const reusableBlock = registry.select('core').getEditedEntityRecord('postType', 'wp_block', oldBlock.attributes.ref);
  const newBlocks = (0, _blocks.parse)(typeof reusableBlock.content === 'function' ? reusableBlock.content(reusableBlock) : reusableBlock.content);
  registry.dispatch(_blockEditor.store).replaceBlocks(oldBlock.clientId, newBlocks);
};
/**
 * Returns a generator converting one or more static blocks into a reusable block.
 *
 * @param {string[]} clientIds The client IDs of the block to detach.
 * @param {string}   title     Reusable block title.
 */


exports.__experimentalConvertBlockToStatic = __experimentalConvertBlockToStatic;

const __experimentalConvertBlocksToReusable = (clientIds, title) => async _ref2 => {
  let {
    registry,
    dispatch
  } = _ref2;
  const reusableBlock = {
    title: title || (0, _i18n.__)('Untitled Reusable block'),
    content: (0, _blocks.serialize)(registry.select(_blockEditor.store).getBlocksByClientId(clientIds)),
    status: 'publish'
  };
  const updatedRecord = await registry.dispatch('core').saveEntityRecord('postType', 'wp_block', reusableBlock);
  const newBlock = (0, _blocks.createBlock)('core/block', {
    ref: updatedRecord.id
  });
  registry.dispatch(_blockEditor.store).replaceBlocks(clientIds, newBlock);

  dispatch.__experimentalSetEditingReusableBlock(newBlock.clientId, true);
};
/**
 * Returns a generator deleting a reusable block.
 *
 * @param {string} id The ID of the reusable block to delete.
 */


exports.__experimentalConvertBlocksToReusable = __experimentalConvertBlocksToReusable;

const __experimentalDeleteReusableBlock = id => async _ref3 => {
  let {
    registry
  } = _ref3;
  const reusableBlock = registry.select('core').getEditedEntityRecord('postType', 'wp_block', id); // Don't allow a reusable block with a temporary ID to be deleted.

  if (!reusableBlock) {
    return;
  } // Remove any other blocks that reference this reusable block.


  const allBlocks = registry.select(_blockEditor.store).getBlocks();
  const associatedBlocks = allBlocks.filter(block => (0, _blocks.isReusableBlock)(block) && block.attributes.ref === id);
  const associatedBlockClientIds = associatedBlocks.map(block => block.clientId); // Remove the parsed block.

  if (associatedBlockClientIds.length) {
    registry.dispatch(_blockEditor.store).removeBlocks(associatedBlockClientIds);
  }

  await registry.dispatch('core').deleteEntityRecord('postType', 'wp_block', id);
};
/**
 * Returns an action descriptor for SET_EDITING_REUSABLE_BLOCK action.
 *
 * @param {string}  clientId  The clientID of the reusable block to target.
 * @param {boolean} isEditing Whether the block should be in editing state.
 * @return {Object} Action descriptor.
 */


exports.__experimentalDeleteReusableBlock = __experimentalDeleteReusableBlock;

function __experimentalSetEditingReusableBlock(clientId, isEditing) {
  return {
    type: 'SET_EDITING_REUSABLE_BLOCK',
    clientId,
    isEditing
  };
}
//# sourceMappingURL=actions.js.map