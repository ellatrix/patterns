"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ReusableBlockConvertButton;

var _element = require("@wordpress/element");

var _blocks = require("@wordpress/blocks");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _icons = require("@wordpress/icons");

var _data = require("@wordpress/data");

var _i18n = require("@wordpress/i18n");

var _notices = require("@wordpress/notices");

var _coreData = require("@wordpress/core-data");

var _store = require("../../store");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Menu control to convert block(s) to reusable block.
 *
 * @param {Object}   props              Component props.
 * @param {string[]} props.clientIds    Client ids of selected blocks.
 * @param {string}   props.rootClientId ID of the currently selected top-level block.
 * @return {import('@wordpress/element').WPComponent} The menu control or null.
 */
function ReusableBlockConvertButton(_ref) {
  let {
    clientIds,
    rootClientId
  } = _ref;
  const [isModalOpen, setIsModalOpen] = (0, _element.useState)(false);
  const [title, setTitle] = (0, _element.useState)('');
  const canConvert = (0, _data.useSelect)(select => {
    var _getBlocksByClientId;

    const {
      canUser
    } = select(_coreData.store);
    const {
      getBlocksByClientId,
      canInsertBlockType
    } = select(_blockEditor.store);
    const blocks = (_getBlocksByClientId = getBlocksByClientId(clientIds)) !== null && _getBlocksByClientId !== void 0 ? _getBlocksByClientId : [];
    const isReusable = blocks.length === 1 && blocks[0] && (0, _blocks.isReusableBlock)(blocks[0]) && !!select(_coreData.store).getEntityRecord('postType', 'wp_block', blocks[0].attributes.ref);

    const _canConvert = // Hide when this is already a reusable block.
    !isReusable && // Hide when reusable blocks are disabled.
    canInsertBlockType('core/block', rootClientId) && blocks.every(block => // Guard against the case where a regular block has *just* been converted.
    !!block && // Hide on invalid blocks.
    block.isValid && // Hide when block doesn't support being made reusable.
    (0, _blocks.hasBlockSupport)(block.name, 'reusable', true)) && // Hide when current doesn't have permission to do that.
    !!canUser('create', 'blocks');

    return _canConvert;
  }, [clientIds]);
  const {
    __experimentalConvertBlocksToReusable: convertBlocksToReusable
  } = (0, _data.useDispatch)(_store.store);
  const {
    createSuccessNotice,
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);
  const onConvert = (0, _element.useCallback)(async function (reusableBlockTitle) {
    try {
      await convertBlocksToReusable(clientIds, reusableBlockTitle);
      createSuccessNotice((0, _i18n.__)('Reusable block created.'), {
        type: 'snackbar'
      });
    } catch (error) {
      createErrorNotice(error.message, {
        type: 'snackbar'
      });
    }
  }, [clientIds]);

  if (!canConvert) {
    return null;
  }

  return (0, _element.createElement)(_blockEditor.BlockSettingsMenuControls, null, _ref2 => {
    let {
      onClose
    } = _ref2;
    return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.MenuItem, {
      icon: _icons.symbol,
      onClick: () => {
        setIsModalOpen(true);
      }
    }, (0, _i18n.__)('Create Reusable block')), isModalOpen && (0, _element.createElement)(_components.Modal, {
      title: (0, _i18n.__)('Create Reusable block'),
      onRequestClose: () => {
        setIsModalOpen(false);
        setTitle('');
      },
      overlayClassName: "reusable-blocks-menu-items__convert-modal"
    }, (0, _element.createElement)("form", {
      onSubmit: event => {
        event.preventDefault();
        onConvert(title);
        setIsModalOpen(false);
        setTitle('');
        onClose();
      }
    }, (0, _element.createElement)(_components.__experimentalVStack, {
      spacing: "5"
    }, (0, _element.createElement)(_components.TextControl, {
      __nextHasNoMarginBottom: true,
      label: (0, _i18n.__)('Name'),
      value: title,
      onChange: setTitle
    }), (0, _element.createElement)(_components.__experimentalHStack, {
      justify: "right"
    }, (0, _element.createElement)(_components.Button, {
      variant: "tertiary",
      onClick: () => {
        setIsModalOpen(false);
        setTitle('');
      }
    }, (0, _i18n.__)('Cancel')), (0, _element.createElement)(_components.Button, {
      variant: "primary",
      type: "submit"
    }, (0, _i18n.__)('Save')))))));
  });
}
//# sourceMappingURL=reusable-block-convert-button.js.map