{"version":3,"sources":["@wordpress/compose/src/hooks/use-merge-refs/index.js"],"names":["assignRef","ref","value","hasOwnProperty","current","useMergeRefs","refs","element","isAttached","didElementChange","previousRefs","currentRefs","forEach","index","previousRef","refsToAssign"],"mappings":";;;;;;;AAGA;;AAHA;AACA;AACA;;AAGA;;AACA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAT,CAAoBC,GAApB,EAAyBC,KAAzB,EAAiC;AAChC,MAAK,OAAOD,GAAP,KAAe,UAApB,EAAiC;AAChCA,IAAAA,GAAG,CAAEC,KAAF,CAAH;AACA,GAFD,MAEO,IAAKD,GAAG,IAAIA,GAAG,CAACE,cAAJ,CAAoB,SAApB,CAAZ,EAA8C;AACpD;;AACA;AAAqDF,IAAAA,GAAF,CAAQG,OAAR,GAClDF,KADkD;AAEnD;AACA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAASG,YAAT,CAAuBC,IAAvB,EAA8B;AAC5C,QAAMC,OAAO,GAAG,sBAAhB;AACA,QAAMC,UAAU,GAAG,qBAAQ,KAAR,CAAnB;AACA,QAAMC,gBAAgB,GAAG,qBAAQ,KAAR,CAAzB;AACA;;AACA;;AACA;;AACA,QAAMC,YAAY,GAAG,qBAAQ,EAAR,CAArB;AACA,QAAMC,WAAW,GAAG,qBAAQL,IAAR,CAApB,CAR4C,CAU5C;AACA;;AACAK,EAAAA,WAAW,CAACP,OAAZ,GAAsBE,IAAtB,CAZ4C,CAc5C;AACA;AACA;;AACA,gCAAiB,MAAM;AACtB,QACCG,gBAAgB,CAACL,OAAjB,KAA6B,KAA7B,IACAI,UAAU,CAACJ,OAAX,KAAuB,IAFxB,EAGE;AACDE,MAAAA,IAAI,CAACM,OAAL,CAAc,CAAEX,GAAF,EAAOY,KAAP,KAAkB;AAC/B,cAAMC,WAAW,GAAGJ,YAAY,CAACN,OAAb,CAAsBS,KAAtB,CAApB;;AACA,YAAKZ,GAAG,KAAKa,WAAb,EAA2B;AAC1Bd,UAAAA,SAAS,CAAEc,WAAF,EAAe,IAAf,CAAT;AACAd,UAAAA,SAAS,CAAEC,GAAF,EAAOM,OAAO,CAACH,OAAf,CAAT;AACA;AACD,OAND;AAOA;;AAEDM,IAAAA,YAAY,CAACN,OAAb,GAAuBE,IAAvB;AACA,GAfD,EAeGA,IAfH,EAjB4C,CAkC5C;AACA;;AACA,gCAAiB,MAAM;AACtBG,IAAAA,gBAAgB,CAACL,OAAjB,GAA2B,KAA3B;AACA,GAFD,EApC4C,CAwC5C;AACA;;AACA,SAAO,0BAAeF,KAAF,IAAa;AAChC;AACA;AACAF,IAAAA,SAAS,CAAEO,OAAF,EAAWL,KAAX,CAAT;AAEAO,IAAAA,gBAAgB,CAACL,OAAjB,GAA2B,IAA3B;AACAI,IAAAA,UAAU,CAACJ,OAAX,GAAqBF,KAAK,KAAK,IAA/B,CANgC,CAQhC;AACA;;AACA,UAAMa,YAAY,GAAGb,KAAK,GAAGS,WAAW,CAACP,OAAf,GAAyBM,YAAY,CAACN,OAAhE,CAVgC,CAYhC;;AACA,SAAM,MAAMH,GAAZ,IAAmBc,YAAnB,EAAkC;AACjCf,MAAAA,SAAS,CAAEC,GAAF,EAAOC,KAAP,CAAT;AACA;AACD,GAhBM,EAgBJ,EAhBI,CAAP;AAiBA","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useRef, useCallback, useLayoutEffect } from '@wordpress/element';\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * @template T\n * @typedef {T extends import('react').Ref<infer R> ? R : never} TypeFromRef\n */\n/* eslint-enable jsdoc/valid-types */\n\n/**\n * @template T\n * @param {import('react').Ref<T>} ref\n * @param {T}                      value\n */\nfunction assignRef( ref, value ) {\n\tif ( typeof ref === 'function' ) {\n\t\tref( value );\n\t} else if ( ref && ref.hasOwnProperty( 'current' ) ) {\n\t\t/* eslint-disable jsdoc/no-undefined-types */\n\t\t/** @type {import('react').MutableRefObject<T>} */ ( ref ).current =\n\t\t\tvalue;\n\t\t/* eslint-enable jsdoc/no-undefined-types */\n\t}\n}\n\n/**\n * Merges refs into one ref callback.\n *\n * It also ensures that the merged ref callbacks are only called when they\n * change (as a result of a `useCallback` dependency update) OR when the ref\n * value changes, just as React does when passing a single ref callback to the\n * component.\n *\n * As expected, if you pass a new function on every render, the ref callback\n * will be called after every render.\n *\n * If you don't wish a ref callback to be called after every render, wrap it\n * with `useCallback( callback, dependencies )`. When a dependency changes, the\n * old ref callback will be called with `null` and the new ref callback will be\n * called with the same value.\n *\n * To make ref callbacks easier to use, you can also pass the result of\n * `useRefEffect`, which makes cleanup easier by allowing you to return a\n * cleanup function instead of handling `null`.\n *\n * It's also possible to _disable_ a ref (and its behaviour) by simply not\n * passing the ref.\n *\n * ```jsx\n * const ref = useRefEffect( ( node ) => {\n *   node.addEventListener( ... );\n *   return () => {\n *     node.removeEventListener( ... );\n *   };\n * }, [ ...dependencies ] );\n * const otherRef = useRef();\n * const mergedRefs useMergeRefs( [\n *   enabled && ref,\n *   otherRef,\n * ] );\n * return <div ref={ mergedRefs } />;\n * ```\n *\n * @template {import('react').Ref<any>} TRef\n * @param {Array<TRef>} refs The refs to be merged.\n *\n * @return {import('react').RefCallback<TypeFromRef<TRef>>} The merged ref callback.\n */\nexport default function useMergeRefs( refs ) {\n\tconst element = useRef();\n\tconst isAttached = useRef( false );\n\tconst didElementChange = useRef( false );\n\t/* eslint-disable jsdoc/no-undefined-types */\n\t/** @type {import('react').MutableRefObject<TRef[]>} */\n\t/* eslint-enable jsdoc/no-undefined-types */\n\tconst previousRefs = useRef( [] );\n\tconst currentRefs = useRef( refs );\n\n\t// Update on render before the ref callback is called, so the ref callback\n\t// always has access to the current refs.\n\tcurrentRefs.current = refs;\n\n\t// If any of the refs change, call the previous ref with `null` and the new\n\t// ref with the node, except when the element changes in the same cycle, in\n\t// which case the ref callbacks will already have been called.\n\tuseLayoutEffect( () => {\n\t\tif (\n\t\t\tdidElementChange.current === false &&\n\t\t\tisAttached.current === true\n\t\t) {\n\t\t\trefs.forEach( ( ref, index ) => {\n\t\t\t\tconst previousRef = previousRefs.current[ index ];\n\t\t\t\tif ( ref !== previousRef ) {\n\t\t\t\t\tassignRef( previousRef, null );\n\t\t\t\t\tassignRef( ref, element.current );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpreviousRefs.current = refs;\n\t}, refs );\n\n\t// No dependencies, must be reset after every render so ref callbacks are\n\t// correctly called after a ref change.\n\tuseLayoutEffect( () => {\n\t\tdidElementChange.current = false;\n\t} );\n\n\t// There should be no dependencies so that `callback` is only called when\n\t// the node changes.\n\treturn useCallback( ( value ) => {\n\t\t// Update the element so it can be used when calling ref callbacks on a\n\t\t// dependency change.\n\t\tassignRef( element, value );\n\n\t\tdidElementChange.current = true;\n\t\tisAttached.current = value !== null;\n\n\t\t// When an element changes, the current ref callback should be called\n\t\t// with the new element and the previous one with `null`.\n\t\tconst refsToAssign = value ? currentRefs.current : previousRefs.current;\n\n\t\t// Update the latest refs.\n\t\tfor ( const ref of refsToAssign ) {\n\t\t\tassignRef( ref, value );\n\t\t}\n\t}, [] );\n}\n"]}